{% extends "base.html" %}

{% block title %}DSO Altitude Tracker{% endblock %}

{% block head_extra %}
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
        font-family: 'Roboto', sans-serif;
        padding: 20px;
        margin: 0;
        background-color: #ffffff;
        color: #333;
    }


    .tab-container {
        display: flex;
        margin-bottom: 15px;
        border-bottom: 2px solid #ccc;
    }

    .tab-button {
        padding: 10px 20px;
        cursor: pointer;
        border: 1px solid #ccc;
        border-bottom: none;
        background-color: #e9e9e9;
        margin-right: 5px;
        border-radius: 5px 5px 0 0;
        font-size: 16px;
    }

    .tab-button.active {
        background-color: #fff;
        border-color: #ccc;
        border-bottom: 2px solid #fff;
        position: relative;
        top: 1px;
    }


    table {
        width: max-content;       /* allow natural column widths */
        min-width: 100%;          /* but never smaller than the viewport */
        border-collapse: collapse;
        border: 1px solid #ddd;
        table-layout: fixed;      /* honor explicit widths and prevent reflow jitter */
        word-wrap: break-word;
    }
    th, td { border: 1px solid #ddd; padding: 6px; font-size: 15px; }


    th[data-column-key="Object"],
    td[data-column-key="Object"] {
        width: 120px;
        min-width: 120px;
        text-align: left;
    }
    th[data-column-key="Common Name"],
    td[data-column-key="Common Name"] {
        width: 220px;             /* hard width so it won't collapse */
        min-width: 220px;         /* enforce a floor */
        text-align: left;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

     th[data-column-key="Altitude Current"], td[data-column-key="Altitude Current"],
    th[data-column-key="Azimuth Current"], td[data-column-key="Azimuth Current"],
    th[data-column-key="Altitude 11PM"], td[data-column-key="Altitude 11PM"],
    th[data-column-key="Azimuth 11PM"], td[data-column-key="Azimuth 11PM"],
    th[data-column-key="Observable Duration (min)"], td[data-column-key="Observable Duration (min)"],
    th[data-column-key="Max Altitude (°)"], td[data-column-key="Max Altitude (°)"],
    th[data-column-key="Angular Separation (°)"], td[data-column-key="Angular Separation (°)"] {
        width: 100px;
        min-width: 100px;
        text-align: center;
    }
    th[data-column-key="Trend"], td[data-column-key="Trend"] {
        width: 70px;
        min-width: 70px;
        text-align: center;
    }
    th[data-column-key="Transit Time"], td[data-column-key="Transit Time"] {
        width: 80px;
        min-width: 80px;
        text-align: center;
    }

    th[data-column-key="Type"], td[data-column-key="Type"],
    th[data-column-key="Magnitude"], td[data-column-key="Magnitude"],
    th[data-column-key="Size"], td[data-column-key="Size"],
    th[data-column-key="SB"], td[data-column-key="SB"] {
        width: 100px;
        min-width: 100px;
        text-align: center;
    }



    #data-table th:not([data-column-key="Object"]):not([data-column-key="Common Name"]),
    #data-table td:not([data-column-key="Object"]):not([data-column-key="Common Name"]) {
        text-align: center;
    }

    #data-table > thead > tr:not(.filter-row) > th,
    #journal-data-table > thead > tr:not(.filter-row) > th,
    #outlook-table > thead > tr:not(.filter-row) > th {
        background-color: #f2f2f2;
        font-weight: normal;
        cursor: pointer;
        min-height: 45px;
        vertical-align: middle;
        padding-top: 8px;
        padding-bottom: 8px;
    }

    th span { display: block; font-weight: bold; font-size: 13px; line-height: 1.3; }
    th span.subtext {
      font-weight: normal;
      font-size: 12px;
      line-height: 1.3;
      display: block;
    }
    #data-body td, #journal-data-body td, #outlook-body td {
        line-height: 1.4;
    }


    .highlight { background-color: #83b4c5; }
    tr.clickable-row:hover { background-color: #f1f1f1; cursor: pointer; }
    #graph-section { display: none; text-align: left; margin-left: 0px; }
    #back-button {
      margin-top: 0px;
      padding: 10px 20px;
      font-size: 16px;
      background-color: #83b4c5;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    #back-button:hover { background-color: #6795a4 !important; }

    .info-bar-wrapper {
        display: flex;
        flex-direction: column;
        margin-bottom: 20px;
    }

    .user-info {
      font-size:14px;
      color:#444;
      margin-bottom:10px;
    }
    .user-info button {
        margin-left:6px;
        padding:4px 10px;
        font-size:13px;
        background:#83b4c5;
        color:white;
        border:none;
        border-radius:4px;
        cursor:pointer;
    }
    .user-info button:hover {
        background:#6795a4;
    }

    .info-bar-container {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 20px;
    }

    .info-bar-location-datetime-group {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 15px;
        flex-grow: 1;
        justify-content: flex-start;
    }
     .info-bar-location-datetime-group > p,
     .info-bar-location-datetime-group > .info-values {
        margin: 0;
    }

    .filter-row th {
        background-color: #f2f2f2;
        vertical-align: top;
    }
    .filter-row input {
      width: 95%;
      box-sizing: border-box;
      padding: 4px;
      font-size: 13px;
      font-family: 'Roboto', sans-serif;
      margin-top: 2px;
      margin-bottom: 2px;
    }
    #location-select {
      height: 35px;
      font-size: 16px;
      padding: 5px;
      box-sizing: border-box;
      font-family: 'Roboto', sans-serif;
    }

    .info-values p { margin: 0; font-size: 16px; }
    .info-values small { font-size: 12px; color: #666; }
    .info-values span { font-weight: bold; font-size: 16px; color: #000; }
    .info-values {
        display: flex;
        flex-wrap: wrap;
        gap: 10px 20px;
        align-items: center;
    }
    .table-wrapper { overflow-x: auto; margin-bottom: 20px; }
    .table-wrapper::-webkit-scrollbar { height: 8px; }
    .table-wrapper::-webkit-scrollbar-thumb { background: #ccc; border-radius: 4px; }
    .table-wrapper::-webkit-scrollbar-thumb:hover { background: #888; }

    th .sort-indicator { font-size: 0.8em; margin-left: 5px; display: inline-block; }


    #journal-data-table th,
    #journal-data-table td {
        text-align: center;
        vertical-align: middle;
    }


    #journal-data-table th[data-journal-column-key="target_object_id"],
    #journal-data-table td[data-journal-column-key="target_object_id"],
    #journal-data-table th[data-journal-column-key="target_common_name"],
    #journal-data-table td[data-journal-column-key="target_common_name"],
    #journal-data-table th[data-journal-column-key="location_name"],
    #journal-data-table td[data-journal-column-key="location_name"],
    #journal-data-table th[data-journal-column-key="session_date"],
    #journal-data-table th[data-journal-column-key="telescope_setup_notes"],
    #journal-data-table td[data-journal-column-key="telescope_setup_notes"] {
        text-align: left;
    }


    #journal-data-table th[data-journal-column-key="target_object_id"],
    #journal-data-table td[data-journal-column-key="target_object_id"] { width: 120px; min-width: 120px; }
    #journal-data-table th[data-journal-column-key="target_common_name"],
    #journal-data-table td[data-journal-column-key="target_common_name"] { min-width: 150px; }
    #journal-data-table th[data-journal-column-key="session_date"],
    #journal-data-table td[data-journal-column-key="session_date"] { width: 100px; min-width: 100px; }
    #journal-data-table th[data-journal-column-key="location_name"],
    #journal-data-table td[data-journal-column-key="location_name"] { min-width: 100px; width: 110px; text-align: left; }
    #journal-data-table th[data-journal-column-key="telescope_setup_notes"],
    #journal-data-table td[data-journal-column-key="telescope_setup_notes"] { min-width: 200px; }
    #journal-data-table th[data-journal-column-key="calculated_integration_time_minutes"],
    #journal-data-table td[data-journal-column-key="calculated_integration_time_minutes"] { width: 100px; min-width: 100px; }
    #journal-data-table th[data-journal-column-key="session_rating_subjective"],
    #journal-data-table td[data-journal-column-key="session_rating_subjective"] { width: 100px; min-width: 100px; }
    #journal-data-table .filter-row input { text-align: left; }

    #remove-filters-container {
      margin-left: auto;
      align-self: center;
    }

    #remove-filters-btn {
      padding: 10px 20px;
      font-size: 16px;
      background-color: #a1b0b4;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    #remove-filters-btn:hover { background-color: #849398 !important; }

    th[data-column-key="Type"], td[data-column-key="Type"],
    th[data-column-key="Magnitude"], td[data-column-key="Magnitude"],
    th[data-column-key="Size"], td[data-column-key="Size"],
    th[data-column-key="SB"], td[data-column-key="SB"],
    th[data-column-key="Constellation"], td[data-column-key="Constellation"] {
        width: 100px;
        min-width: 100px;
        text-align: center;
    }


    #outlook-table th[data-outlook-column-key="object_name"],
    #outlook-table td[data-outlook-column-key="object_name"],
    #outlook-table th[data-outlook-column-key="common_name"],
    #outlook-table td[data-outlook-column-key="common_name"] { text-align: left; }
    #outlook-table th[data-outlook-column-key="object_name"],
    #outlook-table td[data-outlook-column-key="object_name"] { width: 120px; min-width: 120px; }
    #outlook-table th[data-outlook-column-key="common_name"],
    #outlook-table td[data-outlook-column-key="common_name"] { min-width: 150px; }
    #outlook-table th[data-outlook-column-key="date"],
    #outlook-table td[data-outlook-column-key="date"],
    #outlook-table th[data-outlook-column-key="max_alt"],
    #outlook-table td[data-outlook-column-key="max_alt"],
    #outlook-table th[data-outlook-column-key="obs_dur"],
    #outlook-table td[data-outlook-column-key="obs_dur"],
    #outlook-table th[data-outlook-column-key="rating"],
    #outlook-table td[data-outlook-column-key="rating"] {
        width: 110px;
        min-width: 110px;
        text-align: center;
    }
    #outlook-table > thead > tr:not(.filter-row) > th > span:not(.sort-indicator)::after {
        content: '\00a0';
        display: block;
        font-size: 12px;
        font-weight: normal;
    }


    .message { color: #155724; font-weight: bold; }
    .error { color: #dc3545; font-weight: bold; }
    #tab-message-container {
      margin-left: auto;
      align-self: center;
    }


  </style>

  <script>
    // ========================================================================
    // Configuration & Global State Variables
    // ========================================================================
    let activeTab = localStorage.getItem('activeTab') || 'position';
    let outlookDataLoaded = false;
    let isUpdatingLocation = false;

    let allOutlookOpportunities = []; // To store the full list of results
    let currentOutlookSort = { columnKey: 'date', ascending: true }; // Default sort
    const outlookColumnConfig = {
        'object_name':  { dataKey: 'object_name',  sortable: true, filterable: true, numeric: false },
        'common_name':  { dataKey: 'common_name',  sortable: true, filterable: true, numeric: false },
        'date':         { dataKey: 'date',    sortable: true, filterable: true, numeric: false },
        'max_alt':      { dataKey: 'max_alt',      sortable: true, filterable: true, numeric: true },
        'obs_dur':      { dataKey: 'obs_dur',      sortable: true, filterable: true, numeric: true },
        'rating':       { dataKey: 'rating',       sortable: true, filterable: true, numeric: false },
        'score':        { dataKey: 'score',        sortable: true, filterable: false, numeric: true },
        'type':         { dataKey: 'type' },
        'constellation':{ dataKey: 'constellation' },
        'magnitude':    { dataKey: 'magnitude', numeric: true },
        'size':         { dataKey: 'size', numeric: true },
        'sb':           { dataKey: 'sb', numeric: true }
    };

    // --- DSO Table Configuration ---
    let currentSort = { columnKey: 'Altitude Current', ascending: false };
    const columnConfig = {
        'Object':           { header: 'Object<br><span class="subtext">&nbsp;</span>', dataKey: 'Object', type: 'always-visible', filterable: true, sortable: true },
        'Common Name':      { header: 'Common Name<br><span class="subtext">&nbsp;</span>', dataKey: 'Common Name', type: 'always-visible', filterable: true, sortable: true },
        'Altitude Current': { header: 'Altitude<br><span class="subtext">(Current)</span>', dataKey: 'Altitude Current', type: 'position', filterable: true, sortable: true, format: val => (val === 'N/A' || val === null || val === undefined) ? 'N/A' : `${parseFloat(val).toFixed(2)}°` },
        'Azimuth Current':  { header: 'Azimuth <br><span class="subtext">(Current)</span>', dataKey: 'Azimuth Current', type: 'position', filterable: true, sortable: true, format: val => (val === 'N/A' || val === null || val === undefined) ? 'N/A' : `${parseFloat(val).toFixed(2)}°` },
        'Trend':            { header: 'Trend<br><span class="subtext">&nbsp;</span>', dataKey: 'Trend', type: 'position', filterable: false, sortable: true },
        'Altitude 11PM':    { header: 'Altitude <br><span class="subtext">(11 PM)</span>', dataKey: 'Altitude 11PM', type: 'position', filterable: true, sortable: true, format: val => (val === 'N/A' || val === null || val === undefined) ? 'N/A' : `${parseFloat(val).toFixed(2)}°` },
        'Azimuth 11PM':     { header: 'Azimuth <br><span class="subtext">(11 PM)</span>', dataKey: 'Azimuth 11PM', type: 'position', filterable: true, sortable: true, format: val => (val === 'N/A' || val === null || val === undefined) ? 'N/A' : `${parseFloat(val).toFixed(2)}°` },
        'Transit Time':     { header: 'Transit <br><span class="subtext">(Local Time)</span>', dataKey: 'Transit Time', type: 'position', filterable: false, sortable: true },
        'Observable Duration (min)': { header: 'Observable <br><span class="subtext">(minutes)</span>', dataKey: 'Observable Duration (min)', type: 'position', filterable: true, sortable: true, format: val => (val === 'N/A' || val === null || val === undefined) ? 'N/A' : String(val) },
        'Max Altitude (°)': { header: 'Max Altitude<br><span class="subtext">observable (°)</span>', dataKey: 'Max Altitude (°)', type: 'position', filterable: true, sortable: true, format: val => (val === 'N/A' || val === null || val === undefined || isNaN(Number(val))) ? 'N/A' : `${Number(val).toFixed(1)}°` },
        'Angular Separation (°)': { header: 'Ang. Sep. <br><span class="subtext">to moon (°)</span>', dataKey: 'Angular Separation (°)', type: 'position', filterable: true, sortable: true, format: val => (val === 'N/A' || val === null || val === undefined || isNaN(Number(val))) ? 'N/A' : `${parseInt(val)}°` },
        'Constellation':    { header: 'Con<br><span class="subtext">&nbsp;</span>', dataKey: 'Constellation', type: 'properties', filterable: true, sortable: true },
        'Type':             { header: 'Type<br><span class="subtext">&nbsp;</span>', dataKey: 'Type', type: 'properties', filterable: true, sortable: true },
        'Magnitude':        { header: 'Magnitude<br><span class="subtext">&nbsp;</span>', dataKey: 'Magnitude', type: 'properties', filterable: true, sortable: true, format: val => (val === 'N/A' || val === null || val === undefined || isNaN(Number(val))) ? 'N/A' : parseFloat(val).toFixed(1) },
        'Size':             { header: "Size (')<br><span class='subtext'>&nbsp;</span>", dataKey: 'Size', type: 'properties', filterable: true, sortable: true, format: val => (val === 'N/A' || val === null || val === undefined || isNaN(Number(val))) ? 'N/A' : parseFloat(val).toFixed(1) },
        'SB':               { header: 'SB<br><span class="subtext">&nbsp;</span>', dataKey: 'SB', type: 'properties', filterable: true, sortable: true, format: val => (val === 'N/A' || val === null || val === undefined || isNaN(Number(val))) ? 'N/A' : parseFloat(val).toFixed(1) }
    };

    // --- Journal Table Configuration ---
    const allJournalSessions = {{ journal_sessions | tojson | safe }};
    let currentJournalSort = { columnKey: 'session_date', ascending: false };
    const journalColumnConfig = {
        'target_object_id': { headerText: 'Object', dataKey: 'target_object_id', sortable: true, filterable: true },
        'target_common_name': { headerText: 'Common Name', dataKey: 'target_common_name', sortable: true, filterable: true },
        'session_date': { headerText: 'Date', dataKey: 'session_date', sortable: true, filterable: true, format: formatDateISOtoEuropean },
        'location_name': { headerText: 'Location', dataKey: 'location_name', sortable: true, filterable: true },
        'telescope_setup_notes': { headerText: 'Telescope Setup', dataKey: 'telescope_setup_notes', sortable: true, filterable: true, format: val => (val === 'N/A' || val === null || val === undefined || (typeof val === 'string' && val.trim() === '')) ? 'N/A' : String(val).substring(0, 60) + (String(val).length > 60 ? '...' : '') }, // New field, added a simple truncate
        'calculated_integration_time_minutes': { headerText: 'Total Integration', dataKey: 'calculated_integration_time_minutes', sortable: true, filterable: true, format: val => (val === 'N/A' || val === null || val === undefined || isNaN(Number(val))) ? 'N/A' : `${Number(val).toFixed(0)} min` },
        'session_rating_subjective': { headerText: 'Session Rating', dataKey: 'session_rating_subjective', sortable: true, filterable: true, format: val => (val === 'N/A' || val === null || val === undefined) ? 'N/A' : `${String(val)} ★` }
    };

    // ========================================================================
    // Helper Functions
    // ========================================================================
    function formatDateISOtoEuropean(isoStr) {
      if (!isoStr || typeof isoStr !== 'string') return 'N/A';
      const parts = isoStr.split("-");
      if (parts.length !== 3) return isoStr;
      const [year, month, day] = parts;
      return `${day}.${month}.${year}`;
    }

    function parseTimeToMinutes(timeStr) {
      if (!timeStr || typeof timeStr !== 'string' || !/^\d{1,2}:\d{2}$/.test(timeStr)) return 0;
      const [h, m] = timeStr.split(':').map(Number);
      return h * 60 + m;
    }
    function updateRemoveFiltersButtonVisibility() {
        const btnContainer = document.getElementById('remove-filters-container');
        if (!btnContainer) return;

        let isAnyFilterActive = false;
        const allFilterInputs = document.querySelectorAll('#data-table .filter-row input, #journal-filter-row input');

        for (const input of allFilterInputs) {
            // Check only filterable inputs
            if (input.value.trim() !== '') {
                isAnyFilterActive = true;
                break; // Found an active filter, no need to check further
            }
        }
        btnContainer.style.display = isAnyFilterActive ? 'block' : 'none';
    }

    function clearAllFilters() {
        // Clear DSO filters
        for (const key in columnConfig) {
            if (columnConfig[key].filterable) {
                const inputEl = document.querySelector(`#data-table .filter-row th[data-column-key="${key}"] input`);
                if (inputEl) inputEl.value = '';
                localStorage.removeItem("dso_filter_col_key_" + key);
            }
        }

        // Clear Journal filters
        for (const key in journalColumnConfig) {
            if (journalColumnConfig[key].filterable) {
                const inputEl = document.querySelector(`#journal-filter-row th[data-journal-column-key="${key}"] input`);
                if (inputEl) inputEl.value = '';
                localStorage.removeItem("journal_filter_col_key_" + key);
            }
        }

        // Refresh the tables to reflect the cleared filters
        filterTable();
        filterJournalTable();
    }

    // ========================================================================
    // Tab Display Logic
    // ========================================================================
    function updateTabDisplay() {
        const dsoTableWrapper = document.getElementById('dso-table-wrapper');
        const dsoLoadingDiv = document.getElementById('table-loading');
        const journalTableWrapper = document.getElementById('journal-table-wrapper');
        const outlookWrapper = document.getElementById('outlook-wrapper');

        document.querySelectorAll('.tab-button').forEach(button => {
            button.classList.toggle('active', button.dataset.tab === activeTab);
        });

        if (dsoTableWrapper) dsoTableWrapper.style.display = 'none';
        if (dsoLoadingDiv) dsoLoadingDiv.style.display = 'none';
        if (journalTableWrapper) journalTableWrapper.style.display = 'none';
        if (outlookWrapper) outlookWrapper.style.display = 'none';

        if (dsoLoadingDiv) dsoLoadingDiv.style.display = 'none';

        if (activeTab === 'position' || activeTab === 'properties') {
            if (dsoTableWrapper) dsoTableWrapper.style.display = 'block';
            applyDsoColumnVisibility();
            const dsoTableBody = document.getElementById('data-body');
            if (dsoTableBody && dsoTableBody.innerHTML.trim() === '') {
                if (dsoLoadingDiv) dsoLoadingDiv.style.display = 'block';
            }
        } else if (activeTab === 'journal') {
            if (journalTableWrapper) journalTableWrapper.style.display = 'block';
            populateJournalTable();
        } else if (activeTab === 'outlook') {
            if (outlookWrapper) outlookWrapper.style.display = 'block';
            if (!outlookDataLoaded) fetchOutlookData();
        }

        localStorage.setItem('activeTab', activeTab);
        updateRemoveFiltersButtonVisibility();
    }

    function applyDsoColumnVisibility() {
        const headers = document.querySelectorAll("#data-table > thead > tr:not(.filter-row) > th[data-column-key]");
        const filterCells = document.querySelectorAll("#data-table .filter-row th[data-column-key]");
        const tableBodyRows = document.querySelectorAll("#data-body tr");

        headers.forEach(th => {
            const columnKey = th.dataset.columnKey;
            const config = columnConfig[columnKey];
            if (config) {
                th.style.display = (config.type === 'always-visible' || config.type === activeTab) ? 'table-cell' : 'none';
            }
        });
        filterCells.forEach(thFilter => {
            const columnKey = thFilter.dataset.columnKey;
            const config = columnConfig[columnKey];
            const input = thFilter.querySelector('input');
            let show = false;
            if (config) {
                show = (config.type === 'always-visible' || config.type === activeTab);
                thFilter.style.display = show ? 'table-cell' : 'none';
                if (input) {
                    input.disabled = !show || !config.filterable;
                    input.style.visibility = show && config.filterable ? 'visible' : 'hidden';
                }
            }
        });
        tableBodyRows.forEach(row => {
            const cells = row.querySelectorAll('td[data-column-key]');
            cells.forEach(td => {
                const columnKey = td.dataset.columnKey;
                const config = columnConfig[columnKey];
                if (config) {
                    td.style.display = (config.type === 'always-visible' || config.type === activeTab) ? 'table-cell' : 'none';
                }
            });
        });
    }

    // ========================================================================
    // DSO Table Functions (NEW, CORRECTED VERSION)
    // ========================================================================


    async function fetchData() {
        const tbody = document.getElementById("data-body");
        const loadingDiv = document.getElementById("table-loading");
        if (!tbody || !loadingDiv || tbody.dataset.loading === 'true') return;

        tbody.dataset.loading = 'true';
        try {
            if (tbody.innerHTML.trim() === '') loadingDiv.style.display = 'block';

            const listResponse = await fetch('/api/get_object_list');
            if (!listResponse.ok) throw new Error(`HTTP error! status: ${listResponse.status}`);
            const listData = await listResponse.json();

            const fetchPromises = listData.objects.map(objName =>
                fetch(`/api/get_object_data/${encodeURIComponent(objName)}`).then(res => res.json())
            );
            const allObjectData = await Promise.all(fetchPromises);

            tbody.innerHTML = ''; // Clear table for new data

            const columnOrder = [
                'Object', 'Common Name', 'Altitude Current', 'Azimuth Current', 'Trend', 'Altitude 11PM',
                'Azimuth 11PM', 'Transit Time', 'Observable Duration (min)', 'Max Altitude (°)',
                'Angular Separation (°)', 'Constellation', 'Type', 'Magnitude', 'Size', 'SB'
            ];

            const altitudeThreshold = {{ g.altitude_threshold | default(20) }};

            allObjectData.forEach(objectData => {
                if (!objectData || objectData.error) {
                    console.error("Error in object data:", objectData);
                    return;
                }

                const sanitizedId = objectData.Object.replace(/\s+/g, '-');
                const row = document.createElement('tr');
                row.id = `row-${sanitizedId}`;
                row.className = 'clickable-row';

                if (objectData['Common Name'] && objectData['Common Name'].toLowerCase().startsWith("error:")) {
                    row.style.backgroundColor = "#f8d7da";
                } else if (objectData.Project && objectData.Project.toLowerCase() !== "none" && objectData.Project.trim() !== "") {
                    row.style.backgroundColor = "#dce5ea";
                }

                row.onclick = () => {
                    if (objectData['Common Name'] && objectData['Common Name'].toLowerCase().startsWith("error:")) {
                        alert("Graph not available: " + objectData['Common Name']);
                        return;
                    }
                    showGraph(objectData.Object);
                };

                columnOrder.forEach(columnKey => {
                    const config = columnConfig[columnKey];
                    const td = document.createElement('td');
                    td.dataset.columnKey = columnKey;

                    // --- FIX #1: Force correct text alignment ---
                    if (columnKey === 'Object' || columnKey === 'Common Name') {
                        td.style.textAlign = 'left';
                    } else {
                        td.style.textAlign = 'center';
                    }

                    const rawValue = objectData[config.dataKey];
                    let displayValue = (rawValue === null || rawValue === undefined || String(rawValue).trim() === '') ? 'N/A' : (config.format ? config.format(rawValue) : rawValue);

                    // --- FIX #2: Display plain text instead of a link for the 'Object' column ---
                    td.textContent = displayValue;
                    if (columnKey === 'Common Name') {
                        // Preserve full value on hover for mobile/desktop
                        td.setAttribute('title', (rawValue === null || rawValue === undefined) ? '' : String(rawValue));
                    }

                    // --- FIX #3: This will now use your original BLUE highlight color ---
                    if ((config.dataKey === 'Altitude Current' || config.dataKey === 'Altitude 11PM') && parseFloat(rawValue) >= altitudeThreshold) {
                        td.classList.add('highlight');
                    }

                    const numericSortKeys = ['Altitude Current', 'Azimuth Current', 'Altitude 11PM', 'Azimuth 11PM', 'Observable Duration (min)', 'Max Altitude (°)', 'Angular Separation (°)', 'Magnitude', 'Size', 'SB'];
                    if (numericSortKeys.includes(config.dataKey) && (typeof rawValue === 'number' || (typeof rawValue === 'string' && !isNaN(parseFloat(rawValue))))) {
                        td.dataset.rawValue = parseFloat(rawValue);
                    } else if (rawValue === 'N/A') {
                        td.dataset.rawValue = 'N/A';
                    }

                    row.appendChild(td);
                });
                tbody.appendChild(row);
            });
        } catch (error) {
            console.error("Failed to fetch and render data:", error);
            tbody.innerHTML = `<tr><td colspan="${columnOrder.length}" style="text-align:center; color:red;">Error loading data.</td></tr>`;
        } finally {
            loadingDiv.style.display = 'none';
            applyDsoColumnVisibility();
            sortTable(currentSort.columnKey, false);
            filterTable();
            tbody.dataset.loading = 'false';
        }
    }

    function sortOutlookTable(columnKey, toggle = true) {
        if (toggle) {
            if (currentOutlookSort.columnKey === columnKey) {
                currentOutlookSort.ascending = !currentOutlookSort.ascending;
            } else {
                currentOutlookSort.columnKey = columnKey;
                currentOutlookSort.ascending = (columnKey === 'date');
            }
        }

        const config = outlookColumnConfig[columnKey];
        if (!config) return;

        allOutlookOpportunities.sort((a, b) => {
            let valA = a[config.dataKey];
            let valB = b[config.dataKey];

            if (config.dataKey === 'date') {
                 return currentOutlookSort.ascending ? new Date(valA) - new Date(valB) : new Date(valB) - new Date(valA);
            }

            if (config.numeric) {
                valA = parseFloat(valA) || 0;
                valB = parseFloat(valB) || 0;
                return currentOutlookSort.ascending ? valA - valB : valB - valA;
            } else {
                return currentOutlookSort.ascending ? String(valA).localeCompare(String(valB)) : String(valB).localeCompare(String(valA));
            }
        });

        document.querySelectorAll('#outlook-table th .sort-indicator').forEach(span => span.innerHTML = '');
        const activeTh = document.querySelector(`#outlook-table th[data-outlook-column-key="${columnKey}"] .sort-indicator`);
        if (activeTh) activeTh.innerHTML = currentOutlookSort.ascending ? '▲' : '▼';

        renderOutlookTable();
    }

    function filterOutlookTable() {
        renderOutlookTable(); // The render function will handle filtering
    }

    function sortTable(columnKey, toggle = true) { // DSO Table Sort
        const table = document.getElementById("data-table");
        if (!table) return;
        let sortOrder;
        if (toggle) {
            if (currentSort.columnKey === columnKey) { currentSort.ascending = !currentSort.ascending; }
            else { currentSort.columnKey = columnKey; currentSort.ascending = true; }
            localStorage.setItem("dso_sortOrder", currentSort.ascending ? "asc" : "desc");
            localStorage.setItem("dso_sortColumnKey", columnKey);
        } else {
            const storedSortOrder = localStorage.getItem("dso_sortOrder");
            const storedSortColumnKey = localStorage.getItem("dso_sortColumnKey");
            if (storedSortColumnKey) {
                currentSort.columnKey = storedSortColumnKey;
                currentSort.ascending = (storedSortOrder === "asc");
            }
        }
        sortOrder = currentSort.ascending ? "asc" : "desc";
        table.setAttribute("data-sort-order", sortOrder);
        const tbody = document.getElementById("data-body");
        if (!tbody) return;
        const rows = Array.from(tbody.getElementsByTagName("tr"));
        const config = columnConfig[currentSort.columnKey];

        rows.sort((a, b) => {
            const cellA_element = a.querySelector(`td[data-column-key="${currentSort.columnKey}"]`);
            const cellB_element = b.querySelector(`td[data-column-key="${currentSort.columnKey}"]`);
            if (!cellA_element || !cellB_element) return 0;
            let valA_str = cellA_element.dataset.rawValue !== undefined ? cellA_element.dataset.rawValue : cellA_element.innerText.trim();
            let valB_str = cellB_element.dataset.rawValue !== undefined ? cellB_element.dataset.rawValue : cellB_element.innerText.trim();
            const isNA_A = valA_str === 'N/A' || valA_str === ''; const isNA_B = valB_str === 'N/A' || valB_str === '';
            if (isNA_A && isNA_B) return 0; if (isNA_A) return currentSort.ascending ? 1 : -1; if (isNA_B) return currentSort.ascending ? -1 : 1;
            let valA = valA_str; let valB = valB_str;
            const numericSortKeys = ['Altitude Current', 'Azimuth Current', 'Altitude 11PM', 'Azimuth 11PM', 'Observable Duration (min)', 'Max Altitude (°)', 'Angular Separation (°)', 'Magnitude', 'Size', 'SB'];
            if (config && numericSortKeys.includes(config.dataKey)) { valA = parseFloat(valA_str); valB = parseFloat(valB_str); }
            else if (currentSort.columnKey === 'Transit Time' && /^\d{1,2}:\d{2}$/.test(valA_str) && /^\d{1,2}:\d{2}$/.test(valB_str)) { valA = parseTimeToMinutes(valA_str); valB = parseTimeToMinutes(valB_str); }
            if (typeof valA === 'number' && typeof valB === 'number') { if (isNaN(valA) && isNaN(valB)) return 0; if (isNaN(valA)) return currentSort.ascending ? 1 : -1; if (isNaN(valB)) return currentSort.ascending ? -1 : 1; return currentSort.ascending ? valA - valB : valB - valA; }
            return currentSort.ascending ? String(valA).localeCompare(String(valB)) : String(valB).localeCompare(String(valA));
        });
        rows.forEach(row => tbody.appendChild(row));
        updateSortIndicators();
    }

    function updateSortIndicators() { // DSO Table
        document.querySelectorAll('#data-table > thead > tr:not(.filter-row) > th .sort-indicator').forEach(span => span.innerHTML = '');
        const activeTh = document.querySelector(`#data-table > thead > tr:not(.filter-row) > th[data-column-key="${currentSort.columnKey}"]`);
        if (activeTh) { const indicator = activeTh.querySelector('.sort-indicator'); if (indicator) indicator.innerHTML = currentSort.ascending ? '▲' : '▼'; }
    }

    function filterTable() { // DSO Table
      const tbody = document.getElementById("data-body");
      if (!tbody) return;
      const rows = tbody.getElementsByTagName("tr");
      const activeFilters = {};
      for (const columnKey in columnConfig) {
        if (columnConfig.hasOwnProperty(columnKey) && columnConfig[columnKey].filterable) {
          const inputElement = document.querySelector(`#data-table .filter-row th[data-column-key="${columnKey}"] input`);
          if (inputElement && inputElement.value.trim() !== '') {
            activeFilters[columnKey] = inputElement.value.trim().toLowerCase();
          }
        }
      }
      for (let i = 0; i < rows.length; i++) {
        let showRow = true;
        for (const columnKeyInFilter in activeFilters) {
            const filterValue = activeFilters[columnKeyInFilter]; const config = columnConfig[columnKeyInFilter];
            if (!config) continue;
            const cellElement = rows[i].querySelector(`td[data-column-key="${columnKeyInFilter}"]`);
            if (!cellElement) { showRow = false; break; }
            let cellText = (cellElement.dataset.rawValue || cellElement.innerText).trim().toLowerCase();
            if (filterValue === "n/a" || filterValue === "na") { if (cellText !== "n/a") { showRow = false; break; } continue; }
            if (config.dataKey === 'Type') {
                const filterTypes = filterValue.split(/[\s,]+/).filter(t => t.length > 0);
                if (filterTypes.length > 0) { let typeMatch = false; for (const typeTerm of filterTypes) { if (cellText === typeTerm || cellText.includes(typeTerm)) { typeMatch = true; break; } } if (!typeMatch) { showRow = false; break; } }
            } else {
                const numericFilterKeys = ['Altitude Current', 'Azimuth Current', 'Altitude 11PM', 'Azimuth 11PM', 'Observable Duration (min)', 'Max Altitude (°)', 'Angular Separation (°)', 'Magnitude', 'Size', 'SB'];
                if (config && numericFilterKeys.includes(config.dataKey)) {
                    if (cellText === "n/a") { showRow = false; break; } const cellNumber = parseFloat(cellText.replace(/[^0-9\.\-]/g, ""));
                    if (isNaN(cellNumber)) { if (cellText.indexOf(filterValue) === -1) {showRow = false; break;} continue; }
                    const conditions = filterValue.split(" ").filter(cond => cond !== ""); let conditionMetOverall = true;
                    for (let cond of conditions) {
                        let operator = ""; let valueStr = "";
                        if (cond.startsWith(">=")) { operator = ">="; valueStr = cond.substring(2); } else if (cond.startsWith("<=")) { operator = "<="; valueStr = cond.substring(2); }
                        else if (cond.startsWith(">")) { operator = ">"; valueStr = cond.substring(1); } else if (cond.startsWith("<")) { operator = "<"; valueStr = cond.substring(1); }
                        else { if (String(cellNumber).indexOf(cond) === -1 && cellText.indexOf(cond) === -1) { conditionMetOverall = false; break; } continue; }
                        let conditionValue = parseFloat(valueStr); if (isNaN(conditionValue)) { conditionMetOverall = false; break; }
                        let currentConditionMet = false;
                        if (operator === ">" && cellNumber > conditionValue) currentConditionMet = true; else if (operator === ">=" && cellNumber >= conditionValue) currentConditionMet = true;
                        else if (operator === "<" && cellNumber < conditionValue) currentConditionMet = true; else if (operator === "<=" && cellNumber <= conditionValue) currentConditionMet = true;
                        if (!currentConditionMet) { conditionMetOverall = false; break;}
                    } if (!conditionMetOverall) { showRow = false; break; }
                } else { if (filterValue.startsWith("!")) { if (cellText.includes(filterValue.substring(1))) { showRow = false; break; } } else { if (!cellText.includes(filterValue)) { showRow = false; break; } } }
            }
        } rows[i].style.display = showRow ? "" : "none";
      }
      updateRemoveFiltersButtonVisibility();
      if (outlookDataLoaded) { renderOutlookTable(); }
    }

    function saveFilter(inputElement, columnKey, tableType = 'dso') {
      localStorage.setItem(tableType + "_filter_col_key_" + columnKey, inputElement.value);
    }

    function showGraph(objectName, dateStr = null) {
        let url = '/graph_dashboard/' + encodeURIComponent(objectName);

        if (dateStr) {
            const parts = dateStr.split('-');
            if (parts.length === 3) {
                const year = parts[0];
                const month = parts[1];
                const day = parts[2];
                url += `?year=${year}&month=${month}&day=${day}`;
            }
        }
        window.location.href = url;
    }

    function fetchLocations() {
        fetch('/get_locations')
        .then(response => response.json())
        .then(data => {
          let locationSelect = document.getElementById('location-select');
          if (!locationSelect) return;
          locationSelect.innerHTML = '';
          data.locations.forEach(location => {
            let option = document.createElement('option'); option.value = location; option.textContent = location;
            if (location === data.selected) option.selected = true;
            locationSelect.appendChild(option);
          });
        })
        .catch(error => console.error('❌ Error fetching locations:', error));
    }

    function setLocation() {
        isUpdatingLocation = true; // <-- Set flag to true
        const selectedLocation = document.getElementById('location-select').value;
        outlookDataLoaded = false;

        document.getElementById('data-body').innerHTML = '';
        document.getElementById('journal-data-body').innerHTML = '';
        document.getElementById('outlook-body').innerHTML = '';

        const loadingDiv = document.getElementById('table-loading');
        if (loadingDiv) {
            loadingDiv.innerHTML = "Updating location...";
            loadingDiv.style.display = "block";
        }

        fetch('/set_location', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ location: selectedLocation })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                fetchData();
                fetchSunEvents();
                if (activeTab === 'journal') {
                    populateJournalTable();
                } else if (activeTab === 'outlook') {
                    fetchOutlookData();
                }
            } else {
                console.error("❌ Location update failed:", data);
                if (loadingDiv) {
                    loadingDiv.textContent = "❌ Error updating location.";
                }
            }
        })
        .catch(error => {
            console.error('❌ Error setting location:', error);
            if (loadingDiv) {
                loadingDiv.textContent = "❌ Error setting location.";
            }
        })
        .finally(() => {
            isUpdatingLocation = false; // <-- Set flag to false when done
        });
    }

    function fetchSunEvents() {
        fetch('/sun_events')
        .then(response => response.json())
        .then(data => {
          document.getElementById('dawn').textContent = data.astronomical_dawn;
          document.getElementById('dusk').textContent = data.astronomical_dusk;
          const dateEl = document.getElementById('date');
          const timeEl = document.getElementById('time');
          const phaseEl = document.getElementById('phase');
          if(dateEl && data.date) dateEl.textContent = formatDateISOtoEuropean(data.date);
          if(timeEl && data.time) timeEl.textContent = data.time;
          if(phaseEl && data.phase !== undefined) phaseEl.textContent = `${data.phase}%`;
        })
        .catch(error => { console.error('❌ Error fetching sun events:', error);});
    }

    // ========================================================================
    // Journal Table Functions
    // ========================================================================
    function populateJournalTable() {
        const tableBody = document.getElementById('journal-data-body');
        if (!tableBody || !allJournalSessions) return;
        let sessionsToDisplay = [...allJournalSessions];
        const journalFilterInputs = document.querySelectorAll("#journal-filter-row input");
        const activeJournalFilters = {};
        journalFilterInputs.forEach(input => {
            const thParent = input.closest('th');
            if (thParent) {
                const columnKey = thParent.dataset.journalColumnKey;
                const value = input.value.trim().toLowerCase();
                if (value !== '') activeJournalFilters[columnKey] = value;
            }
        });
        const journalNumericFilterKeys = ['calculated_integration_time_minutes','guiding_rms_avg_arcsec','seeing_observed_fwhm','session_rating_subjective'];
        if (Object.keys(activeJournalFilters).length > 0) {
            sessionsToDisplay = sessionsToDisplay.filter(session => {
                for (const key in activeJournalFilters) {
                    const filterValue = activeJournalFilters[key];
                    const config = journalColumnConfig[key];
                    if (!config) continue;
                    let rawSessionValueStr = String(session[config.dataKey] || '').toLowerCase();
                    let formattedSessionValueStr = "";
                    if (config.dataKey === 'session_date') {
                        rawSessionValueStr = session[config.dataKey] || "";
                        if (rawSessionValueStr && config.format) { formattedSessionValueStr = config.format(rawSessionValueStr).toLowerCase(); }
                    } else if (config.dataKey === 'calculated_integration_time_minutes') {
                        rawSessionValueStr = String(session.calculated_integration_time_minutes === undefined || session.calculated_integration_time_minutes === null ? 'N/A' : session.calculated_integration_time_minutes).toLowerCase();
                    }
                    if (filterValue === "n/a" || filterValue === "na") { if (rawSessionValueStr !== "n/a" && rawSessionValueStr !== "") return false; continue; }
                    if (config.dataKey === 'session_date') {
                        const sessionDateString_YYYY_MM_DD = session[config.dataKey] || "";
                        if (!sessionDateString_YYYY_MM_DD) return false;
                        let operator = null; let dateFilterStringUserInput = filterValue;
                        if (dateFilterStringUserInput.startsWith(">=")) { operator = ">="; dateFilterStringUserInput = dateFilterStringUserInput.substring(2).trim(); }
                        else if (dateFilterStringUserInput.startsWith("<=")) { operator = "<="; dateFilterStringUserInput = dateFilterStringUserInput.substring(2).trim(); }
                        else if (dateFilterStringUserInput.startsWith(">")) { operator = ">"; dateFilterStringUserInput = dateFilterStringUserInput.substring(1).trim(); }
                        else if (dateFilterStringUserInput.startsWith("<")) { operator = "<"; dateFilterStringUserInput = dateFilterStringUserInput.substring(1).trim(); }
                        else { dateFilterStringUserInput = dateFilterStringUserInput.trim(); }
                        try {
                            let filterDateObj = null;
                            if (dateFilterStringUserInput.includes('.')) { const parts = dateFilterStringUserInput.split('.'); if (parts.length === 3 && parts.every(p => !isNaN(parseInt(p)))) { filterDateObj = new Date(Date.UTC(parseInt(parts[2]), parseInt(parts[1]) - 1, parseInt(parts[0]))); } }
                            else if (dateFilterStringUserInput.includes('-')) { const parts = dateFilterStringUserInput.split('-'); if (parts.length === 3 && parts.every(p => !isNaN(parseInt(p)))) { filterDateObj = new Date(Date.UTC(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]))); } else if (parts.length === 2 && parts.every(p => !isNaN(parseInt(p)))) { filterDateObj = new Date(Date.UTC(parseInt(parts[0]), parseInt(parts[1]) - 1, 1)); } else if (parts.length === 1 && /^\d{4}$/.test(parts[0])) { filterDateObj = new Date(Date.UTC(parseInt(parts[0]), 0, 1)); } }
                            else if (/^\d{4}$/.test(dateFilterStringUserInput) && !operator) {} else if (dateFilterStringUserInput.length > 0 && operator) { return false; }
                            const sessionParts = sessionDateString_YYYY_MM_DD.split('-'); if (sessionParts.length !== 3) return false;
                            const sessionDateObj = new Date(Date.UTC(parseInt(sessionParts[0]), parseInt(sessionParts[1]) - 1, parseInt(sessionParts[2])));
                            if (isNaN(sessionDateObj.getTime())) { return false; }
                            if (operator && filterDateObj && !isNaN(filterDateObj.getTime())) {
                                if (operator === ">=" && sessionDateObj < filterDateObj) return false; if (operator === "<=" && sessionDateObj > filterDateObj) return false;
                                if (operator === ">" && sessionDateObj <= filterDateObj) return false; if (operator === "<" && sessionDateObj >= filterDateObj) return false;
                            } else if (!operator) { const formattedSessionDateForDisplay = formatDateISOtoEuropean(sessionDateString_YYYY_MM_DD).toLowerCase(); if (!sessionDateString_YYYY_MM_DD.includes(dateFilterStringUserInput) && !formattedSessionDateForDisplay.includes(dateFilterStringUserInput)) { return false; } }
                            else if (operator && (!filterDateObj || isNaN(filterDateObj.getTime()))) { return false; }
                        } catch (e) { console.error("Date filter error:", e); return false; }
                        continue;
                    }
                    if (journalNumericFilterKeys.includes(config.dataKey)) {
                        let sessionNumericValue = session[config.dataKey];
                        if (config.dataKey === 'calculated_integration_time_minutes') { sessionNumericValue = session.calculated_integration_time_minutes; }
                        if (sessionNumericValue === 'N/A' || sessionNumericValue === null || sessionNumericValue === undefined) { if (filterValue === "n/a" || filterValue === "na") continue; return false; }
                        const cellNumber = parseFloat(sessionNumericValue);
                        if (isNaN(cellNumber)) { if (!rawSessionValueStr.includes(filterValue)) return false; continue; }
                        const conditions = filterValue.split(" ").filter(cond => cond !== ""); let conditionMetOverall = true;
                        for (let cond of conditions) {
                            let op = ""; let valStr = "";
                            if (cond.startsWith(">=")) { op = ">="; valStr = cond.substring(2); } else if (cond.startsWith("<=")) { op = "<="; valStr = cond.substring(2); }
                            else if (cond.startsWith(">")) { op = ">"; valStr = cond.substring(1); } else if (cond.startsWith("<")) { op = "<"; valStr = cond.substring(1); }
                            else { if (String(cellNumber).indexOf(cond) === -1 && rawSessionValueStr.indexOf(cond) === -1) { conditionMetOverall = false; break; } continue; }
                            let condVal = parseFloat(valStr); if (isNaN(condVal)) { conditionMetOverall = false; break; } let currentCondMet = false;
                            if (op === ">" && cellNumber > condVal) currentCondMet = true; else if (op === ">=" && cellNumber >= condVal) currentCondMet = true;
                            else if (op === "<" && cellNumber < condVal) currentCondMet = true; else if (op === "<=" && cellNumber <= condVal) currentCondMet = true;
                            if (!currentCondMet) { conditionMetOverall = false; break;}
                        }
                        if (!conditionMetOverall) return false;
                    } else { if (filterValue.startsWith("!")) { if (rawSessionValueStr.includes(filterValue.substring(1))) return false; } else { if (!rawSessionValueStr.includes(filterValue)) return false; } }
                } return true;
            });
        }
        const sortConfig = journalColumnConfig[currentJournalSort.columnKey];
        if (sortConfig) {
            sessionsToDisplay.sort((a, b) => {
                let valA_str = String(a[sortConfig.dataKey] === undefined ? '' : a[sortConfig.dataKey]);
                let valB_str = String(b[sortConfig.dataKey] === undefined ? '' : b[sortConfig.dataKey]);
                if (sortConfig.dataKey === 'calculated_integration_time_minutes') {
                    valA_str = String(a.calculated_integration_time_minutes === undefined || a.calculated_integration_time_minutes === 'N/A' ? -Infinity : a.calculated_integration_time_minutes);
                    valB_str = String(b.calculated_integration_time_minutes === undefined || b.calculated_integration_time_minutes === 'N/A' ? -Infinity : b.calculated_integration_time_minutes);
                } else if (sortConfig.dataKey === 'session_date') {
                    valA_str = String(a[sortConfig.dataKey] || '9999-99-99');
                    valB_str = String(b[sortConfig.dataKey] || '9999-99-99');
                } else if (journalNumericFilterKeys.includes(sortConfig.dataKey)) {
                     valA_str = String(a[sortConfig.dataKey] === 'N/A' || a[sortConfig.dataKey] === null || a[sortConfig.dataKey] === undefined ? -Infinity : a[sortConfig.dataKey]);
                     valB_str = String(b[sortConfig.dataKey] === 'N/A' || b[sortConfig.dataKey] === null || b[sortConfig.dataKey] === undefined ? -Infinity : b[sortConfig.dataKey]);
                }
                const isNA_A = valA_str.toLowerCase() === 'n/a' || valA_str === '' || valA_str === String(-Infinity);
                const isNA_B = valB_str.toLowerCase() === 'n/a' || valB_str === '' || valB_str === String(-Infinity);
                if (isNA_A && isNA_B) return 0; if (isNA_A) return currentJournalSort.ascending ? 1 : -1; if (isNA_B) return currentJournalSort.ascending ? -1 : 1;
                let valA = valA_str; let valB = valB_str;
                if (sortConfig.dataKey === 'session_date') {
                    valA = new Date(valA_str); valB = new Date(valB_str);
                     if (isNaN(valA.getTime()) && isNaN(valB.getTime())) return 0;
                     if (isNaN(valA.getTime())) return currentJournalSort.ascending ? 1 : -1;
                     if (isNaN(valB.getTime())) return currentJournalSort.ascending ? -1 : 1;
                    return currentJournalSort.ascending ? valA - valB : valB - valA;
                } else if (journalNumericFilterKeys.includes(sortConfig.dataKey)) {
                    valA = parseFloat(valA_str); valB = parseFloat(valB_str);
                    if (isNaN(valA) && isNaN(valB)) return 0; if (isNaN(valA)) return currentJournalSort.ascending ? 1 : -1; if (isNaN(valB)) return currentJournalSort.ascending ? -1 : 1;
                    return currentJournalSort.ascending ? valA - valB : valB - valA;
                }
                return currentJournalSort.ascending ? String(valA).localeCompare(String(valB)) : String(valB).localeCompare(String(valA));
            });
        }
        tableBody.innerHTML = '';
        let previousTargetIdForGrouping = null;
        sessionsToDisplay.forEach(session => {
            const row = document.createElement('tr'); row.classList.add('clickable-row');
            row.setAttribute('data-session-id', session.session_id); row.setAttribute('data-target-object-id', session.target_object_id);
            let showFullTargetInfoThisRow = true;
            if (currentJournalSort.columnKey === 'target_object_id' || currentJournalSort.columnKey === 'target_common_name') {
                if (session.target_object_id === previousTargetIdForGrouping) { showFullTargetInfoThisRow = false; }
                previousTargetIdForGrouping = session.target_object_id;
            }
            for (const key in journalColumnConfig) {
                const config = journalColumnConfig[key]; const td = document.createElement('td');
                td.dataset.journalColumnKey = key; let rawValue = session[config.dataKey]; let displayValue = "";
                 if (config.dataKey === 'calculated_integration_time_minutes') { rawValue = session.calculated_integration_time_minutes; }
                if (rawValue === null || rawValue === undefined || (typeof rawValue === 'string' && rawValue.trim() === "") || rawValue === 'N/A') { displayValue = "N/A"; }
                else if (config.format) { displayValue = config.format(rawValue); } else { displayValue = String(rawValue); }
                if ((config.dataKey === 'target_object_id' || config.dataKey === 'target_common_name') && !showFullTargetInfoThisRow) { td.innerHTML = ""; }
                else { td.innerHTML = String(displayValue); }
                if (typeof session[config.dataKey] === 'number' && !isNaN(session[config.dataKey])) { td.dataset.rawValue = session[config.dataKey]; }
                else if (config.dataKey === 'calculated_integration_time_minutes' && typeof session.calculated_integration_time_minutes === 'number' && !isNaN(session.calculated_integration_time_minutes) ) { td.dataset.rawValue = session.calculated_integration_time_minutes; }
                row.appendChild(td);
            }
            row.addEventListener('click', function() {
                const targetId = this.getAttribute('data-target-object-id');
                const sessionId = this.getAttribute('data-session-id');
                if (targetId && sessionId) { window.location.href = `/graph_dashboard/${encodeURIComponent(targetId)}?session_id=${encodeURIComponent(sessionId)}`; }
                else { console.warn("Missing targetId or sessionId", session); }
            });
            tableBody.appendChild(row);
        });
        updateJournalSortIndicators();
    }

    function sortJournalTable(columnKey, toggle = true) {
        if (toggle) {
            if (currentJournalSort.columnKey === columnKey) { currentJournalSort.ascending = !currentJournalSort.ascending; }
            else { currentJournalSort.columnKey = columnKey; currentJournalSort.ascending = true; }
            localStorage.setItem("journal_sortOrder", currentJournalSort.ascending ? "asc" : "desc");
            localStorage.setItem("journal_sortColumnKey", columnKey);
        } else {
            const storedSortOrder = localStorage.getItem("journal_sortOrder");
            const storedSortColumnKey = localStorage.getItem("journal_sortColumnKey");
            if (storedSortColumnKey) {
                currentJournalSort.columnKey = storedSortColumnKey;
                currentJournalSort.ascending = (storedSortOrder === "asc");
            }
        }
        populateJournalTable();
    }

    function updateJournalSortIndicators() {
        document.querySelectorAll('#journal-data-table th .sort-indicator').forEach(span => span.innerHTML = '');
        const activeTh = document.querySelector(`#journal-data-table > thead > tr:not(.filter-row) > th[data-journal-column-key="${currentJournalSort.columnKey}"]`);
        if (activeTh) { const indicator = activeTh.querySelector('.sort-indicator'); if (indicator) { indicator.innerHTML = currentJournalSort.ascending ? '▲' : '▼'; } }
    }

    function filterJournalTable() { populateJournalTable(); }
    function saveJournalFilter(inputElement, columnKey) { localStorage.setItem("journal_filter_col_key_" + columnKey, inputElement.value); }

    // ========================================================================
    // window.onload Event Handler
    // ========================================================================
    window.onload = () => {
      activeTab = localStorage.getItem('activeTab') || 'position';
      const initialDsoSortColumnKey = localStorage.getItem("dso_sortColumnKey") || 'Altitude Current';
      const initialDsoSortOrder = localStorage.getItem("dso_sortOrder") || 'desc';
      currentSort.columnKey = initialDsoSortColumnKey;
      currentSort.ascending = (initialDsoSortOrder === "asc");
      const initialJournalSortColumnKey = localStorage.getItem("journal_sortColumnKey") || 'session_date';
      const initialJournalSortOrder = localStorage.getItem("journal_sortOrder") || 'desc';
      currentJournalSort.columnKey = initialJournalSortColumnKey;
      currentJournalSort.ascending = (initialJournalSortOrder === "asc");
      const removeFiltersBtn = document.getElementById('remove-filters-btn');
      if (removeFiltersBtn) { removeFiltersBtn.addEventListener('click', clearAllFilters); }

      fetchLocations();
      fetchSunEvents();
      fetchData();

      updateTabDisplay();

      setInterval(() => {
        fetchData();
        fetchSunEvents();
      }, 60000);

      document.querySelectorAll('.tab-button').forEach(button => {
        button.addEventListener('click', () => { activeTab = button.dataset.tab; updateTabDisplay(); });
      });
      document.querySelectorAll("#data-table > thead > tr:not(.filter-row) > th[data-column-key]").forEach(header => {
        const columnKey = header.dataset.columnKey;
        if (columnConfig[columnKey] && columnConfig[columnKey].sortable) { header.addEventListener("click", () => sortTable(columnKey, true)); }
      });
      document.querySelectorAll("#data-table .filter-row input").forEach(input => {
          const thParent = input.closest('th'); const columnKey = thParent ? thParent.dataset.columnKey : null;
          if (columnKey && columnConfig[columnKey] && columnConfig[columnKey].filterable) { input.addEventListener("keyup", () => { saveFilter(input, columnKey, 'dso'); filterTable(); }); }
      });
      document.querySelectorAll("#journal-data-table > thead > tr:not(.filter-row) > th[data-journal-column-key]").forEach(header => {
        const columnKey = header.dataset.journalColumnKey;
        if (journalColumnConfig[columnKey] && journalColumnConfig[columnKey].sortable) { header.addEventListener("click", () => sortJournalTable(columnKey, true)); }
      });
      document.querySelectorAll("#journal-filter-row input").forEach(input => {
          const thParent = input.closest('th'); const columnKey = thParent ? thParent.dataset.journalColumnKey : null;
          if (columnKey && journalColumnConfig[columnKey] && journalColumnConfig[columnKey].filterable) { input.addEventListener("keyup", () => { saveJournalFilter(input, columnKey); filterJournalTable(); }); }
      });
      document.querySelectorAll("#outlook-table th[data-outlook-column-key]").forEach(header => {
          const columnKey = header.dataset.outlookColumnKey;
          if (outlookColumnConfig[columnKey] && outlookColumnConfig[columnKey].sortable) {
              header.addEventListener("click", (event) => {
                  if (event.target.tagName.toLowerCase() === 'input') { return; }
                  sortOutlookTable(columnKey, true);
              });
          }
      });
      document.querySelectorAll("#outlook-filter-row input").forEach(input => {
          const thParent = input.closest('th');
          const columnKey = thParent ? thParent.dataset.outlookColumnKey : null;
          if (columnKey && outlookColumnConfig[columnKey] && outlookColumnConfig[columnKey].filterable) { input.addEventListener("keyup", filterOutlookTable); }
      });
      for (const key in columnConfig) {
        if (columnConfig[key].filterable) { const val = localStorage.getItem("dso_filter_col_key_" + key); const inputEl = document.querySelector(`#data-table .filter-row th[data-column-key="${key}"] input`); if (val && inputEl) inputEl.value = val; }
      }
      for (const key in journalColumnConfig) {
        if (journalColumnConfig[key].filterable) { const val = localStorage.getItem("journal_filter_col_key_" + key); const inputEl = document.querySelector(`#journal-filter-row th[data-journal-column-key="${key}"] input`); if (val && inputEl) inputEl.value = val; }
      }
       filterTable();
       filterJournalTable();
       updateRemoveFiltersButtonVisibility();
    };

    function renderOutlookTable() {
        const tableBody = document.getElementById('outlook-body');
        if (!tableBody) return;
        const allFilters = {};
        document.querySelectorAll('#outlook-filter-row input').forEach(input => {
            const key = input.closest('th').dataset.outlookColumnKey;
            if (input.value.trim() !== '') allFilters[key] = input.value.trim().toLowerCase();
        });
        const dsoFilterKeys = ['Object', 'Common Name', 'Type', 'Constellation', 'Magnitude', 'Size', 'SB'];
        const dsoToOutlookKeyMap = { 'Object': 'object_name', 'Common Name': 'common_name', 'Type': 'type', 'Constellation': 'constellation', 'Magnitude': 'magnitude', 'Size': 'size', 'SB': 'sb' };
        dsoFilterKeys.forEach(dsoKey => {
            const input = document.querySelector(`#data-table .filter-row th[data-column-key="${dsoKey}"] input`);
            const outlookKey = dsoToOutlookKeyMap[dsoKey];
            if (input && input.value.trim() !== '' && outlookKey) { allFilters[outlookKey] = input.value.trim().toLowerCase(); }
        });
        let filteredData = allOutlookOpportunities.filter(opp => {
            return Object.keys(allFilters).every(key => {
                const filterValue = allFilters[key]; const config = outlookColumnConfig[key];
                if (key === 'rating') {
                    const numericRating = opp.rating_num; if (numericRating === undefined || numericRating === null) return false;
                    const match = filterValue.match(/([<>]=?)\s*(\d+)/);
                    if (match) { const op = match[1]; const num = parseInt(match[2], 10); if (op === ">") return numericRating > num; if (op === ">=") return numericRating >= num; if (op === "<") return numericRating < num; if (op === "<=") return numericRating <= num; }
                    else if (/^\d+$/.test(filterValue)) { return numericRating === parseInt(filterValue, 10); }
                    return String(opp.rating || '').toLowerCase().includes(filterValue);
                }
                const cellValue = String(opp[key] || '').toLowerCase();
                if (config && config.numeric) {
                    const cellNumber = parseFloat(cellValue); if (isNaN(cellNumber)) return false;
                    const match = filterValue.match(/([<>]=?)\s*(\d+\.?\d*)/);
                    if (match) { const op = match[1]; const num = parseFloat(match[2]); if (op === ">") return cellNumber > num; if (op === ">=") return cellNumber >= num; if (op === "<") return cellNumber < num; if (op === "<=") return cellNumber <= num; }
                    return cellValue.includes(filterValue);
                } else {
                    const filterTerms = filterValue.split(/[\s,]+/).filter(t => t.length > 0);
                    if (filterTerms.length === 0) return true;
                    return filterTerms.some(term => cellValue.includes(term));
                }
            });
        });
        if (filteredData.length > 0) {
            let htmlRows = "";
            filteredData.forEach(target => {
                htmlRows += `
                    <tr class="clickable-row" onclick="showGraph('${target.object_name}', '${target.date}')">
                        <td>${target.object_name}</td>
                        <td>${target.common_name}</td>
                        <td style="text-align:center;">${formatDateISOtoEuropean(target.date)}</td>
                        <td style="text-align:center;">${target.max_alt}°</td>
                        <td style="text-align:center;">${target.obs_dur} min</td>
                        <td style="text-align:center;">${target.rating}</td>
                    </tr>
                `;
            });
            tableBody.innerHTML = htmlRows;
        } else {
            tableBody.innerHTML = `<tr><td colspan="6" style="text-align:center; padding:20px; color:orange;">No targets found matching your filters.</td></tr>`;
        }
    }

    function fetchOutlookData() {
        const tableBody = document.getElementById('outlook-body');
        const loadingDiv = document.getElementById("table-loading");
        if (!tableBody) return;

        if (!isUpdatingLocation) { // <-- Checks the flag
            tableBody.innerHTML = `<tr><td colspan="6" style="text-align:center; padding:20px; color:#6795a4;">Fetching...</td></tr>`;
        }

        fetch('/get_outlook_data')
            .then(response => response.json())
            .then(data => {
                if (!outlookDataLoaded) { outlookDataLoaded = true; }
                if (data.status === 'complete') {
                    allOutlookOpportunities = data.results || [];
                    if (allOutlookOpportunities.length > 0) { sortOutlookTable(currentOutlookSort.columnKey, false); }
                    else { tableBody.innerHTML = `<tr><td colspan="6" style="text-align:center; padding:20px; color:grey;">No imaging opportunities found matching the criteria.</td></tr>`; }
                } else if (data.status === 'running' || data.status === 'starting') {
                    if ((data.results || []).length > 0) { allOutlookOpportunities = data.results || []; sortOutlookTable(currentOutlookSort.columnKey, false); }
                    else { tableBody.innerHTML = `<tr><td colspan="6" style="text-align:center; padding:20px; color:#6795a4;">Waiting for background task...</td></tr>`; }
                    setTimeout(fetchOutlookData, 10000);
                } else {
                    tableBody.innerHTML = `<tr><td colspan="6" style="text-align:center; padding:20px; color:orange;">No data available. Check server logs if this persists.</td></tr>`;
                }
                if (loadingDiv) loadingDiv.style.display = 'none';
            })
            .catch(error => {
                outlookDataLoaded = true; console.error("Error fetching outlook data:", error);
                tableBody.innerHTML = `<tr><td colspan="6" style="text-align:center; padding:20px; color:red;">Error. Check console for details.</td></tr>`;
                if (loadingDiv) loadingDiv.style.display = 'none';
            });
    }

    document.addEventListener("DOMContentLoaded", function () {
        setTimeout(() => {
            const flashMessages = document.querySelectorAll(".flash-transient");
            flashMessages.forEach(el => {
                if (el) { el.style.transition = "opacity 0.5s ease"; el.style.opacity = "0"; setTimeout(() => el.remove(), 500); }
            });
        }, 4000);
    });
    </script>
{% endblock %}
</head>
<body> {% block body %}

  <div class="info-bar-wrapper">
      <div class="user-info">
        {% if is_guest %}
          Mode: <strong>Guest</strong> —
          <button onclick="location.href='{{ url_for('login') }}'">
            Log in
          </button>
          for full access.
        {% elif SINGLE_USER_MODE %}
          Mode: <strong>Single User</strong>
        {% else %}
          Mode: <strong>Multi User</strong> — Logged in as <strong>{{ current_user.username }}</strong>
            <form action="{{ url_for('logout') }}" method="post" style="display: inline;">
              <button type="submit">
                Log Out
              </button>
            </form>
        {% endif %}
      </div>
      <div class="info-bar-container">
        {% if SINGLE_USER_MODE or not is_guest %}
            <div>
                <button type="button" id="back-button"
                        onclick="window.location.href='{{ url_for('config_form') }}'">
                  Configuration
                </button>
            </div>
        {% endif %}
        <div class="info-bar-location-datetime-group">
            <p style="margin:0; display:flex; align-items:center; gap: 5px;">
                <small>Location:</small>
                <span>
                  <select id="location-select" onchange="setLocation()">
                    </select>
                </span>
            </p>
            <div class="info-values">
                <p><small>Date:</small> <span id="date"></span></p>
                <p><small>Time:</small> <span id="time"></span></p>
                <p><small>Moon Illumination:</small> <span id="phase"></span></p>
                <p><small>Astr. Dusk:</small> <span id="dusk"></span></p>
                <p><small>Astr. Dawn:</small> <span id="dawn"></span></p>
            </div>
        </div>
      </div>
  </div>

<div class="tab-container">
    <button class="tab-button active" data-tab="position">Position</button>
    <button class="tab-button" data-tab="properties">Properties</button>
    <button class="tab-button" data-tab="outlook">Outlook</button>
    <button class="tab-button" data-tab="journal">Journal</button>

    <div id="tab-message-container">
      {% with messages = get_flashed_messages(with_categories=true) %}
        {% if messages %}
          {% for category, message in messages %}
            <span class="{{ 'error' if category == 'error' else 'message' }} flash-transient" style="margin: 0;">{{ message }}</span>
          {% endfor %}
        {% endif %}
      {% endwith %}
    </div>

    <div id="remove-filters-container" style="display: none;">
     <button type="button" id="remove-filters-btn">
       Remove Filter
     </button>
    </div>
</div>
<div id="list-section">
    <div class="table-wrapper" id="dso-table-wrapper">
        <table id="data-table" data-sort-order="asc">
          <thead>
            <tr> {# Main Headers for DSO Table #}
              <th data-column-key="Object" class="col-always-visible sortable"><span>Object</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
              <th data-column-key="Common Name" class="col-always-visible sortable"><span>Common Name</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
              <th data-column-key="Altitude Current" class="col-position sortable"><span>Altitude<br><span class="subtext">(Current)</span></span><span class="sort-indicator"></span></th>
              <th data-column-key="Azimuth Current" class="col-position sortable"><span>Azimuth <br><span class="subtext">(Current)</span></span><span class="sort-indicator"></span></th>
              <th data-column-key="Trend" class="col-position sortable"><span>Trend</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
              <th data-column-key="Altitude 11PM" class="col-position sortable"><span>Altitude <br><span class="subtext">(11 PM)</span></span><span class="sort-indicator"></span></th>
              <th data-column-key="Azimuth 11PM" class="col-position sortable"><span>Azimuth <br><span class="subtext">(11 PM)</span></span><span class="sort-indicator"></span></th>
              <th data-column-key="Transit Time" class="col-position sortable"><span>Transit <br><span class="subtext">(Local Time)</span></span><span class="sort-indicator"></span></th>
              <th data-column-key="Observable Duration (min)" class="col-position sortable"><span>Observable <br><span class="subtext">(minutes)</span></span><span class="sort-indicator"></span></th>
              <th data-column-key="Max Altitude (°)" class="col-position sortable"><span>Max Altitude<br><span class="subtext">observable (°)</span></span><span class="sort-indicator"></span></th>
              <th data-column-key="Angular Separation (°)" class="col-position sortable"><span>Ang. Sep. <br><span class="subtext">to moon (°)</span></span><span class="sort-indicator"></span></th>
              <th data-column-key="Constellation" class="col-properties sortable"><span>Constellation</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
              <th data-column-key="Type" class="col-properties sortable"><span>Type</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
              <th data-column-key="Magnitude" class="col-properties sortable"><span>Magnitude</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
              <th data-column-key="Size" class="col-properties sortable"><span>Size (')</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
              <th data-column-key="SB" class="col-properties sortable"><span>SB</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
            </tr>
            <tr class="filter-row"> {# Filter Row for DSO Table #}
              <th data-column-key="Object" class="col-always-visible"><input type="text" placeholder="Search Object" /></th>
              <th data-column-key="Common Name" class="col-always-visible"><input type="text" placeholder="Search Common Name" /></th>
              <th data-column-key="Altitude Current" class="col-position"><input type="text" placeholder="Altitude °" /></th>
              <th data-column-key="Azimuth Current" class="col-position"><input type="text" placeholder="Azimuth °" /></th>
              <th data-column-key="Trend" class="col-position"><input type="text" placeholder="Trend" disabled style="visibility:hidden;" /></th>
              <th data-column-key="Altitude 11PM" class="col-position"><input type="text" placeholder="Altitude °" /></th>
              <th data-column-key="Azimuth 11PM" class="col-position"><input type="text" placeholder="Azimuth °" /></th>
              <th data-column-key="Transit Time" class="col-position"><input type="text" placeholder="Transit" disabled style="visibility:hidden;" /></th>
              <th data-column-key="Observable Duration (min)" class="col-position"><input type="text" placeholder="minutes" /></th>
              <th data-column-key="Max Altitude (°)" class="col-position"><input type="text" placeholder="Max Alt. °" /></th>
              <th data-column-key="Angular Separation (°)" class="col-position"><input type="text" placeholder="Ang. Sep. °" /></th>
              <th data-column-key="Constellation" class="col-properties"><input type="text" placeholder="e.g. Cyg" /></th>
              <th data-column-key="Type" class="col-properties"><input type="text" placeholder="Type (e.g. PN,SNR)" /></th>
              <th data-column-key="Magnitude" class="col-properties"><input type="text" placeholder="Mag e.g. <8" /></th>
              <th data-column-key="Size" class="col-properties"><input type="text" placeholder="Size e.g. >10" /></th>
              <th data-column-key="SB" class="col-properties"><input type="text" placeholder="SB e.g. <22" /></th>
            </tr>
          </thead>
          <tbody id="data-body"></tbody>
        </table>
    </div>

    <div class="table-wrapper" id="journal-table-wrapper" style="display:none;">
        <table id="journal-data-table" data-sort-order="desc">
            <thead>
                <tr>
                    <th data-journal-column-key="target_object_id"><span>Object</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
                    <th data-journal-column-key="target_common_name"><span>Common Name</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
                    <th data-journal-column-key="session_date"><span>Date</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
                    <th data-journal-column-key="location_name"><span>Location</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
                    <th data-journal-column-key="telescope_setup_notes"><span>Telescope Setup</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
                    <th data-journal-column-key="calculated_integration_time_minutes"><span>Total Integration</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
                    <th data-journal-column-key="session_rating_subjective"><span>Session Rating</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
                </tr>
                <tr class="filter-row" id="journal-filter-row">
                    <th data-journal-column-key="target_object_id"><input type="text" placeholder="Object ID"/></th>
                    <th data-journal-column-key="target_common_name"><input type="text" placeholder="Common Name"/></th>
                    <th data-journal-column-key="session_date"><input type="text" placeholder="DD.MM.YYYY"/></th> {# Changed placeholder #}
                    <th data-journal-column-key="location_name"><input type="text" placeholder="Location"/></th>
                    <th data-journal-column-key="telescope_setup_notes"><input type="text" placeholder="Setup notes"/></th>
                    <th data-journal-column-key="calculated_integration_time_minutes"><input type="text" placeholder="e.g. >120"/></th>
                    <th data-journal-column-key="session_rating_subjective"><input type="text" placeholder="e.g. 4"/></th>
                </tr>
            </thead>
            <tbody id="journal-data-body">
                </tbody>
        </table>
    </div>

    <div class="table-wrapper" id="outlook-wrapper" style="display:none;">
        <table id="outlook-table">
            <thead>
                <tr>
                    <th data-outlook-column-key="object_name"><span>Object</span><span class="sort-indicator"></span></th>
                    <th data-outlook-column-key="common_name"><span>Common Name</span><span class="sort-indicator"></span></th>
                    <th data-outlook-column-key="date"><span>Date</span><span class="sort-indicator"></span></th>
                    <th data-outlook-column-key="max_alt"><span>Max Alt</span><span class="sort-indicator"></span></th>
                    <th data-outlook-column-key="obs_dur"><span>Obs. Time</span><span class="sort-indicator"></span></th>
                    <th data-outlook-column-key="rating"><span>Rating</span><span class="sort-indicator"></span></th>
                </tr>
                <tr class="filter-row" id="outlook-filter-row">
                    <th data-outlook-column-key="object_name"><input type="text" placeholder="Search Object"/></th>
                    <th data-outlook-column-key="common_name"><input type="text" placeholder="Search Name"/></th>
                    <th data-outlook-column-key="date"><input type="text" placeholder="Search Date"/></th>
                    <th data-outlook-column-key="max_alt"><input type="text" placeholder="e.g. >60"/></th>
                    <th data-outlook-column-key="obs_dur"><input type="text" placeholder="e.g. >300"/></th>
                    <th data-outlook-column-key="rating"><input type="text" placeholder="e.g. ★★★★★"/></th>
                </tr>
            </thead>
            <tbody id="outlook-body">
                </tbody>
        </table>
    </div>
    <div id="table-loading" style="display:none; color: #6795a4; font-weight: normal; margin-top: 30px; margin-left: 10px;">
      Loading...
    </div>
</div> {# End of list-section #}

<div id="graph-section" style="display: none;">
  <iframe id="graph-iframe"
          style="width: 100%; max-width:1500px; height: 1000px; border: none;"
          title="Graph">
  </iframe>
</div>
{% endblock %}
</body> </html>