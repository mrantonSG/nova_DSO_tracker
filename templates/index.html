{% extends "base.html" %}

{% block title %}DSO Altitude Tracker{% endblock %}

{% block head_extra %}
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
        font-family: 'Roboto', sans-serif;
        padding: 20px;
        margin: 0;
        background-color: #ffffff;
        color: #333;
    }


    .tab-container {
        display: flex;
        margin-bottom: 15px;
        border-bottom: 2px solid #ccc;
    }

    .tab-button {
        padding: 10px 20px;
        cursor: pointer;
        border: 1px solid #ccc;
        border-bottom: none;
        background-color: #e9e9e9;
        margin-right: 5px;
        border-radius: 5px 5px 0 0;
        font-size: 16px;
    }

    .tab-button.active {
        background-color: #fff;
        border-color: #ccc;
        border-bottom: 2px solid #fff;
        position: relative;
        top: 1px;
    }

    #journal-data-table {
        table-layout: fixed; /* Explicitly set fixed layout for this table */
    }

    table {
        width: max-content;       /* allow natural column widths */
        min-width: 100%;          /* but never smaller than the viewport */
        border-collapse: collapse;
        border: 1px solid #ddd;
        table-layout: fixed;      /* honor explicit widths and prevent reflow jitter */
        word-wrap: break-word;
    }
    th, td { border: 1px solid #ddd; padding: 6px; font-size: 15px; }


    th[data-column-key="Object"],
    td[data-column-key="Object"] {
        width: 120px;
        min-width: 120px;
        text-align: left;
    }
    th[data-column-key="Common Name"],
    td[data-column-key="Common Name"] {
        min-width: 220px;         /* enforce a floor */
        text-align: left;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

     th[data-column-key="Altitude Current"], td[data-column-key="Altitude Current"],
    th[data-column-key="Azimuth Current"], td[data-column-key="Azimuth Current"],
    th[data-column-key="Altitude 11PM"], td[data-column-key="Altitude 11PM"],
    th[data-column-key="Azimuth 11PM"], td[data-column-key="Azimuth 11PM"],
    th[data-column-key="Observable Duration (min)"], td[data-column-key="Observable Duration (min)"],
    th[data-column-key="Max Altitude (°)"], td[data-column-key="Max Altitude (°)"],
    th[data-column-key="Angular Separation (°)"], td[data-column-key="Angular Separation (°)"] {
        width: 100px;
        min-width: 100px;
        text-align: center;
    }
    th[data-column-key="Trend"], td[data-column-key="Trend"] {
        width: 70px;
        min-width: 70px;
        text-align: center;
    }
    th[data-column-key="Transit Time"], td[data-column-key="Transit Time"] {
        width: 80px;
        min-width: 80px;
        text-align: center;
    }

    th[data-column-key="Type"], td[data-column-key="Type"],
    th[data-column-key="Magnitude"], td[data-column-key="Magnitude"],
    th[data-column-key="Size"], td[data-column-key="Size"],
    th[data-column-key="SB"], td[data-column-key="SB"] {
        width: 100px;
        min-width: 100px;
        text-align: center;
    }

    /* --- ADDED FOR NEW COLUMNS --- */
    th[data-column-key="Best Month"], td[data-column-key="Best Month"],
    th[data-column-key="Max Altitude"], td[data-column-key="Max Altitude"] {
        width: 100px;
        min-width: 100px;
        text-align: center;
    }
    /* --- END OF ADD --- */

    td.highlight.obstructed {
        background-color: #ffeeba !important; /* A light yellow/orange */
        color: #856404; /* A darker text color for readability */
    }

    #data-table th:not([data-column-key="Object"]):not([data-column-key="Common Name"]),
    #data-table td:not([data-column-key="Object"]):not([data-column-key="Common Name"]) {
        text-align: center;
    }

    #data-table > thead > tr:not(.filter-row) > th,
    #journal-data-table > thead > tr:not(.filter-row) > th,
    #outlook-table > thead > tr:not(.filter-row) > th {
        background-color: #f2f2f2;
        font-weight: normal;
        cursor: pointer;
        min-height: 45px;
        vertical-align: middle;
        padding-top: 8px;
        padding-bottom: 8px;
    }

    th span { display: block; font-weight: bold; font-size: 13px; line-height: 1.3; }
    th span.subtext {
      font-weight: normal;
      font-size: 12px;
      line-height: 1.3;
      display: block;
    }
    #data-body td, #journal-data-body td, #outlook-body td {
        line-height: 1.4;
    }


    .highlight { background-color: #83b4c5; }
    .active-project-row { background-color: #dce5eb !important; }
    tr.clickable-row:hover { background-color: #f1f1f1; cursor: pointer; }
    #graph-section { display: none; text-align: left; margin-left: 0px; }
    #back-button {
      margin-top: 0px;
      padding: 10px 20px;
      font-size: 16px;
      background-color: #83b4c5;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    #back-button:hover { background-color: #6795a4 !important; }

    .info-bar-wrapper {
        display: flex;
        flex-direction: column;
        margin-bottom: 20px;
    }

    .user-info {
      font-size:14px;
      color:#444;
      margin-bottom:10px;
    }
    .user-info button {
        margin-left:6px;
        padding:4px 10px;
        font-size:13px;
        background:#83b4c5;
        color:white;
        border:none;
        border-radius:4px;
        cursor:pointer;
    }
    .user-info button:hover {
        background:#6795a4;
    }

    .info-bar-container {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 20px;
    }

    .info-bar-location-datetime-group {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 15px;
        flex-grow: 1;
        justify-content: flex-start;
    }
     .info-bar-location-datetime-group > p,
     .info-bar-location-datetime-group > .info-values {
        margin: 0;
    }

    .filter-row th {
        background-color: #f2f2f2;
        vertical-align: top;
    }
    .filter-row input {
      width: 95%;
      box-sizing: border-box;
      padding: 4px;
      font-size: 13px;
      font-family: 'Roboto', sans-serif;
      margin-top: 2px;
      margin-bottom: 2px;
    }
    #location-select {
      height: 35px;
      font-size: 16px;
      padding: 5px;
      box-sizing: border-box;
      font-family: 'Roboto', sans-serif;
    }

    .info-values p { margin: 0; font-size: 16px; }
    .info-values small { font-size: 12px; color: #666; }
    .info-values span { font-weight: bold; font-size: 16px; color: #000; }
    .info-values {
        display: flex;
        flex-wrap: wrap;
        gap: 10px 20px;
        align-items: center;
    }
    .table-wrapper { overflow-x: auto; margin-bottom: 20px; }
    .table-wrapper::-webkit-scrollbar { height: 8px; }
    .table-wrapper::-webkit-scrollbar-thumb { background: #ccc; border-radius: 4px; }
    .table-wrapper::-webkit-scrollbar-thumb:hover { background: #888; }

    th .sort-indicator { font-size: 0.8em; margin-left: 5px; display: inline-block; }


    #journal-data-table th,
    #journal-data-table td {
        text-align: center;
        vertical-align: middle;
    }


    #journal-data-table th[data-journal-column-key="object_name"],
    #journal-data-table td[data-journal-column-key="object_name"],
    #journal-data-table th[data-journal-column-key="target_common_name"],
    #journal-data-table td[data-journal-column-key="target_common_name"],
    #journal-data-table th[data-journal-column-key="location_name"],
    #journal-data-table td[data-journal-column-key="location_name"],
    #journal-data-table th[data-journal-column-key="session_date"],
    #journal-data-table th[data-journal-column-key="telescope_setup_notes"],
    #journal-data-table td[data-journal-column-key="telescope_setup_notes"] {
        text-align: left;
    }


    #journal-data-table th[data-journal-column-key="object_name"],
    #journal-data-table td[data-journal-column-key="object_name"] { width: 120px; min-width: 120px; }
    #journal-data-table th[data-journal-column-key="target_common_name"],
    #journal-data-table td[data-journal-column-key="target_common_name"] { min-width: 150px; }
    #journal-data-table th[data-journal-column-key="session_date"],
    #journal-data-table td[data-journal-column-key="session_date"] { width: 100px; min-width: 100px; }
    #journal-data-table th[data-journal-column-key="location_name"],
    #journal-data-table td[data-journal-column-key="location_name"] { min-width: 100px; width: 110px; text-align: left; }
    #journal-data-table th[data-journal-column-key="telescope_setup_notes"],
    #journal-data-table td[data-journal-column-key="telescope_setup_notes"] { min-width: 200px; }
    #journal-data-table th[data-journal-column-key="calculated_integration_time_minutes"],
    #journal-data-table td[data-journal-column-key="calculated_integration_time_minutes"] { width: 100px; min-width: 100px; }
    #journal-data-table th[data-journal-column-key="session_rating_subjective"],
    #journal-data-table td[data-journal-column-key="session_rating_subjective"] { width: 100px; min-width: 100px; }
    #journal-data-table .filter-row input { text-align: left; }

    #remove-filters-container {
      margin-left: auto;
      align-self: center;
    }

    #remove-filters-btn {
      padding: 10px 20px;
      font-size: 16px;
      background-color: #a1b0b4;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    #remove-filters-btn:hover { background-color: #849398 !important; }

    th[data-column-key="Type"], td[data-column-key="Type"],
    th[data-column-key="Magnitude"], td[data-column-key="Magnitude"],
    th[data-column-key="Size"], td[data-column-key="Size"],
    th[data-column-key="SB"], td[data-column-key="SB"],
    th[data-column-key="Constellation"], td[data-column-key="Constellation"] {
        width: 100px;
        min-width: 100px;
        text-align: center;
    }


    #outlook-table th[data-outlook-column-key="object_name"],
    #outlook-table td[data-outlook-column-key="object_name"],
    #outlook-table th[data-outlook-column-key="common_name"],
    #outlook-table td[data-outlook-column-key="common_name"] { text-align: left; }
    #outlook-table th[data-outlook-column-key="object_name"],
    #outlook-table td[data-outlook-column-key="object_name"] { width: 120px; min-width: 120px; }
    #outlook-table th[data-outlook-column-key="common_name"],
    #outlook-table td[data-outlook-column-key="common_name"] { min-width: 150px; }
    #outlook-table th[data-outlook-column-key="date"],
    #outlook-table td[data-outlook-column-key="date"],
    #outlook-table th[data-outlook-column-key="max_alt"],
    #outlook-table td[data-outlook-column-key="max_alt"],
    #outlook-table th[data-outlook-column-key="obs_dur"],
    #outlook-table td[data-outlook-column-key="obs_dur"],
    #outlook-table th[data-outlook-column-key="rating"],
    #outlook-table td[data-outlook-column-key="rating"] {
        width: 110px;
        min-width: 110px;
        text-align: center;
    }
    #outlook-table > thead > tr:not(.filter-row) > th > span:not(.sort-indicator)::after {
        content: '\00a0';
        display: block;
        font-size: 12px;
        font-weight: normal;
    }


    .message { color: #155724; font-weight: bold; }
    .error { color: #dc3545; font-weight: bold; }
    #tab-message-container {
      margin-left: auto;
      align-self: center;
    }

  </style>

  <script>
    // ========================================================================
    // Configuration & Global State Variables
    // ========================================================================
    let activeTab = localStorage.getItem('activeTab') || 'position';
    let outlookDataLoaded = false;

    let allOutlookOpportunities = []; // To store the full list of results
    let currentOutlookSort = { columnKey: 'date', ascending: true }; // Default sort
    const outlookColumnConfig = {
        'object_name':  { dataKey: 'object_name',  sortable: true, filterable: true, numeric: false },
        'common_name':  { dataKey: 'common_name',  sortable: true, filterable: true, numeric: false },
        'date':         { dataKey: 'date',    sortable: true, filterable: true, numeric: false },
        'max_alt':      { dataKey: 'max_alt',      sortable: true, filterable: true, numeric: true },
        'obs_dur':      { dataKey: 'obs_dur',      sortable: true, filterable: true, numeric: true },
        'rating':       { dataKey: 'rating',       sortable: true, filterable: true, numeric: false },
        'score':        { dataKey: 'score',        sortable: true, filterable: false, numeric: true },
        'type':         { dataKey: 'type' },
        'constellation':{ dataKey: 'constellation' },
        'magnitude':    { dataKey: 'magnitude', numeric: true },
        'size':         { dataKey: 'size', numeric: true },
        'sb':           { dataKey: 'sb', numeric: true }
    };

    // --- DSO Table Configuration ---
    let currentSort = { columnKey: 'Altitude Current', ascending: false };
    const columnConfig = {
        'Object':           { header: 'Object<br><span class="subtext">&nbsp;</span>', dataKey: 'Object', type: 'always-visible', filterable: true, sortable: true },
        'Common Name':      { header: 'Common Name<br><span class="subtext">&nbsp;</span>', dataKey: 'Common Name', type: 'always-visible', filterable: true, sortable: true },
        'Altitude Current': { header: 'Altitude<br><span class="subtext">(Current)</span>', dataKey: 'Altitude Current', type: 'position', filterable: true, sortable: true, format: val => (val === 'N/A' || val === null || val === undefined) ? 'N/A' : `${parseFloat(val).toFixed(2)}°` },
        'Azimuth Current':  { header: 'Azimuth <br><span class="subtext">(Current)</span>', dataKey: 'Azimuth Current', type: 'position', filterable: true, sortable: true, format: val => (val === 'N/A' || val === null || val === undefined) ? 'N/A' : `${parseFloat(val).toFixed(2)}°` },
        'Trend':            { header: 'Trend<br><span class="subtext">&nbsp;</span>', dataKey: 'Trend', type: 'position', filterable: false, sortable: true },
        'Altitude 11PM':    { header: 'Altitude <br><span class="subtext">(11 PM)</span>', dataKey: 'Altitude 11PM', type: 'position', filterable: true, sortable: true, format: val => (val === 'N/A' || val === null || val === undefined) ? 'N/A' : `${parseFloat(val).toFixed(2)}°` },
        'Azimuth 11PM':     { header: 'Azimuth <br><span class="subtext">(11 PM)</span>', dataKey: 'Azimuth 11PM', type: 'position', filterable: true, sortable: true, format: val => (val === 'N/A' || val === null || val === undefined) ? 'N/A' : `${parseFloat(val).toFixed(2)}°` },
        'Transit Time':     { header: 'Transit <br><span class="subtext">(Local Time)</span>', dataKey: 'Transit Time', type: 'position', filterable: false, sortable: true },
        'Observable Duration (min)': { header: 'Observable <br><span class="subtext">(minutes)</span>', dataKey: 'Observable Duration (min)', type: 'position', filterable: true, sortable: true, format: val => (val === 'N/A' || val === null || val === undefined) ? 'N/A' : String(val) },
        'Max Altitude (°)': { header: 'Max Altitude<br><span class="subtext">observable (°)</span>', dataKey: 'Max Altitude (°)', type: 'position', filterable: true, sortable: true, format: val => (val === 'N/A' || val === null || val === undefined || isNaN(Number(val))) ? 'N/A' : `${Number(val).toFixed(1)}°` },
        'Angular Separation (°)': { header: 'Ang. Sep. <br><span class="subtext">to moon (°)</span>', dataKey: 'Angular Separation (°)', type: 'position', filterable: true, sortable: true, format: val => (val === 'N/A' || val === null || val === undefined || isNaN(Number(val))) ? 'N/A' : `${parseInt(val)}°` },
        'Constellation':    { header: 'Con<br><span class="subtext">&nbsp;</span>', dataKey: 'Constellation', type: 'properties', filterable: true, sortable: true },
        'Type':             { header: 'Type<br><span class="subtext">&nbsp;</span>', dataKey: 'Type', type: 'properties', filterable: true, sortable: true },
        'Magnitude':        { header: 'Magnitude<br><span class="subtext">&nbsp;</span>', dataKey: 'Magnitude', type: 'properties', filterable: true, sortable: true, format: val => (val === 'N/A' || val === null || val === undefined || isNaN(Number(val))) ? 'N/A' : parseFloat(val).toFixed(1) },
        'Size':             { header: "Size (')<br><span class='subtext'>&nbsp;</span>", dataKey: 'Size', type: 'properties', filterable: true, sortable: true, format: val => (val === 'N/A' || val === null || val === undefined || isNaN(Number(val))) ? 'N/A' : parseFloat(val).toFixed(1) },
        'SB':               { header: 'SB<br><span class="subtext">&nbsp;</span>', dataKey: 'SB', type: 'properties', filterable: true, sortable: true, format: val => (val === 'N/A' || val === null || val === undefined || isNaN(Number(val))) ? 'N/A' : parseFloat(val).toFixed(1) },
        /* --- ADDED FOR NEW COLUMNS --- */
        'Best Month':       { header: 'Best Month<br><span class="subtext">(Opp.)</span>', dataKey: 'best_month_ra', type: 'properties', filterable: true, sortable: true },
        'Max Altitude':     { header: 'Max Alt<br><span class="subtext">(Culm.)</span>', dataKey: 'max_culmination_alt', type: 'properties', filterable: true, sortable: true, format: val => (val === 'N/A' || val === null || val === undefined || isNaN(Number(val))) ? 'N/A' : `${Number(val).toFixed(1)}°` }
        /* --- END OF ADD --- */
    };

    // --- Journal Table Configuration ---
    const allJournalSessions = {{ journal_sessions | tojson | safe }};
    let currentJournalSort = { columnKey: 'session_date', ascending: false };
    const journalColumnConfig = {
        'object_name': {
            headerText: 'Object',
            dataKey: 'object_name',
            sortable: true,
            filterable: true
        },
        'target_common_name': {
            headerText: 'Common Name',
            dataKey: 'target_common_name',
            sortable: true,
            filterable: true
        },
        'date_utc': {
            headerText: 'Date',
            dataKey: 'date_utc',
            sortable: true,
            filterable: true,
            format: formatDateISOtoEuropean
        },
        'location_name': {
            headerText: 'Location',
            dataKey: 'location_name',
            sortable: true,
            filterable: true
        },
        'telescope_setup_notes': {
            headerText: 'Telescope Setup',
            dataKey: 'telescope_setup_notes',
            sortable: true,
            filterable: true,
            format: val => (val === null || val === undefined || String(val).trim() === '') ? 'N/A' : String(val).substring(0, 60) + (String(val).length > 60 ? '...' : '')
        },
        'calculated_integration_time_minutes': {
            headerText: 'Total Integration',
            dataKey: 'calculated_integration_time_minutes',
            sortable: true,
            filterable: true,
            format: val => (val === null || val === undefined || isNaN(Number(val))) ? 'N/A' : `${Number(val).toFixed(0)} min`
        },
        'session_rating_subjective': {
            headerText: 'Session Rating',
            dataKey: 'session_rating_subjective',
            sortable: true,
            filterable: true,
            format: val => (val === null || val === undefined) ? 'N/A' : `${String(val)} ★`
        }
    };

    // ========================================================================
    // Helper Functions
    // ========================================================================
    function formatDateISOtoEuropean(isoStr) {
      if (!isoStr || typeof isoStr !== 'string') return 'N/A';
      const parts = isoStr.split("-");
      if (parts.length !== 3) return isoStr;
      const [year, month, day] = parts;
      return `${day}.${month}.${year}`;
    }

    function parseTimeToMinutes(timeStr) {
      if (!timeStr || typeof timeStr !== 'string' || !/^\d{1,2}:\d{2}$/.test(timeStr)) return 0;
      const [h, m] = timeStr.split(':').map(Number);
      return h * 60 + m;
    }
    function updateRemoveFiltersButtonVisibility() {
        const btnContainer = document.getElementById('remove-filters-container');
        if (!btnContainer) return;

        let isAnyFilterActive = false;
        const allFilterInputs = document.querySelectorAll('#data-table .filter-row input, #journal-filter-row input');

        for (const input of allFilterInputs) {
            // Check only filterable inputs
            if (input.value.trim() !== '') {
                isAnyFilterActive = true;
                break; // Found an active filter, no need to check further
            }
        }
        btnContainer.style.display = isAnyFilterActive ? 'block' : 'none';
    }

    function clearAllFilters() {
        // Clear DSO filters
        for (const key in columnConfig) {
            if (columnConfig[key].filterable) {
                const inputEl = document.querySelector(`#data-table .filter-row th[data-column-key="${key}"] input`);
                if (inputEl) inputEl.value = '';
                localStorage.removeItem("dso_filter_col_key_" + key);
            }
        }

        // Clear Journal filters
        for (const key in journalColumnConfig) {
            if (journalColumnConfig[key].filterable) {
                const inputEl = document.querySelector(`#journal-filter-row th[data-journal-column-key="${key}"] input`);
                if (inputEl) inputEl.value = '';
                localStorage.removeItem("journal_filter_col_key_" + key);
            }
        }

        // Refresh the tables to reflect the cleared filters
        filterTable();
        filterJournalTable();
    }

    // ========================================================================
    // Tab Display Logic
    // ========================================================================
    function updateTabDisplay() {
        const dsoTableWrapper = document.getElementById('dso-table-wrapper');
        const dsoLoadingDiv = document.getElementById('table-loading');
        const journalTableWrapper = document.getElementById('journal-table-wrapper');
        const outlookWrapper = document.getElementById('outlook-wrapper');

        document.querySelectorAll('.tab-button').forEach(button => {
            button.classList.toggle('active', button.dataset.tab === activeTab);
        });

        if (dsoTableWrapper) dsoTableWrapper.style.display = 'none';
        if (dsoLoadingDiv) dsoLoadingDiv.style.display = 'none';
        if (journalTableWrapper) journalTableWrapper.style.display = 'none';
        if (outlookWrapper) outlookWrapper.style.display = 'none';

        if (dsoLoadingDiv) dsoLoadingDiv.style.display = 'none';

        if (activeTab === 'position' || activeTab === 'properties') {
            if (dsoTableWrapper) dsoTableWrapper.style.display = 'block';
            applyDsoColumnVisibility();
            const dsoTableBody = document.getElementById('data-body');
            if (dsoTableBody && dsoTableBody.innerHTML.trim() === '') {
                if (dsoLoadingDiv) dsoLoadingDiv.style.display = 'block';
            }
        } else if (activeTab === 'journal') {
            if (journalTableWrapper) journalTableWrapper.style.display = 'block';
            populateJournalTable();
        } else if (activeTab === 'outlook') {
            if (outlookWrapper) outlookWrapper.style.display = 'block';
            if (!outlookDataLoaded) fetchOutlookData();
        }

        localStorage.setItem('activeTab', activeTab);
        updateRemoveFiltersButtonVisibility();
    }

    function applyDsoColumnVisibility() {
        const headers = document.querySelectorAll("#data-table > thead > tr:not(.filter-row) > th[data-column-key]");
        const filterCells = document.querySelectorAll("#data-table .filter-row th[data-column-key]");
        const tableBodyRows = document.querySelectorAll("#data-body tr");

        headers.forEach(th => {
            const columnKey = th.dataset.columnKey;
            const config = columnConfig[columnKey];
            if (config) {
                th.style.display = (config.type === 'always-visible' || config.type === activeTab) ? 'table-cell' : 'none';
            }
        });
        filterCells.forEach(thFilter => {
            const columnKey = thFilter.dataset.columnKey;
            const config = columnConfig[columnKey];
            const input = thFilter.querySelector('input');
            let show = false;
            if (config) {
                show = (config.type === 'always-visible' || config.type === activeTab);
                thFilter.style.display = show ? 'table-cell' : 'none';
                if (input) {
                    input.disabled = !show || !config.filterable;
                    input.style.visibility = show && config.filterable ? 'visible' : 'hidden';
                }
            }
        });
        tableBodyRows.forEach(row => {
            const cells = row.querySelectorAll('td[data-column-key]');
            cells.forEach(td => {
                const columnKey = td.dataset.columnKey;
                const config = columnConfig[columnKey];
                if (config) {
                    td.style.display = (config.type === 'always-visible' || config.type === activeTab) ? 'table-cell' : 'none';
                }
            });
        });
    }

    // ========================================================================
    // DSO Table Functions (NEW, CORRECTED VERSION)
    // ========================================================================

    // Helper: match numeric filters like ">170<190", ">=20 <=50", or ranges like "170-190" / "170..190"
    function matchesNumericFilter(cellNumber, filterValue) {
        if (typeof cellNumber !== 'number' || isNaN(cellNumber)) return false;
        if (!filterValue || typeof filterValue !== 'string') return false;
        let s = filterValue.trim();
        // Normalize separators
        s = s.replace(/,/g, ' ');

        // Case 1: explicit range "a-b" or "a..b" or "a—b"
        const rangeMatch = s.match(/^\s*(-?\d+(?:\.\d+)?)\s*[-–—:.]{1,2}\s*(-?\d+(?:\.\d+)?)\s*$/);
        if (rangeMatch) {
            let a = parseFloat(rangeMatch[1]);
            let b = parseFloat(rangeMatch[2]);
            if (isNaN(a) || isNaN(b)) return false;
            if (a > b) { const tmp = a; a = b; b = tmp; }
            return cellNumber >= a && cellNumber <= b;
        }

        // Case 2: chained comparators like ">170<190" or ">=20 <=50"
        const pairs = [];
        const regex = /([<>]=?)\s*(-?\d+(?:\.\d+)?)/g;
        let m;
        while ((m = regex.exec(s)) !== null) {
            pairs.push({ op: m[1], val: parseFloat(m[2]) });
        }
        if (pairs.length > 0) {
            return pairs.every(p => {
                if (isNaN(p.val)) return false;
                if (p.op === '>')  return cellNumber >  p.val;
                if (p.op === '>=') return cellNumber >= p.val;
                if (p.op === '<')  return cellNumber <  p.val;
                if (p.op === '<=') return cellNumber <= p.val;
                return false;
            });
        }

        // Fallback: simple substring match on the numeric text
        return String(cellNumber).indexOf(s) !== -1;
    }


async function fetchData() {
    const tbody = document.getElementById("data-body");
    const loadingDiv = document.getElementById("table-loading");
    // Prevent multiple simultaneous fetches
    if (!tbody || !loadingDiv || tbody.dataset.loading === 'true') return;

    tbody.dataset.loading = 'true'; // Mark as loading

    // --- NEW: Remember which location we are STARTING to fetch ---
    const locationBeingFetched = sessionStorage.getItem('selectedLocation');
    console.log(`Starting fetch for location: ${locationBeingFetched}`);

    // --- Define columnOrder here so it's available in catch block if needed ---
    const columnOrder = [
        'Object', 'Common Name', 'Altitude Current', 'Azimuth Current', 'Trend', 'Altitude 11PM',
        'Azimuth 11PM', 'Transit Time', 'Observable Duration (min)', 'Max Altitude (°)',
        'Angular Separation (°)', 'Constellation', 'Type', 'Magnitude', 'Size', 'SB',
        'Best Month', 'Max Altitude'
    ];

    try {
        // Show loading indicator only if the table is currently empty
        if (tbody.innerHTML.trim() === '') loadingDiv.style.display = 'block';

        // 1. Fetch the list of all object names first
        const listResponse = await fetch('/api/get_object_list');
        if (!listResponse.ok) throw new Error(`HTTP error fetching object list! status: ${listResponse.status}`);
        const listData = await listResponse.json(); // Gets { objects: ["name1", "name2", ...] }

        // --- Get the currently selected location from browser session storage ---
        const currentSelectedLocation = sessionStorage.getItem('selectedLocation');
        // --- End location retrieval ---

        // 2. Start fetching detailed data for EACH object in parallel, passing the location
        const fetchPromises = listData.objects.map(objName =>
            // --- Pass location as a query parameter ---
            fetch(`/api/get_object_data/${encodeURIComponent(objName)}?location=${encodeURIComponent(currentSelectedLocation || '')}`)
            // --- End URL modification ---
            .then(res => { // Handle the response for each object
                if (!res.ok) { // Check if the server reported an error for this specific object
                    console.error(`Error fetching data for ${objName}: ${res.status}`);
                    // Return a placeholder error object so Promise.all doesn't fail completely
                    return { Object: objName, error: true, 'Common Name': `Error: ${res.status}` };
                }
                return res.json(); // If okay, parse the JSON data
            })
            .catch(error => { // Catch network errors (e.g., server down) for individual requests
                console.error(`Network error fetching data for ${objName}:`, error);
                // Return a placeholder error object
                return { Object: objName, error: true, 'Common Name': 'Error: Network failed' };
            })
        );

        // 3. Wait for ALL the individual detail fetches to complete
        const allObjectData = await Promise.all(fetchPromises);

        // 4. Clear the table body, ready for the new rows
        tbody.innerHTML = '';

        // Get the altitude threshold (needed for highlighting) from the template/global scope if possible
        // Fallback to 20 if not defined
        const altitudeThreshold = {{ g.altitude_threshold | default(20) }};

        // 5. Loop through the data for each object and build the table row
        allObjectData.forEach(objectData => {
            // Skip if data is missing or marked as an error from the fetch stage
            if (!objectData) {
                console.warn("Skipping row due to missing objectData.");
                return;
            }
             // Handle explicit errors returned from fetch promises
             if (objectData.error === true) {
                 console.warn(`Skipping row for ${objectData.Object} due to fetch error: ${objectData['Common Name']}`);
                 // Optionally, you could still add a row indicating the error here
                 // return; // Let's still add the row to show the error
             }


            // Create the table row element
            const sanitizedId = String(objectData.Object || 'unknown').replace(/\s+/g, '-'); // Handle potential missing Object field
            const row = document.createElement('tr');
            row.id = `row-${sanitizedId}`;
            row.className = 'clickable-row';

            // Style rows indicating errors differently
             if (objectData.error === true || (objectData['Common Name'] && String(objectData['Common Name']).toLowerCase().startsWith("error:"))) {
                row.style.backgroundColor = "#f8d7da"; // Light red for errors
                row.style.color = "#721c24";
            } else {
                // Apply active project highlighting if not an error row
                const ap = objectData.ActiveProject;
                const isActive = (ap === true) || (ap === 1) || (ap === '1') || (ap === 'true') || (ap === 'True');
                if (isActive) {
                    row.classList.add('active-project-row');
                }
            }


            // Make rows clickable to go to the graph view, unless it's an error row
             if (objectData.error !== true && !(objectData['Common Name'] && String(objectData['Common Name']).toLowerCase().startsWith("error:"))) {
                row.onclick = () => {
                    showGraph(objectData.Object);
                };
            } else {
                row.style.cursor = 'default'; // Not clickable if error
            }


            // 6. Create a table cell (td) for each column in the defined order
            columnOrder.forEach(columnKey => {
                const config = columnConfig[columnKey]; // Get config (header, formatting, etc.)
                if (!config) {
                    console.warn(`Missing columnConfig for key: ${columnKey}`);
                    return; // Skip this cell if config is missing
                }

                const td = document.createElement('td');
                td.dataset.columnKey = columnKey; // Store key for filtering/sorting

                // Set text alignment based on column
                if (columnKey === 'Object' || columnKey === 'Common Name') {
                    td.style.textAlign = 'left';
                } else {
                    td.style.textAlign = 'center';
                }

                // Get the raw value, handle potential undefined/null
                const rawValue = objectData[config.dataKey];

                // Format the value for display (use formatter if defined, handle N/A)
                let displayValue = (rawValue === null || rawValue === undefined || String(rawValue).trim() === '')
                                   ? 'N/A'
                                   : (config.format ? config.format(rawValue) : rawValue);
                td.textContent = displayValue;

                // Add tooltip for potentially truncated Common Name
                if (columnKey === 'Common Name' && rawValue !== null && rawValue !== undefined) {
                    td.setAttribute('title', String(rawValue));
                }

                // Apply highlighting and obstruction styling based on altitude and obstruction flags
                const isAboveThreshold = parseFloat(rawValue) >= altitudeThreshold;

                if (config.dataKey === 'Altitude Current' && isAboveThreshold && objectData.error !== true) {
                    td.classList.add('highlight');
                    if (objectData.is_obstructed_now) {
                        td.classList.add('obstructed');
                    }
                }

                if (config.dataKey === 'Altitude 11PM' && isAboveThreshold && objectData.error !== true) {
                    td.classList.add('highlight');
                    if (objectData.is_obstructed_at_11pm) {
                        td.classList.add('obstructed');
                    }
                }

                // Store raw numeric value in data attribute for accurate sorting
                const numericSortKeys = [
                    'Altitude Current', 'Azimuth Current', 'Altitude 11PM', 'Azimuth 11PM',
                    'Observable Duration (min)', 'Max Altitude (°)', 'Angular Separation (°)',
                    'Magnitude', 'Size', 'SB', 'Max Altitude'
                ];

                 if (numericSortKeys.includes(columnKey)) {
                     if (rawValue === 'N/A' || rawValue === null || rawValue === undefined) {
                        td.dataset.rawValue = 'N/A';
                     } else if (typeof rawValue === 'number') {
                         td.dataset.rawValue = rawValue;
                     } else if (typeof rawValue === 'string' && !isNaN(parseFloat(rawValue))) {
                         td.dataset.rawValue = parseFloat(rawValue);
                     } else {
                        // Store the original string if it's not clearly numeric or N/A
                         td.dataset.rawValue = rawValue;
                     }
                 } else if (rawValue === 'N/A' || rawValue === null || rawValue === undefined) {
                     td.dataset.rawValue = 'N/A'; // Ensure N/A sorts correctly for text columns too
                }


                row.appendChild(td); // Add the cell to the row
            });
            tbody.appendChild(row); // Add the completed row to the table body
        });

    } catch (error) {
        // Handle errors during the overall fetch process (e.g., fetching the object list failed)
        console.error("Failed to fetch and render data:", error);
        tbody.innerHTML = `<tr><td colspan="${columnOrder.length}" style="text-align:center; color:red;">Error loading data: ${error.message}</td></tr>`;
    } finally {
        // 7. Hide loading indicator, apply column visibility, sort, and filter
        loadingDiv.style.display = 'none';
        applyDsoColumnVisibility(); // Show/hide columns based on the active tab
        sortTable(currentSort.columnKey, false); // Apply the current sort order
        filterTable(); // Apply any active filters
        tbody.dataset.loading = 'false'; // Mark loading as complete
        fetchSunEvents();

        // --- NEW: Check if location changed *during* this fetch ---
        const finalSelectedLocation = sessionStorage.getItem('selectedLocation');
        if (finalSelectedLocation !== locationBeingFetched) {
            console.log(`Location changed to ${finalSelectedLocation} during fetch. Re-triggering...`);
            // Call setLocation() again. Since loading is now false,
            // it will immediately start the new fetch.
            setLocation();
        } else {
            console.log(`Finished fetch for location: ${locationBeingFetched}`);
        }
        // --- END NEW LOGIC ---
    }
}

    function sortOutlookTable(columnKey, toggle = true) {
        if (toggle) {
            if (currentOutlookSort.columnKey === columnKey) {
                currentOutlookSort.ascending = !currentOutlookSort.ascending;
            } else {
                currentOutlookSort.columnKey = columnKey;
                currentOutlookSort.ascending = (columnKey === 'date');
            }
        }

        const config = outlookColumnConfig[columnKey];
        if (!config) return;

        allOutlookOpportunities.sort((a, b) => {
            let valA = a[config.dataKey];
            let valB = b[config.dataKey];

            if (config.dataKey === 'date') {
                 return currentOutlookSort.ascending ? new Date(valA) - new Date(valB) : new Date(valB) - new Date(valA);
            }

            if (config.numeric) {
                valA = parseFloat(valA) || 0;
                valB = parseFloat(valB) || 0;
                return currentOutlookSort.ascending ? valA - valB : valB - valA;
            } else {
                return currentOutlookSort.ascending ? String(valA).localeCompare(String(valB)) : String(valB).localeCompare(String(valA));
            }
        });

        document.querySelectorAll('#outlook-table th .sort-indicator').forEach(span => span.innerHTML = '');
        const activeTh = document.querySelector(`#outlook-table th[data-outlook-column-key="${columnKey}"] .sort-indicator`);
        if (activeTh) activeTh.innerHTML = currentOutlookSort.ascending ? '▲' : '▼';

        renderOutlookTable();
    }

    function filterOutlookTable() {
        renderOutlookTable(); // The render function will handle filtering
    }

    function sortTable(columnKey, toggle = true) { // DSO Table Sort
        const table = document.getElementById("data-table");
        if (!table) return;
        let sortOrder;
        if (toggle) {
            if (currentSort.columnKey === columnKey) { currentSort.ascending = !currentSort.ascending; }
            else { currentSort.columnKey = columnKey; currentSort.ascending = true; }
            localStorage.setItem("dso_sortOrder", currentSort.ascending ? "asc" : "desc");
            localStorage.setItem("dso_sortColumnKey", columnKey);
        } else {
            const storedSortOrder = localStorage.getItem("dso_sortOrder");
            const storedSortColumnKey = localStorage.getItem("dso_sortColumnKey");
            if (storedSortColumnKey) {
                currentSort.columnKey = storedSortColumnKey;
                currentSort.ascending = (storedSortOrder === "asc");
            }
        }
        sortOrder = currentSort.ascending ? "asc" : "desc";
        table.setAttribute("data-sort-order", sortOrder);
        const tbody = document.getElementById("data-body");
        if (!tbody) return;
        const rows = Array.from(tbody.getElementsByTagName("tr"));
        const config = columnConfig[currentSort.columnKey];

        rows.sort((a, b) => {
            const cellA_element = a.querySelector(`td[data-column-key="${currentSort.columnKey}"]`);
            const cellB_element = b.querySelector(`td[data-column-key="${currentSort.columnKey}"]`);
            if (!cellA_element || !cellB_element) return 0;
            let valA_str = cellA_element.dataset.rawValue !== undefined ? cellA_element.dataset.rawValue : cellA_element.innerText.trim();
            let valB_str = cellB_element.dataset.rawValue !== undefined ? cellB_element.dataset.rawValue : cellB_element.innerText.trim();
            const isNA_A = valA_str === 'N/A' || valA_str === ''; const isNA_B = valB_str === 'N/A' || valB_str === '';
            if (isNA_A && isNA_B) return 0; if (isNA_A) return currentSort.ascending ? 1 : -1; if (isNA_B) return currentSort.ascending ? -1 : 1;
            let valA = valA_str; let valB = valB_str;
            // --- MODIFIED TO ADD NEW COLUMN ---
            const numericSortKeys = [
                'Altitude Current', 'Azimuth Current', 'Altitude 11PM', 'Azimuth 11PM',
                'Observable Duration (min)', 'Max Altitude (°)', 'Angular Separation (°)',
                'Magnitude', 'Size', 'SB', 'Max Altitude'
            ];
            // --- END MODIFICATION ---
            if (config && numericSortKeys.includes(currentSort.columnKey)) { valA = parseFloat(valA_str); valB = parseFloat(valB_str); }
            else if (currentSort.columnKey === 'Transit Time' && /^\d{1,2}:\d{2}$/.test(valA_str) && /^\d{1,2}:\d{2}$/.test(valB_str)) { valA = parseTimeToMinutes(valA_str); valB = parseTimeToMinutes(valB_str); }
            if (typeof valA === 'number' && typeof valB === 'number') { if (isNaN(valA) && isNaN(valB)) return 0; if (isNaN(valA)) return currentSort.ascending ? 1 : -1; if (isNaN(valB)) return currentSort.ascending ? -1 : 1; return currentSort.ascending ? valA - valB : valB - valA; }
            return currentSort.ascending ? String(valA).localeCompare(String(valB)) : String(valB).localeCompare(String(valA));
        });
        rows.forEach(row => tbody.appendChild(row));
        updateSortIndicators();
    }

    function updateSortIndicators() { // DSO Table
        document.querySelectorAll('#data-table > thead > tr:not(.filter-row) > th .sort-indicator').forEach(span => span.innerHTML = '');
        const activeTh = document.querySelector(`#data-table > thead > tr:not(.filter-row) > th[data-column-key="${currentSort.columnKey}"]`);
        if (activeTh) { const indicator = activeTh.querySelector('.sort-indicator'); if (indicator) indicator.innerHTML = currentSort.ascending ? '▲' : '▼'; }
    }

    function filterTable() { // DSO Table
      const tbody = document.getElementById("data-body");
      if (!tbody) return;
      const rows = tbody.getElementsByTagName("tr");
      const activeFilters = {};
      for (const columnKey in columnConfig) {
        if (columnConfig.hasOwnProperty(columnKey) && columnConfig[columnKey].filterable) {
          const inputElement = document.querySelector(`#data-table .filter-row th[data-column-key="${columnKey}"] input`);
          if (inputElement && inputElement.value.trim() !== '') {
            activeFilters[columnKey] = inputElement.value.trim().toLowerCase();
          }
        }
      }
      for (let i = 0; i < rows.length; i++) {
        let showRow = true;
        for (const columnKeyInFilter in activeFilters) {
            const filterValue = activeFilters[columnKeyInFilter]; const config = columnConfig[columnKeyInFilter];
            if (!config) continue;
            const cellElement = rows[i].querySelector(`td[data-column-key="${columnKeyInFilter}"]`);
            if (!cellElement) { showRow = false; break; }
            let cellText = (cellElement.dataset.rawValue || cellElement.innerText).trim().toLowerCase();
            if (filterValue === "n/a" || filterValue === "na") { if (cellText !== "n/a") { showRow = false; break; } continue; }
            if (config.dataKey === 'Type') {
                const filterTypes = filterValue.split(/[\s,]+/).filter(t => t.length > 0);
                if (filterTypes.length > 0) { let typeMatch = false; for (const typeTerm of filterTypes) { if (cellText === typeTerm || cellText.includes(typeTerm)) { typeMatch = true; break; } } if (!typeMatch) { showRow = false; break; } }
            } else {
                const numericFilterKeys = [
                    'Altitude Current', 'Azimuth Current', 'Altitude 11PM', 'Azimuth 11PM',
                    'Observable Duration (min)', 'Max Altitude (°)', 'Angular Separation (°)',
                    'Magnitude', 'Size', 'SB', 'Max Altitude'
                ];

                // --- THIS IS THE FIX ---
                // We must check if the columnKeyInFilter is in the array,
                // NOT the config.dataKey.
                if (config && numericFilterKeys.includes(columnKeyInFilter)) {
                // --- END OF FIX ---
                    if (cellText === "n/a") { showRow = false; break; }
                    const cellNumber = parseFloat(cellText.replace(/[^0-9.\-]/g, ""));
                    if (isNaN(cellNumber)) {
                        // If we can't parse a number, fall back to substring match
                        if (cellText.indexOf(filterValue) === -1) { showRow = false; break; }
                        continue;
                    }
                    if (!matchesNumericFilter(cellNumber, filterValue)) { showRow = false; break; }
                } else {
                    // --- NEW LOGIC for comma-separated filters ---
                    if (columnKeyInFilter === 'Best Month') {
                        const filterTerms = filterValue.split(/[\s,]+/).filter(t => t.length > 0);
                        if (filterTerms.length > 0) {
                            // Check if the cellText (e.g., "dec") matches ANY of the filter terms (e.g., "dec", "jan")
                            const matchFound = filterTerms.some(term => cellText.includes(term));
                            if (!matchFound) {
                                showRow = false;
                                break;
                            }
                        }
                    // --- END NEW LOGIC ---
                    } else if (filterValue.startsWith("!")) {
                        if (cellText.includes(filterValue.substring(1))) { showRow = false; break; }
                    } else {
                        if (!cellText.includes(filterValue)) { showRow = false; break; }
                    }
                }
            }
        } rows[i].style.display = showRow ? "" : "none";
      }
      updateRemoveFiltersButtonVisibility();
      if (outlookDataLoaded) { renderOutlookTable(); }
    }

    function saveFilter(inputElement, columnKey, tableType = 'dso') {
      localStorage.setItem(tableType + "_filter_col_key_" + columnKey, inputElement.value);
    }

    function showGraph(objectName, dateStr = null, targetTab = 'chart') {
        let url = '/graph_dashboard/' + encodeURIComponent(objectName);
        const params = new URLSearchParams();
        const currentSelectedLocation = sessionStorage.getItem('selectedLocation');
        if (currentSelectedLocation) {
            params.set('location', currentSelectedLocation); // Add location to URL parameters
        }

        if (dateStr) {
            const parts = dateStr.split('-');
            if (parts.length === 3) {
                params.set('year', parts[0]);
                params.set('month', parts[1]);
                params.set('day', parts[2]);
            }
        }

        // This 'if' block is the key part of the logic
        if (targetTab) {
            params.set('tab', targetTab);
        }

        const queryString = params.toString();
        if (queryString) {
            url += '?' + queryString;
        }

        window.location.href = url;
    }

function fetchLocations() {
        fetch('/get_locations')
        .then(response => response.json())
        .then(data => {
            let locationSelect = document.getElementById('location-select');
            if (!locationSelect) return;
            locationSelect.innerHTML = ''; // Clear existing options

            // --- ADD: Determine initial location ---
            let initialLocation = sessionStorage.getItem('selectedLocation');
            // If nothing in session storage OR if the stored location is no longer valid/active, use the default from backend
            if (!initialLocation || !data.locations.includes(initialLocation)) {
                initialLocation = data.selected; // 'selected' is the default from backend
                if (initialLocation) {
                    sessionStorage.setItem('selectedLocation', initialLocation);
                }
            }
            // --- END ADD ---

            data.locations.forEach(location => {
                let option = document.createElement('option');
                option.value = location;
                option.textContent = location;
                // --- MODIFY: Select based on initialLocation ---
                if (location === initialLocation) {
                    option.selected = true;
                }
                // --- END MODIFY ---
                locationSelect.appendChild(option);
            });

            // --- ADD: Trigger initial data load AFTER setting the dropdown ---
            // This ensures the first fetchData uses the correct location
            // We call setLocation indirectly via the 'change' event if the value differs,
            // otherwise directly trigger fetches if the value is already correct.
             if (locationSelect.value !== initialLocation && initialLocation) {
                 locationSelect.value = initialLocation; // Ensure dropdown matches
                 // Manually trigger if needed, though initial fetches should handle it now
                 // setLocation();
             }
             // Initial fetches should happen in window.onload now, using the sessionStorage value implicitly
             // fetchData(); // No longer needed here, handled by window.onload
             // fetchSunEvents(); // No longer needed here, handled by window.onload

        })
        .catch(error => console.error('❌ Error fetching locations:', error));
    }

function setLocation() {
    // Get the table body to check its loading status
    const tbody = document.getElementById("data-body");

    // Get the newly selected location
    const selectedLocation = document.getElementById('location-select').value;

    // Always store the user's *latest* choice in sessionStorage.
    // This is what we'll check when the current fetch finishes.
    console.log(`Location select changed to: ${selectedLocation}`);
    sessionStorage.setItem('selectedLocation', selectedLocation);
    outlookDataLoaded = false; // Reset outlook flag for the new location

    // --- NEW LOGIC ---
    // If data is already being fetched, just update the loading message and stop.
    // The `fetchData` function will see this change when it finishes.
    if (tbody.dataset.loading === 'true') {
        console.log(`Location change to ${selectedLocation} queued (data load in progress).`);
        const loadingDiv = document.getElementById('table-loading');
        if (loadingDiv) {
            loadingDiv.innerHTML = `Switching to ${selectedLocation}...`;
            loadingDiv.style.display = "block";
        }
        return; // Do NOT trigger another fetch
    }

    // --- If we are NOT loading, proceed as normal ---
    console.log(`Triggering fetch for new location: ${selectedLocation}`);

    // Clear existing data immediately
    document.getElementById('data-body').innerHTML = '';
    document.getElementById('journal-data-body').innerHTML = '';
    document.getElementById('outlook-body').innerHTML = '';

    // Show loading indicator
    const loadingDiv = document.getElementById('table-loading');
    if (loadingDiv) {
        loadingDiv.innerHTML = "Updating location...";
        loadingDiv.style.display = "block";
    }

    // Trigger the data fetches for the new location
    fetchData();

    if (activeTab === 'journal') {
       populateJournalTable();
    } else if (activeTab === 'outlook') {
       fetchOutlookData(); // Re-fetch outlook for the new location
    }
}

    function fetchSunEvents() {
        const currentSelectedLocation = sessionStorage.getItem('selectedLocation');
        fetch(`/sun_events?location=${encodeURIComponent(currentSelectedLocation || '')}`)
        .then(response => response.json())
        .then(data => {
          document.getElementById('dawn').textContent = data.astronomical_dawn;
          document.getElementById('dusk').textContent = data.astronomical_dusk;
          const dateEl = document.getElementById('date');
          const timeEl = document.getElementById('time');
          const phaseEl = document.getElementById('phase');
          if(dateEl && data.date) dateEl.textContent = formatDateISOtoEuropean(data.date);
          if(timeEl && data.time) timeEl.textContent = data.time;
          if(phaseEl && data.phase !== undefined) phaseEl.textContent = `${data.phase}%`;
        })
        .catch(error => { console.error('❌ Error fetching sun events:', error);});
    }

    // ========================================================================
    // Journal Table Functions
    // ========================================================================
function populateJournalTable() {
        const tableBody = document.getElementById('journal-data-body');
        if (!tableBody || !allJournalSessions) return;

        let sessionsToDisplay = [...allJournalSessions];

        // --- [PRESERVED] Your existing filtering logic ---
        const journalFilterInputs = document.querySelectorAll("#journal-filter-row input");
        const activeJournalFilters = {};
        journalFilterInputs.forEach(input => {
            const thParent = input.closest('th');
            if (thParent) {
                const columnKey = thParent.dataset.journalColumnKey;
                const value = input.value.trim().toLowerCase();
                if (value !== '') activeJournalFilters[columnKey] = value;
            }
        });
        const journalNumericFilterKeys = ['calculated_integration_time_minutes','guiding_rms_avg_arcsec','seeing_observed_fwhm','session_rating_subjective'];
        if (Object.keys(activeJournalFilters).length > 0) {
            sessionsToDisplay = sessionsToDisplay.filter(session => {
                for (const key in activeJournalFilters) {
                    const filterValue = activeJournalFilters[key];
                    const config = journalColumnConfig[key];
                    if (!config) continue;
                    let rawSessionValueStr = String(session[config.dataKey] || '').toLowerCase();
                    if (filterValue === "n/a" || filterValue === "na") { if (rawSessionValueStr !== "n/a" && rawSessionValueStr !== "") return false; continue; }
                    if (key === 'date_utc') { // Corrected key for date filtering
                        const sessionDateString_YYYY_MM_DD = session[config.dataKey] || "";
                        if (!sessionDateString_YYYY_MM_DD) return false;
                        let operator = null; let dateFilterStringUserInput = filterValue;
                        if (dateFilterStringUserInput.startsWith(">=")) { operator = ">="; dateFilterStringUserInput = dateFilterStringUserInput.substring(2).trim(); }
                        else if (dateFilterStringUserInput.startsWith("<=")) { operator = "<="; dateFilterStringUserInput = dateFilterStringUserInput.substring(2).trim(); }
                        else if (dateFilterStringUserInput.startsWith(">")) { operator = ">"; dateFilterStringUserInput = dateFilterStringUserInput.substring(1).trim(); }
                        else if (dateFilterStringUserInput.startsWith("<")) { operator = "<"; dateFilterStringUserInput = dateFilterStringUserInput.substring(1).trim(); }
                        try {
                            let filterDateObj = null;
                            if (dateFilterStringUserInput.includes('.')) { const parts = dateFilterStringUserInput.split('.'); if (parts.length === 3) { filterDateObj = new Date(Date.UTC(parseInt(parts[2]), parseInt(parts[1]) - 1, parseInt(parts[0]))); } }
                            const sessionParts = sessionDateString_YYYY_MM_DD.split('-'); if (sessionParts.length !== 3) return false;
                            const sessionDateObj = new Date(Date.UTC(parseInt(sessionParts[0]), parseInt(sessionParts[1]) - 1, parseInt(sessionParts[2])));
                            if (operator && filterDateObj) {
                                if (operator === ">=" && sessionDateObj < filterDateObj) return false; if (operator === "<=" && sessionDateObj > filterDateObj) return false;
                                if (operator === ">" && sessionDateObj <= filterDateObj) return false; if (operator === "<" && sessionDateObj >= filterDateObj) return false;
                            } else if (!operator) { const formattedSessionDate = formatDateISOtoEuropean(sessionDateString_YYYY_MM_DD).toLowerCase(); if (!sessionDateString_YYYY_MM_DD.includes(dateFilterStringUserInput) && !formattedSessionDate.includes(dateFilterStringUserInput)) return false; }
                        } catch (e) { return false; }
                        continue;
                    }
                    if (journalNumericFilterKeys.includes(key)) {
                        let sessionNumericValue = session[config.dataKey];
                        if (sessionNumericValue === null || sessionNumericValue === undefined) return false;
                        const cellNumber = parseFloat(sessionNumericValue);
                        if (isNaN(cellNumber)) { if (!rawSessionValueStr.includes(filterValue)) return false; continue; }
                        if (!matchesNumericFilter(cellNumber, filterValue)) return false;
                    } else { if (filterValue.startsWith("!")) { if (rawSessionValueStr.includes(filterValue.substring(1))) return false; } else { if (!rawSessionValueStr.includes(filterValue)) return false; } }
                } return true;
            });
        }

        // --- [PRESERVED] Your existing sorting logic ---
        const sortConfig = journalColumnConfig[currentJournalSort.columnKey];
        if (sortConfig) {
            sessionsToDisplay.sort((a, b) => {
                let valA_str = String(a[sortConfig.dataKey] === undefined ? '' : a[sortConfig.dataKey]);
                let valB_str = String(b[sortConfig.dataKey] === undefined ? '' : b[sortConfig.dataKey]);
                const isNA_A = valA_str.toLowerCase() === 'n/a' || valA_str === '';
                const isNA_B = valB_str.toLowerCase() === 'n/a' || valB_str === '';
                if (isNA_A && isNA_B) return 0; if (isNA_A) return currentJournalSort.ascending ? 1 : -1; if (isNA_B) return currentJournalSort.ascending ? -1 : 1;
                if (sortConfig.dataKey === 'date_utc') {
                    const valA = new Date(valA_str); const valB = new Date(valB_str);
                    return currentJournalSort.ascending ? valA - valB : valB - valA;
                } else if (journalNumericFilterKeys.includes(sortConfig.dataKey)) {
                    const valA = parseFloat(valA_str); const valB = parseFloat(valB_str);
                    return currentJournalSort.ascending ? valA - valB : valB - valA;
                }
                return currentJournalSort.ascending ? valA_str.localeCompare(valB_str) : valB_str.localeCompare(String(valB_str));
            });
        }

        // --- [PRESERVED & CORRECTED] Your rendering logic ---
        tableBody.innerHTML = '';
        let previousTargetIdForGrouping = null;

        sessionsToDisplay.forEach(session => {
            const row = document.createElement('tr');
            row.classList.add('clickable-row');
            row.setAttribute('data-session-id', session.id);
            row.setAttribute('data-target-object-id', session.object_name);

            let showFullTargetInfoThisRow = true;

            // --- THIS IS THE CORRECTED GROUPING LOGIC ---
            if (currentJournalSort.columnKey === 'object_name' || currentJournalSort.columnKey === 'target_common_name') {
                if (session.object_name === previousTargetIdForGrouping) {
                    showFullTargetInfoThisRow = false;
                }
                previousTargetIdForGrouping = session.object_name;
            }
            // --- END OF CORRECTION ---

            for (const key in journalColumnConfig) {
                const config = journalColumnConfig[key];
                const td = document.createElement('td');
                td.dataset.journalColumnKey = key;

                let rawValue = session[config.dataKey];
                let displayValue = "";
                if (rawValue === null || rawValue === undefined || (typeof rawValue === 'string' && rawValue.trim() === "") || rawValue === 'N/A') {
                    displayValue = "N/A";
                } else if (config.format) {
                    displayValue = config.format(rawValue);
                } else {
                    displayValue = String(rawValue);
                }

                // Correctly apply the grouping visual effect
                if ((config.dataKey === 'object_name' || config.dataKey === 'target_common_name') && !showFullTargetInfoThisRow) {
                    td.innerHTML = "";
                } else {
                    td.innerHTML = String(displayValue);
                }

                row.appendChild(td);
            }

            row.addEventListener('click', function() {
                const targetId = this.getAttribute('data-target-object-id');
                const sessionId = this.getAttribute('data-session-id');
                if (targetId && sessionId) {
                    window.location.href = `/graph_dashboard/${encodeURIComponent(targetId)}?session_id=${encodeURIComponent(sessionId)}&tab=journal`;
                }
            });
            tableBody.appendChild(row);
        });
        updateJournalSortIndicators();
    }

    function sortJournalTable(columnKey, toggle = true) {
        if (toggle) {
            if (currentJournalSort.columnKey === columnKey) { currentJournalSort.ascending = !currentJournalSort.ascending; }
            else { currentJournalSort.columnKey = columnKey; currentJournalSort.ascending = true; }
            localStorage.setItem("journal_sortOrder", currentJournalSort.ascending ? "asc" : "desc");
            localStorage.setItem("journal_sortColumnKey", columnKey);
        } else {
            const storedSortOrder = localStorage.getItem("journal_sortOrder");
            const storedSortColumnKey = localStorage.getItem("journal_sortColumnKey");
            if (storedSortColumnKey) {
                currentJournalSort.columnKey = storedSortColumnKey;
                currentJournalSort.ascending = (storedSortOrder === "asc");
            }
        }
        populateJournalTable();
    }

    function updateJournalSortIndicators() {
        document.querySelectorAll('#journal-data-table th .sort-indicator').forEach(span => span.innerHTML = '');
        const activeTh = document.querySelector(`#journal-data-table > thead > tr:not(.filter-row) > th[data-journal-column-key="${currentJournalSort.columnKey}"]`);
        if (activeTh) { const indicator = activeTh.querySelector('.sort-indicator'); if (indicator) { indicator.innerHTML = currentJournalSort.ascending ? '▲' : '▼'; } }
    }

    function filterJournalTable() { populateJournalTable(); }
    function saveJournalFilter(inputElement, columnKey) { localStorage.setItem("journal_filter_col_key_" + columnKey, inputElement.value); }

    // ========================================================================
    // window.onload Event Handler
    // ========================================================================
    window.onload = () => {
      // --- START: New Timer Logic ---
      let timeToNextUpdate = 60;
      const updateIntervalInSeconds = 60;
      const timerSpan = document.getElementById('next-update-timer');

      // This is the 60-second interval to fetch data
      setInterval(() => {
        fetchData();
        fetchSunEvents();
        timeToNextUpdate = updateIntervalInSeconds; // Reset the timer
        if (timerSpan) timerSpan.textContent = `in ${timeToNextUpdate}s`; // Update text immediately
      }, updateIntervalInSeconds * 1000); // 60000ms

      // This is the new 1-second interval to update the countdown display
      setInterval(() => {
          timeToNextUpdate--; // Decrement the timer
          if (timeToNextUpdate < 0) {
              timeToNextUpdate = 0; // Don't go below zero
          }
          if (timerSpan) {
              timerSpan.textContent = `in ${timeToNextUpdate}s`;
          }
      }, 1000); // Run every 1 second
      // --- END: New Timer Logic ---

      activeTab = localStorage.getItem('activeTab') || 'position';
      const initialDsoSortColumnKey = localStorage.getItem("dso_sortColumnKey") || 'Altitude Current';
      const initialDsoSortOrder = localStorage.getItem("dso_sortOrder") || 'desc';
      currentSort.columnKey = initialDsoSortColumnKey;
      currentSort.ascending = (initialDsoSortOrder === "asc");
      const initialJournalSortColumnKey = localStorage.getItem("journal_sortColumnKey") || 'session_date';
      const initialJournalSortOrder = localStorage.getItem("journal_sortOrder") || 'desc';
      currentJournalSort.columnKey = initialJournalSortColumnKey;
      currentJournalSort.ascending = (initialJournalSortOrder === "asc");
      const removeFiltersBtn = document.getElementById('remove-filters-btn');
      if (removeFiltersBtn) { removeFiltersBtn.addEventListener('click', clearAllFilters); }

      fetchLocations();
      fetchSunEvents();
      fetchData();

      updateTabDisplay();

      // The 60-second interval is now handled by the new timer logic above
      // so we remove the old one.
      /*
      setInterval(() => {
        fetchData();
        fetchSunEvents();
      }, 60000);
      */

      document.querySelectorAll('.tab-button').forEach(button => {
        button.addEventListener('click', () => { activeTab = button.dataset.tab; updateTabDisplay(); });
      });
      document.querySelectorAll("#data-table > thead > tr:not(.filter-row) > th[data-column-key]").forEach(header => {
        const columnKey = header.dataset.columnKey;
        if (columnConfig[columnKey] && columnConfig[columnKey].sortable) { header.addEventListener("click", () => sortTable(columnKey, true)); }
      });
      document.querySelectorAll("#data-table .filter-row input").forEach(input => {
          const thParent = input.closest('th'); const columnKey = thParent ? thParent.dataset.columnKey : null;
          if (columnKey && columnConfig[columnKey] && columnConfig[columnKey].filterable) { input.addEventListener("keyup", () => { saveFilter(input, columnKey, 'dso'); filterTable(); }); }
      });
      document.querySelectorAll("#journal-data-table > thead > tr:not(.filter-row) > th[data-journal-column-key]").forEach(header => {
        const columnKey = header.dataset.journalColumnKey;
        if (journalColumnConfig[columnKey] && journalColumnConfig[columnKey].sortable) { header.addEventListener("click", () => sortJournalTable(columnKey, true)); }
      });
      document.querySelectorAll("#journal-filter-row input").forEach(input => {
          const thParent = input.closest('th'); const columnKey = thParent ? thParent.dataset.journalColumnKey : null;
          if (columnKey && journalColumnConfig[columnKey] && journalColumnConfig[columnKey].filterable) { input.addEventListener("keyup", () => { saveJournalFilter(input, columnKey); filterJournalTable(); }); }
      });
      document.querySelectorAll("#outlook-table th[data-outlook-column-key]").forEach(header => {
          const columnKey = header.dataset.outlookColumnKey;
          if (outlookColumnConfig[columnKey] && outlookColumnConfig[columnKey].sortable) {
              header.addEventListener("click", (event) => {
                  if (event.target.tagName.toLowerCase() === 'input') { return; }
                  sortOutlookTable(columnKey, true);
              });
          }
      });
      document.querySelectorAll("#outlook-filter-row input").forEach(input => {
          const thParent = input.closest('th');
          const columnKey = thParent ? thParent.dataset.outlookColumnKey : null;
          if (columnKey && outlookColumnConfig[columnKey] && outlookColumnConfig[columnKey].filterable) { input.addEventListener("keyup", filterOutlookTable); }
      });
      for (const key in columnConfig) {
        if (columnConfig[key].filterable) { const val = localStorage.getItem("dso_filter_col_key_" + key); const inputEl = document.querySelector(`#data-table .filter-row th[data-column-key="${key}"] input`); if (val && inputEl) inputEl.value = val; }
      }
      for (const key in journalColumnConfig) {
        if (journalColumnConfig[key].filterable) { const val = localStorage.getItem("journal_filter_col_key_" + key); const inputEl = document.querySelector(`#journal-filter-row th[data-journal-column-key="${key}"] input`); if (val && inputEl) inputEl.value = val; }
      }
       filterTable();
       filterJournalTable();
       updateRemoveFiltersButtonVisibility();
    };

    function renderOutlookTable() {
        const tableBody = document.getElementById('outlook-body');
        if (!tableBody) return;
        const allFilters = {};
        document.querySelectorAll('#outlook-filter-row input').forEach(input => {
            const key = input.closest('th').dataset.outlookColumnKey;
            if (input.value.trim() !== '') allFilters[key] = input.value.trim().toLowerCase();
        });
        const dsoFilterKeys = ['Object', 'Common Name', 'Type', 'Constellation', 'Magnitude', 'Size', 'SB'];
        const dsoToOutlookKeyMap = { 'Object': 'object_name', 'Common Name': 'common_name', 'Type': 'type', 'Constellation': 'constellation', 'Magnitude': 'magnitude', 'Size': 'size', 'SB': 'sb' };
        dsoFilterKeys.forEach(dsoKey => {
            const input = document.querySelector(`#data-table .filter-row th[data-column-key="${dsoKey}"] input`);
            const outlookKey = dsoToOutlookKeyMap[dsoKey];
            if (input && input.value.trim() !== '' && outlookKey) { allFilters[outlookKey] = input.value.trim().toLowerCase(); }
        });
        let filteredData = allOutlookOpportunities.filter(opp => {
            return Object.keys(allFilters).every(key => {
                const filterValue = allFilters[key]; const config = outlookColumnConfig[key];
                if (key === 'rating') {
                    const numericRating = opp.rating_num; if (numericRating === undefined || numericRating === null) return false;
                    const match = filterValue.match(/([<>]=?)\s*(\d+)/);
                    if (match) { const op = match[1]; const num = parseInt(match[2], 10); if (op === ">") return numericRating > num; if (op === ">=") return numericRating >= num; if (op === "<") return numericRating < num; if (op === "<=") return numericRating <= num; }
                    else if (/^\d+$/.test(filterValue)) { return numericRating === parseInt(filterValue, 10); }
                    return String(opp.rating || '').toLowerCase().includes(filterValue);
                }
                const cellValue = String(opp[key] || '').toLowerCase();
                if (config && config.numeric) {
                    const cellNumber = parseFloat(cellValue); if (isNaN(cellNumber)) return false;
                    const match = filterValue.match(/([<>]=?)\s*(\d+\.?\d*)/);
                    if (match) { const op = match[1]; const num = parseFloat(match[2]); if (op === ">") return cellNumber > num; if (op === ">=") return cellNumber >= num; if (op === "<") return cellNumber < num; if (op === "<=") return cellNumber <= num; }
                    return cellValue.includes(filterValue);
                } else {
                    const filterTerms = filterValue.split(/[\s,]+/).filter(t => t.length > 0);
                    if (filterTerms.length === 0) return true;
                    return filterTerms.some(term => cellValue.includes(term));
                }
            });
        });
        if (filteredData.length > 0) {
            let htmlRows = "";
            filteredData.forEach(target => {
                htmlRows += `
                    <tr class="clickable-row" onclick="showGraph('${target.object_name}', '${target.date}', 'chart')">
                        <td>${target.object_name}</td>
                        <td>${target.common_name}</td>
                        <td style="text-align:center;">${formatDateISOtoEuropean(target.date)}</td>
                        <td style="text-align:center;">${target.max_alt}°</td>
                        <td style="text-align:center;">${target.obs_dur} min</td>
                        <td style="text-align:center;">${target.rating}</td>
                    </tr>
                `;
            });
            tableBody.innerHTML = htmlRows;
        } else {
            tableBody.innerHTML = `<tr><td colspan="6" style="text-align:center; padding:20px; color:orange;">No targets found matching your filters.</td></tr>`;
        }
    }


    function fetchOutlookData() {
        const tableBody = document.getElementById('outlook-body');
        const loadingDiv = document.getElementById("table-loading"); // Assuming you might have a general loading div
        if (!tableBody) return;

        // --- START FIX ---
        // Get the main DSO table body to check if a location update is already in progress
        const mainDsoTbody = document.getElementById("data-body");
        const isLocationUpdating = mainDsoTbody && mainDsoTbody.dataset.loading === 'true';

        // Show fetching message only if not already updating location UI
        if (!isLocationUpdating) {
        // --- END FIX ---
            tableBody.innerHTML = `<tr><td colspan="6" style="text-align:center; padding:20px; color:#6795a4;">Fetching...</td></tr>`;
        }

        // --- START FIX ---
        // Get the currently selected location name from browser's session storage
        const currentSelectedLocation = sessionStorage.getItem('selectedLocation');
        // Construct the URL with the location as a query parameter
        const fetchUrl = `/get_outlook_data?location=${encodeURIComponent(currentSelectedLocation || '')}`;
        // --- END FIX ---

        fetch(fetchUrl) // <-- Use the modified URL
            .then(response => response.json())
            .then(data => {
                // --- FIX: Only set outlookDataLoaded to true when data is actually complete ---
                // if (!outlookDataLoaded) { outlookDataLoaded = true; } // REMOVE THIS LINE (it was a bug)

                if (data.status === 'complete') {
                    // --- FIX: Set loaded flag ONLY on complete ---
                    if (!outlookDataLoaded) { outlookDataLoaded = true; } // Correct placement

                    allOutlookOpportunities = data.results || []; // Store data globally
                    if (allOutlookOpportunities.length > 0) {
                        // Sort and render the table (assuming sortOutlookTable also calls renderOutlookTable)
                        sortOutlookTable(currentOutlookSort.columnKey, false);
                    } else {
                        tableBody.innerHTML = `<tr><td colspan="6" style="text-align:center; padding:20px; color:grey;">No imaging opportunities found matching the criteria.</td></tr>`;
                    }
                } else if (data.status === 'running' || data.status === 'starting') {
                    // Background task is running, show waiting message
                    if ((data.results || []).length > 0) {
                         // Optionally display stale data while waiting
                        allOutlookOpportunities = data.results || [];
                        sortOutlookTable(currentOutlookSort.columnKey, false);
                    } else {
                        tableBody.innerHTML = `<tr><td colspan="6" style="text-align:center; padding:20px; color:#6795a4;">Waiting for background task...</td></tr>`;
                    }
                    // Poll again after a delay
                    setTimeout(fetchOutlookData, 10000);
                } else { // Handle 'idle' (should become 'starting' now) or 'error'
                    tableBody.innerHTML = `<tr><td colspan="6" style="text-align:center; padding:20px; color:orange;">No data available or error. Check server logs if this persists. ${data.message || ''}</td></tr>`;
                    // Optionally set outlookDataLoaded = true here too, to stop retrying on error
                     if (!outlookDataLoaded) { outlookDataLoaded = true; }
                }
                // Hide general loading indicator if used
                if (loadingDiv) loadingDiv.style.display = 'none';
            })
            .catch(error => {
                // outlookDataLoaded = true; // Set flag even on error to stop retries
                console.error("Error fetching outlook data:", error);
                tableBody.innerHTML = `<tr><td colspan="6" style="text-align:center; padding:20px; color:red;">Error fetching data. Check console for details.</td></tr>`;
                if (loadingDiv) loadingDiv.style.display = 'none';
            });
    }

    document.addEventListener("DOMContentLoaded", function () {
        setTimeout(() => {
            const flashMessages = document.querySelectorAll(".flash-transient");
            flashMessages.forEach(el => {
                if (el) { el.style.transition = "opacity 0.5s ease"; el.style.opacity = "0"; setTimeout(() => el.remove(), 500); }
            });
        }, 4000);
    });
    </script>
{% endblock %}
</head>
<body> {% block body %}

  <div class="info-bar-wrapper">
      <div class="user-info">
        {% if is_guest %}
          Mode: <strong>Guest</strong> —
          <button onclick="location.href='{{ url_for('login') }}'">
            Log in
          </button>
          for full access.
        {% elif SINGLE_USER_MODE %}
          Mode: <strong>Single User</strong>
        {% else %}
          Mode: <strong>Multi User</strong> — Logged in as <strong>{{ current_user.username }}</strong>
            <form action="{{ url_for('logout') }}" method="post" style="display: inline;">
              <button type="submit">
                Log Out
              </button>
            </form>
        {% endif %}
      </div>
      <div class="info-bar-container">
        {% if SINGLE_USER_MODE or not is_guest %}
            <div>
                <button type="button" id="back-button"
                        onclick="window.location.href='{{ url_for('config_form') }}'">
                  Configuration
                </button>
            </div>
        {% endif %}
        <div class="info-bar-location-datetime-group">
            <p style="margin:0; display:flex; align-items:center; gap: 5px;">
                <small>Location:</small>
                <span>
                  <select id="location-select" onchange="setLocation()">
                    </select>
                </span>
            </p>
            <div class="info-values">
                <p><small>Date:</small> <span id="date"></span></p>
                <p><small>Time:</small> <span id="time"></span></p>
                <p><small>Moon Illumination:</small> <span id="phase"></span></p>
                <p><small>Astr. Dusk:</small> <span id="dusk"></span></p>
                <p><small>Astr. Dawn:</small> <span id="dawn"></span></p>
                <p><small>Next Update:</small> <span id="next-update-timer" style="font-weight:normal; font-size:14px; color:#555;">in 60s</span></p>
            </div>
        </div>
      </div>
  </div>

<div class="tab-container">
    <button class="tab-button active" data-tab="position">Position</button>
    <button class="tab-button" data-tab="properties">Properties</button>
    <button class="tab-button" data-tab="outlook">Outlook</button>
    <button class="tab-button" data-tab="journal">Journal</button>

    <div id="tab-message-container">
      {% with messages = get_flashed_messages(with_categories=true) %}
        {% if messages %}
          {% for category, message in messages %}
            <span class="{{ 'error' if category == 'error' else 'message' }} flash-transient" style="margin: 0;">{{ message }}</span>
          {% endfor %}
        {% endif %}
      {% endwith %}
    </div>

    <div id="remove-filters-container" style="display: none;">
     <button type="button" id="remove-filters-btn">
       Remove Filter
     </button>
    </div>
</div>
<div id="list-section">
    <div class="table-wrapper" id="dso-table-wrapper">
        <table id="data-table" data-sort-order="asc">
          <thead>
            <tr> {# Main Headers for DSO Table #}
              <th data-column-key="Object" class="col-always-visible sortable"><span>Object</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
              <th data-column-key="Common Name" class="col-always-visible sortable"><span>Common Name</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
              <th data-column-key="Altitude Current" class="col-position sortable"><span>Altitude<br><span class="subtext">(Current)</span></span><span class="sort-indicator"></span></th>
              <th data-column-key="Azimuth Current" class="col-position sortable"><span>Azimuth <br><span class="subtext">(Current)</span></span><span class="sort-indicator"></span></th>
              <th data-column-key="Trend" class="col-position sortable"><span>Trend</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
              <th data-column-key="Altitude 11PM" class="col-position sortable"><span>Altitude <br><span class="subtext">(11 PM)</span></span><span class="sort-indicator"></span></th>
              <th data-column-key="Azimuth 11PM" class="col-position sortable"><span>Azimuth <br><span class="subtext">(11 PM)</span></span><span class="sort-indicator"></span></th>
              <th data-column-key="Transit Time" class="col-position sortable"><span>Transit <br><span class="subtext">(Local Time)</span></span><span class="sort-indicator"></span></th>
              <th data-column-key="Observable Duration (min)" class="col-position sortable"><span>Observable <br><span class="subtext">(minutes)</span></span><span class="sort-indicator"></span></th>
              <th data-column-key="Max Altitude (°)" class="col-position sortable"><span>Max Altitude<br><span class="subtext">observable (°)</span></span><span class="sort-indicator"></span></th>
              <th data-column-key="Angular Separation (°)" class="col-position sortable"><span>Ang. Sep. <br><span class="subtext">to moon (°)</span></span><span class="sort-indicator"></span></th>
              <th data-column-key="Constellation" class="col-properties sortable"><span>Constellation</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
              <th data-column-key="Type" class="col-properties sortable"><span>Type</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
              <th data-column-key="Magnitude" class="col-properties sortable"><span>Magnitude</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
              <th data-column-key="Size" class="col-properties sortable"><span>Size (')</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
              <th data-column-key="SB" class="col-properties sortable"><span>SB</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
              <th data-column-key="Best Month" class="col-properties sortable"><span>Best Month</span><span class="subtext">(Opp.)</span><span class="sort-indicator"></span></th>
              <th data-column-key="Max Altitude" class="col-properties sortable"><span>Max Alt</span><span class="subtext">(Culm.)</span><span class="sort-indicator"></span></th>
            </tr>
            <tr class="filter-row"> {# Filter Row for DSO Table #}
              <th data-column-key="Object" class="col-always-visible"><input type="text" placeholder="Search Object" /></th>
              <th data-column-key="Common Name" class="col-always-visible"><input type="text" placeholder="Search Common Name" /></th>
              <th data-column-key="Altitude Current" class="col-position"><input type="text" placeholder="Altitude °" /></th>
              <th data-column-key="Azimuth Current" class="col-position"><input type="text" placeholder="Azimuth °" /></th>
              <th data-column-key="Trend" class="col-position"><input type="text" placeholder="Trend" disabled style="visibility:hidden;" /></th>
              <th data-column-key="Altitude 11PM" class="col-position"><input type="text" placeholder="Altitude °" /></th>
              <th data-column-key="Azimuth 11PM" class="col-position"><input type="text" placeholder="Azimuth °" /></th>
              <th data-column-key="Transit Time" class="col-position"><input type="text" placeholder="Transit" disabled style="visibility:hidden;" /></th>
              <th data-column-key="Observable Duration (min)" class="col-position"><input type="text" placeholder="minutes" /></th>
              <th data-column-key="Max Altitude (°)" class="col-position"><input type="text" placeholder="Max Alt. °" /></th>
              <th data-column-key="Angular Separation (°)" class="col-position"><input type="text" placeholder="Ang. Sep. °" /></th>
              <th data-column-key="Constellation" class="col-properties"><input type="text" placeholder="e.g. Cyg" /></th>
              <th data-column-key="Type" class="col-properties"><input type="text" placeholder="Type (e.g. PN,SNR)" /></th>
              <th data-column-key="Magnitude" class="col-properties"><input type="text" placeholder="Mag e.g. <8" /></th>
              <th data-column-key="Size" class="col-properties"><input type="text" placeholder="Size e.g. >10" /></th>
              <th data-column-key="SB" class="col-properties"><input type="text" placeholder="SB e.g. <22" /></th>
              <th data-column-key="Best Month" class="col-properties"><input type="text" placeholder="e.g. Dec" /></th>
              <th data-column-key="Max Altitude" class="col-properties"><input type="text" placeholder="e.g. >80" /></th>
            </tr>
          </thead>
          <tbody id="data-body"></tbody>
        </table>
    </div>

    <div class="table-wrapper" id="journal-table-wrapper" style="display:none;">
        <table id="journal-data-table" data-sort-order="desc">
            <thead>
                <tr>
                    <th data-journal-column-key="object_name"><span>Object</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
                    <th data-journal-column-key="target_common_name"><span>Common Name</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
                    <th data-journal-column-key="date_utc"><span>Date</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
                    <th data-journal-column-key="location_name"><span>Location</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
                    <th data-journal-column-key="telescope_setup_notes"><span>Telescope Setup</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
                    <th data-journal-column-key="calculated_integration_time_minutes"><span>Total Integration</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
                    <th data-journal-column-key="session_rating_subjective"><span>Session Rating</span><span class="subtext">&nbsp;</span><span class="sort-indicator"></span></th>
                </tr>
                <tr class="filter-row" id="journal-filter-row">
                    <th data-journal-column-key="object_name"><input type="text" placeholder="Object ID"/></th>
                    <th data-journal-column-key="target_common_name"><input type="text" placeholder="Search Common Name"/></th>
                    <th data-journal-column-key="date_utc"><input type="text" placeholder="DD.MM.YYYY"/></th>
                    <th data-journal-column-key="location_name"><input type="text" placeholder="Location"/></th>
                    <th data-journal-column-key="telescope_setup_notes"><input type="text" placeholder="Setup notes"/></th>
                    <th data-journal-column-key="calculated_integration_time_minutes"><input type="text" placeholder="e.g. >120"/></th>
                    <th data-journal-column-key="session_rating_subjective"><input type="text" placeholder="e.g. 4"/></th>
                </tr>
            </thead>
            <tbody id="journal-data-body">
                </tbody>
        </table>
    </div>

    <div class="table-wrapper" id="outlook-wrapper" style="display:none;">
        <table id="outlook-table">
            <thead>
                <tr>
                    <th data-outlook-column-key="object_name"><span>Object</span><span class="sort-indicator"></span></th>
                    <th data-outlook-column-key="common_name"><span>Common Name</span><span class="sort-indicator"></span></th>
                    <th data-outlook-column-key="date"><span>Date</span><span class="sort-indicator"></span></th>
                    <th data-outlook-column-key="max_alt"><span>Max Alt</span><span class="sort-indicator"></span></th>
                    <th data-outlook-column-key="obs_dur"><span>Obs. Time</span><span class="sort-indicator"></span></th>
                    <th data-outlook-column-key="rating"><span>Rating</span><span class="sort-indicator"></span></th>
                </tr>
                <tr class="filter-row" id="outlook-filter-row">
                    <th data-outlook-column-key="object_name"><input type="text" placeholder="Search Object"/></th>
                    <th data-outlook-column-key="common_name"><input type="text" placeholder="Search Common Name"/></th>
                    <th data-outlook-column-key="date"><input type="text" placeholder="Search Date"/></th>
                    <th data-outlook-column-key="max_alt"><input type="text" placeholder="e.g. >60"/></th>
                    <th data-outlook-column-key="obs_dur"><input type="text" placeholder="e.g. >300"/></th>
                    <th data-outlook-column-key="rating"><input type="text" placeholder="e.g. ★★★★★"/></th>
                </tr>
            </thead>
            <tbody id="outlook-body">
                </tbody>
        </table>
    </div>
    <div id="table-loading" style="display:none; color: #6795a4; font-weight: normal; margin-top: 30px; margin-left: 10px;">
      Loading...
    </div>
</div> {# End of list-section #}

<div id="graph-section" style="display: none;">
  <iframe id="graph-iframe"
          style="width: 100%; max-width:1500px; height: 1000px; border: none;"
          title="Graph">
  </iframe>
</div>
{% endblock %}
</body> </html>