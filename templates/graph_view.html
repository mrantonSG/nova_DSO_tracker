{% extends "base.html" %}

{% block title %}Graph – Nova DSO Tracker{% endblock %}

{% block head_extra %}

<script src="https://aladin.cds.unistra.fr/AladinLite/api/v3/latest/aladin.js" charset="utf-8"></script>
<style>
    body {
        padding: 20px;
        margin: 0;
    }

    #back-button {
        margin-top: 0;
        padding: 10px 20px;
        font-size: 16px;
        background-color: #83b4c5;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    }

    #back-button:hover {
        background-color: #6795a4 !important;
    }

    #chart-section img {
        max-width: 100%;
        height: auto;
        border-radius: 5px;
        margin-bottom: 10px;
        margin-bottom: 20px;
    }

    #chart-section {
        margin-top: 20px;
        display: flex;
        flex-direction: column;
        gap: 15px;
    }

    .date-controls {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 10px;
        margin-bottom: 10px;
    }

    .date-controls label, .date-controls input, .date-controls select {
        font-size: 14px;
        padding: 4px;
    }

    .view-buttons {
        margin-top: 10px;
        display: flex;
        gap: 10px;
    }

    .view-button {
        background-color: #83b4c5;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        padding: 8px 16px;
        font-size: 14px;
    }

    .view-button:hover {
        background-color: #6795a4;
    }

    #project-field {
        width: 100%;
        max-width: 970px;
        height: 150px;
        box-sizing: border-box;
        font-size: 15px;
    }

    .inline-button {
        background-color: #83b4c5;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        padding: 10px 20px;
        font-size: 16px;
        margin-right: 10px;
    }

    .button-container {
        padding: 10px;
        margin-left: 50px;
    }

    .top-info-grid {
        display: flex;
        align-items: stretch;
        margin-bottom: 40px;
    }

    .info-button-column {
        flex-shrink: 0;
        padding-right: 15px;
        margin-right: 15px;
        border-right: 1px solid #ccc;

        display: flex;
        flex-direction: column;
        align-items: flex-start;
    }

    .info-details-column {
        display: flex;
        flex-direction: column;
        flex-grow: 1;
    }

    .primary-info-line .inline-button {
        margin-right: 15px;
        flex-shrink: 0;
    }

    .object-title-block-main {
        margin-bottom: 10px;
    }

    .object-common-name {
        font-size: 1.4em;
        font-weight: bold;
        color: #333;
    }

    .secondary-info-line-main {
        display: flex;
        flex-wrap: nowrap;
        gap: 20px;
        align-items: center;
    }

    .secondary-info-line-main small {
        font-size: 12px;
        color: #666;
    }

    .secondary-info-line-main p {
        margin: 0;
        font-size: 16px;
    }

    .secondary-info-line-main span {
        font-weight: bold;
        font-size: 16px;
        color: #000;
    }

    .object-title-block {
        flex-grow: 1;
    }

    .object-id-name {
        font-size: 1.2em;
        font-weight: bold;
        color: #555;
        margin-left: 4px;
    }

    .inline-button:hover {
        background-color: #6795a4 !important;
    }

    .content-section {
        margin-top: 25px;
        padding: 20px;
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        margin-bottom: 25px;
    }

    .content-section h3 {
        margin-top: 0;
        color: #343a40;
        border-bottom: 1px solid #ced4da;
        padding-bottom: 10px;
        font-size: 1.2em;
        font-weight: 600;
    }

    .sessions-history-list {
        list-style-type: none;
        padding-left: 0;
        max-height: 250px;
        overflow-y: auto;
        border: 1px solid #ced4da;
        border-radius: 4px;
        background-color: #fff;
        margin-top: 10px;
    }

    .sessions-history-list li {
        padding: 7px 10px;
        border-bottom: 1px dotted #e0e0e0;
        font-size: 0.85em;
    }

    .sessions-history-list li:last-child {
        border-bottom: none;
    }

    .sessions-history-list li a {
        text-decoration: none;
        color: #0056b3;
    }

    .sessions-history-list li a:hover {
        text-decoration: underline;
    }

    .sessions-history-list li.current-session-item {
        background-color: #cfe2ff;
        border-left: 3px solid #0056b3;
        padding-left: 7px;
    }

    .sessions-history-list li.current-session-item a {
        font-weight: bold;
    }

    .selected-session-details {
        margin-top: 15px;
        padding: 15px;
        background-color: #ffffff;
        border: 1px solid #bac8d3;
        border-radius: 4px;
        max-width: 770px;
    }

    .selected-session-details h4 {
        margin-top: 0;
        color: #2c3e50;
        font-size: 1.05em;
        font-weight: 600;
    }

    .selected-session-details p, .selected-session-details div {
        margin-bottom: 6px;
        font-size: 0.9em;
        line-height: 1.5;
    }

    .selected-session-details strong {
        color: #1c2833;
    }

    .action-button-group {
        display: flex;
        align-items: center;

        margin-top: 10px;
        margin-bottom: 10px;
    }

    .action-button-group .inline-button {
        margin-right: 8px;

        margin-bottom: 5px;
        font-size: 13px;
        padding: 6px 12px;
        text-decoration: none;
        box-sizing: border-box;
        display: inline-block;
        vertical-align: middle;
        line-height: 1.2;
    }

    hr.detail-separator {
        border: 0;
        height: 1px;
        background: #e0e0e0;
        margin: 10px 0;
    }

    #opportunities-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
        font-size: 14px;
        margin-left: 20px;
    }

    #opportunities-table th, #opportunities-table td {
        border: 1px solid #ccc;
        padding: 8px 12px;
        text-align: left;
    }

    #opportunities-table th {
        background-color: #83b4c5;
        color: white;
        font-weight: normal;
    }

    #opportunities-table tr:nth-child(even) {
        background-color: #f2f2f2;
    }

    #opportunities-table tr:hover {
        background-color: #e1f0f5;
    }

    #opportunities-section {
        margin-top: 40px;
    }

    .opportunities-heading {
        font-size: 16px;
        font-weight: normal;
        color: #333;
        margin-bottom: 10px;
        margin-left: 20px;
    }

    #opportunities-table th,
    #opportunities-table td {
        text-align: center !important;
        vertical-align: middle !important;
    }

    .highlight {
        background-color: #d6ecff !important;
    }

    code {
        background-color: #f5f5f5;
        padding: 2px 4px;
        border-radius: 4px;
        font-family: monospace;
    }

    .preserve-newlines {
        white-space: pre-wrap;
        margin-top: 4px;
        padding-left: 10px;
        border-left: 2px solid #eee;
    }


    .session-history-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
        font-size: 0.85em;
    }

    .session-history-table th, .session-history-table td {
        border: 1px solid #dde;
        padding: 6px 8px;
        text-align: left;
        vertical-align: middle;
    }

    .session-history-table th {
        background-color: #e9ecef;
        font-weight: 600;
    }

    .session-history-table tr.clickable-session-row:hover {
        background-color: #e6f7ff;
        cursor: pointer;
    }

    .session-history-table tr.current-session-item {
        background-color: #cfe2ff !important;
        font-weight: bold;
    }

    .session-history-table td.col-date, .session-history-table th.col-date {
        width: 120px;
    }

    .session-history-table td.col-location, .session-history-table th.col-location {
        width: 150px;
    }

    .session-history-table td.col-setup, .session-history-table th.col-setup {
        width: auto;
    }

    .session-history-table td.col-integ, .session-history-table th.col-integ {
        width: 100px;
        text-align: center;
    }

    .session-history-table td.col-rating, .session-history-table th.col-rating {
        width: 100px;
        text-align: center;
    }

    .selected-session-details .form-data-value {
        padding: 8px 10px;
        background-color: #e9ecef;
        border: 1px solid #ced4da;
        border-radius: 4px;
        min-height: 25px;
        word-wrap: break-word;
        font-size: 1.1em;
        line-height: 1.5;
    }


    .selected-session-details div.form-data-value.preserve-newlines {
        min-height: 80px;
        background-color: #fff;
        border: 1px dashed #ced4da;

    }

    div.form-data-value.preserve-newlines {
        min-height: 80px;
        background-color: #fff;
        border: 1px dashed #ced4da;
    }

    .form-group label {
        display: block;
        margin-bottom: 3px;
        font-weight: normal;
        font-size: 1em;
        color: #495057;
        width: 320px;


    }

    .form-group {
        margin-bottom: 10px;
    }

    .form-section-title {
        font-size: 1.1em;
        font-weight: bold;
        color: #333;
        margin-top: 20px;
        margin-bottom: 10px;
        border-bottom: 1px solid #eee;
        padding-bottom: 5px;
    }

    .form-row {
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
    }

    .form-row .form-group {
        flex: 1;
        min-width: 200px;
    }


    .framing-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 15px;
    }

    .framing-table th, .framing-table td {
        border: 1px solid #eee;
        padding: 10px;
        text-align: left;
        font-size: 14px;
    }

    .framing-table th {
        background-color: #f9f9f9;
        font-weight: 600;
    }

    .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.6);
    }

    .framing-controls {
        margin-bottom: 15px;
        display: flex;
        gap: 20px;
        align-items: center;
        color: black;
    }

    .framing-controls select, .framing-controls button {
        font-size: 14px;
        padding: 5px;
    }


    #aladin-lite-div .aladin-location,
    #aladin-lite-div .aladin-mouse-position {
        display: none !important;
    }


    .modal-header-bar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 12px 56px 6px 16px;
        border-bottom: 1px solid #83b4c5;
    }

    .brand-strong {
        font-weight: 800;
        letter-spacing: 0.2px;
        font-size: 20px;
    }

    .brand-light {
        font-weight: 400;
        margin-left: 6px;
        color: #555;
        font-size: 20px;
    }

    .fov-chip {
        font-size: 13px;
        color: #444;
        background: #f3f5f7;
        border: 1px solid #e2e6ea;
        border-radius: 999px;
        padding: 4px 10px;
        white-space: nowrap;
        margin-right: 48px;
    }

    .modal .close {
        position: absolute;
        top: 10px;
        right: 12px;
        z-index: 3;
        line-height: 1;
        font-size: 22px;
        color: #999;
    }

    .modal .close:hover {
        color: #666;
    }

    #framing-modal {
        position: fixed;
        inset: 0;
        display: none;
        background: rgba(0, 0, 0, 0.6);
        z-index: 1000;
    }


    #framing-modal-content {
        position: relative;
        margin: 4vh auto 6vh auto;
        width: clamp(320px, 70vw, 1200px);
        height: clamp(400px, 78vh, 900px);
        background: #fff;
        border-radius: 10px;
        box-shadow: 0 12px 32px rgba(0, 0, 0, 0.25);
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }

    #framing-header,
    #framing-toolbar {
        padding: 10px 16px;
    }

    #framing-toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 10px 14px;
        align-items: center;
        border-top: 1px solid #e9eef2;
        border-bottom: 1px solid #e9eef2;
    }


    #framing-body {
        flex: 1 1 auto;
        min-height: 240px;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        padding: 10px 16px 14px 16px;
    }

    #aladin-lite-div {
        flex: 1 1 auto;
        min-height: 200px;
        border-radius: 6px;
        overflow: hidden;
    }

    .framing-readout {
        display: flex;
        flex-wrap: wrap;
        gap: 8px 12px;
        align-items: center;
        margin: 8px 0 10px;
    }

    @media (max-width: 1280px) {
        #framing-modal-content {
            width: 96vw;
            height: 92vh;
            margin: 2vh auto;
        }

        #framing-toolbar, #framing-body {
            padding-left: 12px;
            padding-right: 12px;
        }

        #framing-toolbar {
            gap: 8px 10px;
        }
    }

    @media (max-width: 900px) {
        .framing-readout {
            gap: 6px 10px;
        }

        .inline-label {
            white-space: nowrap;
            font-size: 0.95rem;
        }
    }

    .framing-controls {
        padding-left: 16px;
        padding-right: 16px;
    }

    #framing-modal-content.fullscreen {
        width: 98vw !important;
        height: 96vh !important;
        margin: 2vh auto !important;
    }

    .fullscreen-btn {
        float: right;
        border: none;
        background: transparent;
        font-size: 1.3rem;
        cursor: pointer;
        margin-right: 10px;
    }

    .fullscreen-btn:hover {
        color: #0077aa;
    }

    .close {
        font-size: 1.4rem;
        cursor: pointer;
        color: #666;
    }

    .close:hover {
        color: #d00;
    }

    .modal-controls {
        position: absolute;
        top: 8px;
        right: 12px;
        z-index: 2;
        display: flex;
        gap: 10px;
        align-items: center;
        pointer-events: auto;
    }

    .fullscreen-btn,
    .close-btn {
        width: 28px;
        height: 28px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        line-height: 1;
        border: 0;
        border-radius: 6px;
        background: transparent;
        color: #444;
        cursor: pointer;
    }

    .close-btn:hover {
        color: #d22;
    }

    #chart-container {
        position: relative;
        width: 100%;
        max-width: 1000px;
        margin: auto;
        height: 55vh;
    }

    #altitudeChartCanvas {
        display: block;
        margin-left: 0;
    }

    .chart-container,
    .canvas-wrapper,
    #chart-container,
    #chart-area {
        position: relative;

    }

    #altitudeChartCanvas {
        display: block;
        width: 100%;
        height: 100%;
    }

    .loading-overlay.hidden {
        opacity: 0;
        visibility: hidden;
    }

    #chart-wrapper {
        width: 80%;
        max-width: 1100px;
        margin-left: 0;
    }

    #chart-area {
        position: relative;
    }

    #altitudeChartCanvas {
        display: block;
        width: 100% !important;
        height: auto !important;
    }

    .loading-overlay {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(255, 255, 255, 0.6);
        backdrop-filter: blur(2px);
        font: 600 18px/1.2 system-ui, sans-serif;
        color: #334;
        z-index: 2;
        opacity: 1;
        visibility: visible;
        transition: opacity 200ms ease, visibility 200ms ease;
    }

</style>

{% endblock %}
</head>
<body>
{% block body %}

<div class="top-info-grid"> {# Renamed for clarity, this will be our main flex row for the two columns #}

    {# ---- Column 1: Back to Tracker Button ---- #}
    <div class="info-button-column">
        <button class="inline-button" onclick='window.top.location.href="{{ url_for("index") }}"'>Back to Tracker</button>
    </div>
    {# ---- END: Column 1 ---- #}

    {# ---- Column 2: Object Details and Secondary Info ---- #}
    <div class="info-details-column">
        {# Object Name/ID Display #}
        <div class="object-title-block-main">
            <span class="object-common-name">{{ alt_name | default(object_name, True) }}</span>
            <span class="object-id-name">({{ object_name }})</span>
        </div>

        {# Secondary Info Line: Location, Date, Moon, etc. #}
        <div class="secondary-info-line-main">
            <p><small>Location:</small> <span id="location-display">{{ header_location_name }}</span></p>
            <p><small>Date (Graph):</small> <span id="date-display">{{ header_date_display }}</span></p>
            <p><small>Moon (for date):</small> <span id="phase-display">{{ header_moon_phase }}%</span></p>
            <p><small>Astro Dusk:</small> <span id="dusk-display">{{ header_astro_dusk }}</span></p>
            <p><small>Astro Dawn:</small> <span id="dawn-display">{{ header_astro_dawn }}</span></p>
        </div>
    </div>
    {# ---- END: Column 2 ---- #}

</div>
<div id="chart-section">
    <div style="width: 80%; max-width: 1100px; margin-left: 0;">
        <div id="chart-area">
            <canvas id="altitudeChartCanvas"></canvas>
            <div id="chart-loading" class="loading-overlay">Loading chart...</div>
        </div>

        <div class="date-controls" style="margin-top: 20px; padding-left: 20px; box-sizing: border-box;">
            <label for="day-select">Day:</label>
            <input type="number" id="day-select" value="{{ selected_day }}" min="1" max="31" style="width:60px;"/>

            <label for="month-select">Month:</label>
            <select id="month-select">
                {% for m in range(1, 13) %}
                <option value="{{ m }}" {% if m== selected_month|int %}selected{% endif %}>{{ '%02d' % m }}</option>
                {% endfor %}
            </select>

            <label for="year-select">Year:</label>
            <input type="number" id="year-select" value="{{ selected_year }}" style="width:70px;"/>

            <button class="view-button" data-view="day" onclick="changeView('day')">Day View</button>
            <button class="view-button" data-view="month" onclick="changeView('month')">Month View</button>
            <button class="view-button" data-view="year" onclick="changeView('year')">Year View</button>
        </div>
    </div>
</div>

{# End of chart-section #}


<div class="content-section journal-section-for-object">
    <h3>Imaging Journal for {{ alt_name | default(object_name, True) }}</h3>
    <div class="action-button-group">
        {% if is_guest %}
        <a href="#" onclick="alert('Please log in to add a journal session.'); return false;" class="inline-button">Add
            New Session</a>
        {% else %}
        <a href="{{ url_for('journal_add_for_target', object_name=object_name) }}" class="inline-button">Add New
            Session</a>
        {% endif %}
    </div>

    {% if object_specific_sessions %}
    <h4>Session History:</h4>
    <div class="table-wrapper" style="max-height: 280px; overflow-y: auto; margin-bottom:15px;"> {# Make it scrollable
        #}
        <table class="session-history-table">
            <thead>
            <tr>
                <th class="col-date">Date</th>
                <th class="col-location">Location</th>
                <th class="col-setup">Telescope Setup</th>
                <th class="col-integ">Integ. Time</th>
                <th class="col-rating">Rating</th>
            </tr>
            </thead>
            <tbody>
            {% for session_item in object_specific_sessions %}
            <tr class="clickable-session-row {{ 'current-session-item' if session_item.session_id == current_session_id else '' }}"
                onclick='window.location.href="{{ url_for("graph_dashboard", object_name=object_name, day=selected_day, month=selected_month, year=selected_year, session_id=session_item.session_id) }}"'>
                <td class="col-date">{{ session_item.session_date |date_eu| default("N/A") }}</td>
                <td class="col-location">{{ session_item.location_name | default("N/A") }}</td>
                <td class="col-setup">{{ session_item.telescope_setup_notes | default("N/A") | truncate(50, True) }}
                </td>
                <td class="col-integ">
                    {% set integ_min = session_item.get('calculated_integration_time_minutes') %}
                    {{ integ_min | round(0) if integ_min is number and integ_min != 'N/A' else 'N/A' }} min
                </td>
                <td class="col-rating">{{ session_item.session_rating_subjective | default('N/A') }}{% if
                    session_item.session_rating_subjective and session_item.session_rating_subjective != 'N/A' and
                    session_item.session_rating_subjective is not none %} ★{% endif %}
                </td>
            </tr>
            {% endfor %}
            </tbody>
        </table>
    </div>

    {% if selected_session_data %}
    <div class="selected-session-details"> {# Keep this outer wrapper #}
        <h4>Details for Session: {{ selected_session_data.session_date | date_eu }}
            {% if selected_session_data.session_id %}<small>(ID: {{ selected_session_data.session_id[:8] }}...)</small>{%
            endif %}
        </h4>
        <div class="action-button-group">
            {% if is_guest %}
            <a href="#" onclick="alert('Please log in to edit journal sessions.'); return false;" class="inline-button"
               style="background-color:#ffc107; color:black;">Edit This Session</a>
            {% else %}
            <a href="{{ url_for('journal_edit', session_id=selected_session_data.session_id) }}" class="inline-button"
               style="background-color:#ffc107; color:black;">Edit This Session</a>
            {% endif %}
            {% if is_guest %}
            <button type="button" class="inline-button" style="background-color:#dc3545;"
                    onclick="alert('Please log in to delete journal sessions.');">Delete This Session
            </button>
            {% else %}
            <form action="{{ url_for('journal_delete', session_id=selected_session_data.session_id) }}" method="POST"
                  style="display:inline;"
                  onsubmit="return confirm('Are you sure you want to delete this journal entry? This action cannot be undone.');">
                <button type="submit" class="inline-button" style="background-color:#dc3545;">Delete This Session
                </button>
            </form>
            {% endif %}
        </div>

        {# --- Mimicking journal_form.html structure --- #}
        <div class="form-section-title" style="margin-top:20px;">Core Info</div>
        <div class="form-row">
            <div class="form-group">
                <label>Session Date:</label>
                <p class="form-data-value">{{ selected_session_data.session_date | date_eu | default('N/A') }}</p>
            </div>
            <div class="form-group">
                <label>Target Object:</label>
                <p class="form-data-value">{{ selected_session_data.target_object_id | default('N/A') }}</p>
            </div>
        </div>
        <div class="form-group">
            <label>Location:</label>
            <p class="form-data-value">{{ selected_session_data.location_name | default('N/A') }}</p>
        </div>

        <div class="form-section-title">Sky Conditions (Observed)</div>
        <div class="form-row">
            <div class="form-group">
                <label>Seeing (FWHM, arcsec):</label>
                <p class="form-data-value">{{ selected_session_data.seeing_observed_fwhm | default('N/A') }}{% if
                    selected_session_data.seeing_observed_fwhm and selected_session_data.seeing_observed_fwhm not in
                    ['N/A', None] %}"{% endif %}</p>
            </div>
            <div class="form-group">
                <label>Transparency Scale:</label>
                <p class="form-data-value">{{ selected_session_data.transparency_observed_scale | default('N/A') }}</p>
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label>SQM Reading:</label>
                <p class="form-data-value">{{ selected_session_data.sky_sqm_observed | default('N/A') }}</p>
            </div>
            <div class="form-group"></div>
        </div>
        <div class="form-group">
            <label>Weather Notes:</label>
            <div class="form-data-value preserve-newlines">{{ selected_session_data.weather_notes | default('N/A') }}
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label>Moon Illumination (Session):</label>
                <p class="form-data-value">{{ selected_session_data.moon_illumination_session | default('N/A') }}{% if
                    selected_session_data.moon_illumination_session not in ['N/A', None] %}%{% endif %}</p>
            </div>
            <div class="form-group">
                <label>Moon Angular Separation (Session):</label>
                <p class="form-data-value">{{ selected_session_data.moon_angular_separation_session | default('N/A')
                    }}{% if selected_session_data.moon_angular_separation_session not in ['N/A', None] %}°{% endif
                    %}</p>
            </div>
        </div>
        <div class="form-section-title">Equipment & Guiding</div>
        <div class="form-group">
            <label>Telescope Setup Notes:</label>
            <p class="form-data-value">{{ selected_session_data.telescope_setup_notes | default('N/A') }}</p>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label>Filter Used:</label>
                <p class="form-data-value">{{ selected_session_data.filter_used_session | default('N/A') }}</p>
            </div>
            <div class="form-group">
                <label>Guiding RMS (avg, arcsec):</label>
                <p class="form-data-value">{{ selected_session_data.guiding_rms_avg_arcsec | default('N/A') }}{% if
                    selected_session_data.guiding_rms_avg_arcsec and selected_session_data.guiding_rms_avg_arcsec not in
                    ['N/A', None] %}"{% endif %}</p>
            </div>
        </div>
        <div class="form-group">
            <label>Guiding Equipment (Scope, Camera, Software):</label>
            <p class="form-data-value">{{ selected_session_data.guiding_equipment | default('N/A') }}</p>
        </div>
        <div class="form-group">
            <label>Dither Settings:</label>
            <p class="form-data-value">{{ selected_session_data.dither_details | default('N/A') }}</p>
        </div>
        <div class="form-group">
            <label>Acquisition Software:</label>
            <p class="form-data-value">{{ selected_session_data.acquisition_software | default('N/A') }}</p>
        </div>
        <div class="form-section-title">Acquisition Details</div>
        <div class="form-row">
            <div class="form-group">
                <label>Sub Exposure (seconds):</label>
                <p class="form-data-value">{{ selected_session_data.exposure_time_per_sub_sec | default('N/A') }}s</p>
            </div>
            <div class="form-group">
                <label>Number of Light Subs:</label>
                <p class="form-data-value">{{ selected_session_data.number_of_subs_light | default('N/A') }}</p>
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label>Gain:</label>
                <p class="form-data-value">{{ selected_session_data.gain_setting | default('N/A') }}</p>
            </div>
            <div class="form-group">
                <label>Offset:</label>
                <p class="form-data-value">{{ selected_session_data.offset_setting | default('N/A') }}</p>
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label>Binning:</label>
                <p class="form-data-value">{{ selected_session_data.binning_session | default('N/A') }}</p>
            </div>
            <div class="form-group">
                <label>Total Integration:</label>
                <p class="form-data-value">
                    {% set integ_min_detail = selected_session_data.get('calculated_integration_time_minutes') %}
                    {{ integ_min_detail | round(0) if integ_min_detail is number and integ_min_detail != 'N/A' else
                    'N/A' }} min
                </p>
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label>Camera Temp Setpoint (°C):</label>
                <p class="form-data-value">{{ selected_session_data.camera_temp_setpoint_c | default('N/A') }}°C</p>
            </div>
            <div class="form-group">
                <label>Camera Temp Actual Avg (°C):</label>
                <p class="form-data-value">{{ selected_session_data.camera_temp_actual_avg_c | default('N/A') }}°C</p>
            </div>
        </div>

        <div class="form-section-title">Monochrome Filter Exposures</div>

        {% set filters_display = [
        ('L', 'Luminance'), ('R', 'Red'), ('G', 'Green'), ('B', 'Blue'),
        ('Ha', 'H-alpha'), ('OIII', 'OIII'), ('SII', 'SII')
        ] %}

        {% for filt_key, filt_name in filters_display %}
        {% set subs_val = selected_session_data.get('filter_' + filt_key + '_subs') %}
        {% set exp_val = selected_session_data.get('filter_' + filt_key + '_exposure_sec') %}

        {# Only display the row if there's data for either subs or exposure for that filter #}
        {% if (subs_val is not none and subs_val|string|trim != '') or
        (exp_val is not none and exp_val|string|trim != '') %}
        {# The rest of the div.form-row and its content remains the same as before #}
        <div class="form-row" style="margin-bottom: 8px;">
            <div class="form-group" style="flex: 0 0 200px; display: flex; align-items: center;">
                <label style="margin-bottom: 0;">{{ filt_name }} ({{ filt_key }}) Filter:</label>
            </div>
            <div class="form-group">
                <label># Subs:</label>
                <p class="form-data-value">{{ subs_val | default('N/A') }}</p>
            </div>
            <div class="form-group">
                <label>Exp (sec/sub):</label>
                <p class="form-data-value">{{ exp_val | default('N/A') }}</p>
            </div>
        </div>
        {% endif %}
        {% endfor %}

        <div class="form-section-title">Calibration Strategy</div>
        <div class="form-group">
            <label>Darks:</label>
            <p class="form-data-value">{{ selected_session_data.darks_strategy | default('N/A') }}</p>
        </div>
        <div class="form-group">
            <label>Flats:</label>
            <p class="form-data-value">{{ selected_session_data.flats_strategy | default('N/A') }}</p>
        </div>
        <div class="form-group">
            <label>Bias / Dark Flats:</label>
            <p class="form-data-value">{{ selected_session_data.bias_darkflats_strategy | default('N/A') }}</p>
        </div>

        <div class="form-section-title">Outcome & Reflections</div>
        <div class="form-row">
            <div class="form-group">
                <label>Session Rating (1-5 ★):</label>
                <p class="form-data-value">{{ selected_session_data.session_rating_subjective | default('N/A') }}{% if
                    selected_session_data.session_rating_subjective and selected_session_data.session_rating_subjective
                    not in ['N/A', None] %} ★{% endif %}</p>
            </div>

        </div>

        <div class="form-group">
            <label>General Notes, Problems, Learnings:</label>
            <div class="form-data-value preserve-newlines">{{ selected_session_data.general_notes_problems_learnings |
                default('N/A') }}
            </div>
        </div>
    </div>
    {% elif object_specific_sessions %}
    <p style="margin-top:15px; color:#555;"><em>Select a session from the history above to view its full details.</em>
    </p>
    {% endif %}
    {% else %}
    <p style="margin-top:15px; color:#777;">No journal entries found for {{ alt_name | default(object_name, True)
        }}.</p>
    {% endif %}
</div>
{# End of Journal Section #}

{% if available_rigs and object_main_details.Size and object_main_details.Size != "N/A" %}
<div class="content-section">
    <h3>Framing With Your Rigs</h3>
    <p style="font-size:13px; color: #666; margin-top: -8px;"><em>Assessment is based on the object's largest dimension
        and may not reflect framing of specific features.</em></p>
    <table class="framing-table">
        <thead>
        <tr>
            <th>Rig Name</th>
            <th>Rig FOV</th>
            <th>Object Size</th>
            <th>Fit Assessment</th>
        </tr>
        </thead>
        <tbody>
        {% set object_size = object_main_details.Size | float %}
        {% for rig in available_rigs %}
        {% if rig.fov_w_arcmin and rig.fov_h_arcmin %}
        {% set fov_max = [rig.fov_w_arcmin, rig.fov_h_arcmin] | max %}
        {% set fov_min = [rig.fov_w_arcmin, rig.fov_h_arcmin] | min %}

        {# --- NEW, MORE DETAILED LOGIC --- #}
        {% if object_size > fov_max %}
        {% set fit_text = "Mosaic Required" %}
        {% set fit_color = "#e74c3c" %} {# Red #}

        {% elif object_size > fov_min %}
        {% set fit_text = "Fits with Rotation" %}
        {% set fit_color = "#f39c12" %} {# Orange #}

        {% else %}
        {# The object fits easily, so now we assess how well #}
        {% set fit_ratio = (object_size / fov_min) * 100 %}

        {% if fit_ratio < 5 %}
        {# NEW CATEGORY for very small objects #}
        {% set fit_text = "Small Target" %}
        {% set fit_color = "#9b59b6" %} {# Purple #}
        {% elif fit_ratio < 20 %}
        {% set fit_text = "Wide Field" %}
        {% set fit_color = "#3498db" %} {# Blue #}
        {% else %}
        {% set fit_text = "Good Fit" %}
        {% set fit_color = "#2ecc71" %} {# Green #}
        {% endif %}
        {% endif %}

        <tr>
            <td><strong>{{ rig.rig_name }}</strong></td>
            <td>{{ rig.fov_w_arcmin | round(1) }}' x {{ rig.fov_h_arcmin | round(1) }}'</td>
            <td>{{ object_size }}'</td>
            <td style="color: {{ fit_color }}; font-weight: bold;">{{ fit_text }}</td>
        </tr>
        {% endif %}
        {% endfor %}
        </tbody>
    </table>
</div>
{% endif %}

{# This was your 'button-container' div previously, now wrapped and styled #}
<div class="content-section project-notes-section">
    <h3>Project Notes</h3>
    <textarea id="project-field" name="project_notes_from_config"
              title="General notes for this object from your main configuration. Editable on the Configuration page.">{{ project_notes_from_config }}</textarea>
    <div id="project-quick-link" style="margin:6px 0 12px; font-size:14px; color:#333;"></div>
    <div class="button-group"> {# Your existing group of buttons for this object #}
        <button class="inline-button" onclick="saveProject()">Save Project Notes</button>
        {# If you make project-field editable #}
        <button class="inline-button" onclick="openFramingAssistant()">Show Framing</button>
        <button class="inline-button" onclick="toggleSimbad()">Toggle SIMBAD Info</button>
        <button class="inline-button" onclick="loadImagingOpportunities()">Find Imaging Opportunities</button>
        <button id="open-in-stellarium" class="inline-button" onclick="openInStellarium()">Open in Stellarium</button>
    </div>
    <div id="stellarium-status" style="margin-top: 10px; color: #666;"></div>
</div>
{# End of Project Notes Section #}


<div id="simbadContainer" style="display:none; margin-top:20px;">
    <iframe id="simbadIframe" style="width:100%; height:1200px; border:1px solid #ddd;"></iframe>
</div>

<div id="opportunities-section" style="display: none; max-width: 800px; margin-top: 30px;">
    <div class="opportunities-heading">Imaging Opportunities:<br><small>Note: The star rating does not differentiate
        whether the moon is above or below the horizon.</small></div>
    <table id="opportunities-table" class="opportunity-table center-text">
        <thead>
        <tr>
            <th>Date</th>
            <th>From</th>
            <th>To</th>
            <th>Obs Duration (min)</th>
            <th>Max Alt (°)</th>
            <th>Moon Illum (%)</th>
            <th>Ang Sep (°)</th>
            <th>Rating</th>
            <th>Add to Cal</th>
        </tr>
        </tr>
        </thead>
        <tbody id="opportunities-body">
        {# Populated by loadImagingOpportunities() #}
        </tbody>
    </table>
</div>
<div id="framing-modal" class="modal">
    <div id="framing-modal-content">
        <div class="modal-controls">
            <button type="button" class="fullscreen-btn" aria-label="Toggle fullscreen" title="Fullscreen"
                    onclick="toggleFramingFullscreen(this)">⤢
            </button>
            <button type="button" class="close-btn" aria-label="Close" title="Close" onclick="closeFramingAssistant()">
                ×
            </button>
        </div>

        <!-- Modal header (inside the white panel) -->
        <div class="modal-header-bar">
            <div class="brand">
                <span class="brand-strong">Nova</span>
                <span class="brand-light">DSO Tracker</span>
            </div>
            <span id="fov-vs-object" class="fov-chip"></span>
        </div>

        <!-- QoL utility bar -->
        <div class="framing-controls" style="align-items:center; gap:10px; padding-top:4px;">
            <label style="display:flex;align-items:center;gap:6px;">
                <input type="checkbox" id="lock-to-object" onchange="applyLockToObject(this.checked)">
                Lock FOV
            </label>

            <button class="inline-button" style="padding:6px 10px;font-size:13px;" onclick="flipFraming90()">Flip 90°
            </button>
            <button class="inline-button" style="padding:6px 10px;font-size:13px;" onclick="copyFramingUrl()">Copy
                framing URL
            </button>
            <button id="insert-into-project" type="button" class="inline-button" style="padding:6px 10px;font-size:13px;"
                    onclick="insertFramingIntoProject()">Insert into Project</button>
            </button>
        </div>
        <div class="framing-controls">
            <div>
                <label for="framing-rig-select">Select Rig:</label>
                <select id="framing-rig-select" onchange="updateFramingChart(true); updateFovVsObjectLabel();">
                    {% if available_rigs %}
                    {% for rig in available_rigs %}
                    <option value="{{ rig.rig_id }}"
                            data-fovw="{{ rig.fov_w_arcmin }}"
                            data-fovh="{{ rig.fov_h_arcmin }}">
                        {{ rig.rig_name }}
                    </option>
                    {% endfor %}
                    {% else %}
                    <option value="">No rigs configured</option>
                    {% endif %}
                </select>
            </div>

            <div>
                <label for="framing-rotation">Rotation:</label>
                <input type="range" id="framing-rotation" min="0" max="360" value="0" step="1"
                       oninput="window.updateFramingChart(false); if (lockToObject) { const sel=document.getElementById('framing-rig-select'); const opt=sel.options[sel.selectedIndex]; updateScreenFovOverlay(opt.dataset.fovw,opt.dataset.fovh,this.value); }"
                       onchange="window.updateFramingChart(false); if (lockToObject) { const sel=document.getElementById('framing-rig-select'); const opt=sel.options[sel.selectedIndex]; updateScreenFovOverlay(opt.dataset.fovw,opt.dataset.fovh,this.value); }"
                <span id="rotation-value">0°</span>
            </div>

            <div>
                <label for="survey-select">Survey:</label>
                <select id="survey-select" onchange="setSurvey(this.value)">
                    <option value="P/DSS2/color">DSS2 (color)</option>
                    <option value="P/allWISE/color">AllWISE (color)</option>
                    <option value="P/2MASS/color">2MASS (color)</option>
                    <option value="P/GALEXGR6/AIS/color">GALEX (color)</option>
                    <option value="P/PanSTARRS/DR1/color-z-zg-g">Pan-STARRS (color)</option>
                    <option value="CDS/P/SHASSA">SHASSA Hα</option>
                    <option value="P/SDSS9/color">SDSS9 (color)</option>
                </select>
                <span style="margin-left:18px;">Blend with:</span>
                    <select id="blend-survey-select" style="margin-left:6px;">
                        <option value="P/DSS2/color" selected>DSS2 (color)</option>
                        <option value="P/DSS2/red">DSS2 (red)</option>
                        <option value="P/DSS2/blue">DSS2 (blue)</option>
                        <option value="P/2MASS/color">2MASS (color)</option>
                        <option value="P/allWISE/color">WISE (color)</option>
                        <option value="P/SDSS9/color">SDSS (color)</option>
                        <option value="P/GALEXGR6/AIS/color">GALEX (color)</option>
                    </select>
                    <input id="blend-opacity" type="range" min="0" max="1" step="0.01" value="0"
                           title="Blend opacity" style="width:130px; vertical-align:middle; margin-left:8px;">
            </div>
        </div>

        <!-- Image tuning + RA/Dec utility bar -->
        <div class="framing-controls" style="flex-wrap: wrap;">
            <div>
                <label>Brightness</label>
                <input type="range" id="img-bright" min="-1" max="1" step="0.01" value="0"
                       oninput="updateImageAdjustments()">
            </div>
            <div>
                <label>Contrast</label>
                <input type="range" id="img-contrast" min="-1" max="1" step="0.01" value="0"
                       oninput="updateImageAdjustments()">
            </div>
            <div>
                <label>Gamma</label>
                <input type="range" id="img-gamma" min="0.1" max="10" step="0.1" value="1"
                       oninput="updateImageAdjustments()">
            </div>
            <div>
                <label>Saturation</label>
                <input type="range" id="img-sat" min="-1" max="1" step="0.01" value="0"
                       oninput="updateImageAdjustments()">
            </div>

            <div style="display:flex; align-items:center; gap:6px;">
                <label>RA</label>
                <input id="ra-readout" type="text" style="width:160px;" readonly>
                <label>Dec</label>
                <input id="dec-readout" type="text" style="width:160px;" readonly>
                <button class="inline-button" style="padding:6px 10px; font-size:13px;" onclick="copyRaDec()">Copy
                </button>
                <!--        <button class="inline-button" style="padding:6px 10px; font-size:13px;" onclick="useReadoutAsFovCenter()">Use current RA/Dec</button>-->
            </div>

            <div style="display:flex; align-items:center; gap:6px;">
                <span style="font-size:12px;color:#555;">Tip: Click on the sky to move the FOV center.</span>
                <button class="inline-button" style="padding:6px 10px; font-size:13px;"
                        onclick="resetFovCenterToObject()">Recenter to object
                </button>
                <div style="display:flex; align-items:center; gap:4px;">
                    <button class="inline-button" style="padding:4px 8px;" title="Nudge Up" onclick="nudgeFov(0, +1)">
                        ↑
                    </button>
                    <div>
                        <button class="inline-button" style="padding:4px 8px;" title="Nudge Left"
                                onclick="nudgeFov(-1, 0)">←
                        </button>
                        <button class="inline-button" style="padding:4px 8px;" title="Nudge Right"
                                onclick="nudgeFov(+1, 0)">→
                        </button>
                    </div>
                    <button class="inline-button" style="padding:4px 8px;" title="Nudge Down" onclick="nudgeFov(0, -1)">
                        ↓
                    </button>
                    <span style="font-size:12px;color:#555;">(1′ steps)</span>
                </div>
            </div>
        </div>
        <div id="aladin-lite-div"></div>
    </div>
</div>

<script src="{{ url_for('static', filename='js/chart/chart.umd.min.js') }}"></script>
<script src="{{ url_for('static', filename='js/chart/luxon.min.js') }}"></script>
<script src="{{ url_for('static', filename='js/chart/chartjs-adapter-luxon.umd.min.js') }}"></script>
<script src="{{ url_for('static', filename='js/chart/chartjs-plugin-annotation.min.js') }}"></script>

<script>

    const plotTz = "{{ graph_tz_name_param | default('UTC', true) }}";
    Chart.defaults.adapters = Chart.defaults.adapters || {};
    Chart.defaults.adapters.date = {
        ...(Chart.defaults.adapters.date || {}),
        zone: plotTz
    };
    console.log('Adapter:', Chart._adapters?._date?.id, 'Zone:', Chart.defaults.adapters.date.zone);

    const OBJECT_SIZE_ARCMIN = null;
    // --- Aladin Lite Variables ---
    let aladin = null;
    let fovLayer = null;
    // --- NEW CLIENT-SIDE CHARTING LOGIC ---
    let altitudeChart = null; // Global variable to hold the chart instance

    // Function to parse a HH:MM time string and combine it with a date object
    function getDateTimeMs(baseDateISO, timeStr) {
        if (!timeStr || !timeStr.includes(':')) return null;
        const [hour, minute] = timeStr.split(':').map(Number);
        const base = luxon.DateTime.fromISO(baseDateISO, {zone: plotTz}).startOf('day');
        return base.set({hour, minute, second: 0, millisecond: 0}).toMillis();
    }

    // The main function to fetch data and render the chart

    async function renderClientSideChart() {
        const chartLoadingDiv = document.getElementById('chart-loading');
        chartLoadingDiv?.classList.remove('hidden');

        // Inputs from the page
        const objectName = "{{ object_name }}";
        const day = document.getElementById('day-select').value;
        const month = document.getElementById('month-select').value;
        const year = document.getElementById('year-select').value;

        const plotLat = "{{ graph_lat_param | default('', True) }}";
        const plotLon = "{{ graph_lon_param | default('', True) }}";
        const plotTz = "{{ graph_tz_name_param | default('', True) }}";

        const apiUrl =
            `/api/get_plot_data/${encodeURIComponent(objectName)}?day=${day}&month=${month}&year=${year}` +
            `&plot_lat=${plotLat}&plot_lon=${plotLon}&plot_tz=${encodeURIComponent(plotTz)}`;

        try {
            // --- fetch data
            const resp = await fetch(apiUrl);
            if (!resp.ok) throw new Error(`Failed to fetch chart data: ${resp.status} ${resp.statusText}`);
            const data = await resp.json();

            // --- build times + annotations
            // Robust “to milliseconds” parser for mixed inputs
            function toMs(val) {
                // Numeric? treat < 1e12 as seconds; otherwise milliseconds
                if (typeof val === 'number') return (val < 1e12 ? val * 1000 : val);

                if (typeof val === 'string') {
                    // Does the string already carry a timezone/offset? (…Z or ±HH:MM)
                    const hasOffset = /[Zz]|[+\-]\d{2}:?\d{2}$/.test(val);

                    if (hasOffset) {
                        // Respect the embedded offset, then show in plotTz
                        return luxon.DateTime.fromISO(val).setZone(plotTz).toMillis();
                    } else {
                        // “Naive” wall time → interpret directly in plotTz
                        return luxon.DateTime.fromISO(val, {zone: plotTz}).toMillis();
                    }
                }
                return null;
            }

            const labels = data.times.map(toMs);
            const annotations = {};

            const baseDate = new Date(data.date);
            const nextDate = new Date(baseDate);
            nextDate.setDate(baseDate.getDate() + 1);

            const baseDt = luxon.DateTime.fromISO(data.date, {zone: plotTz});
            const nextDt = baseDt.plus({days: 1});

            // Helper to parse HH:MM and combine with a given date object
            function wallTimeMs(baseDateTime, timeStr) {
                if (!timeStr || !timeStr.includes(':')) return null;
                const [h, m] = timeStr.split(':').map(Number);
                return baseDateTime.set({hour: h, minute: m, second: 0, millisecond: 0}).toMillis();
            }

            // Get the sunset time for the base date as a reference point.
            const sunsetTimeCurrent = wallTimeMs(baseDt, data.sun_events.current.sunset);

            // Determine the correct date for dusk.
            let duskTime;
            const duskTimeCurrent = wallTimeMs(baseDt, data.sun_events.current.astronomical_dusk);
            if (duskTimeCurrent && sunsetTimeCurrent && duskTimeCurrent < sunsetTimeCurrent) {
                // If dusk time is before sunset time, it belongs to the next calendar day.
                duskTime = wallTimeMs(nextDt, data.sun_events.current.astronomical_dusk);
            } else {
                duskTime = duskTimeCurrent;
            }

            // Dawn and sunrise always belong to the next calendar day.
            const dawnTime = wallTimeMs(nextDt, data.sun_events.next.astronomical_dawn);
            const sunriseTime = wallTimeMs(nextDt, data.sun_events.next.sunrise);
            const sunsetTime = sunsetTimeCurrent; // Assign for annotation

            // Use Luxon to compute midnight at the plotting location’s timezone, then work in ms
            const firstMs = labels[0];
            const lastMs = labels[labels.length - 1];
            const originalWindowMs = lastMs - firstMs;

            const midnightMs = luxon.DateTime
                .fromISO(data.date, {zone: plotTz})
                .plus({days: 1})       // midnight that splits the night (00:00 of "next" date)
                .startOf('day')
                .toMillis();

            const currentCenterMs = (firstMs + lastMs) / 2;
            const delta = midnightMs - currentCenterMs;

            const xMinCentered = firstMs + delta;
            const xMaxCentered = xMinCentered + originalWindowMs;

            if (sunsetTime) {
                annotations.sunsetLine = {
                    type: 'line',
                    xMin: sunsetTime, xMax: sunsetTime,
                    borderColor: 'black', borderWidth: 1,
                    label: {
                        display: true,
                        content: 'Sunset',
                        position: 'start',
                        rotation: 90,
                        font: {size: 10, weight: '400'},
                        color: '#222',
                        backgroundColor: 'rgba(255,255,255,0.92)',
                        borderColor: 'rgba(0,0,0,0.15)',
                        borderWidth: 1
                    }
                };
            }
            if (duskTime) {
                annotations.duskLine = {
                    type: 'line',
                    xMin: duskTime, xMax: duskTime,
                    borderColor: 'black', borderWidth: 1,
                    label: {
                        display: true,
                        content: 'Astronomical dusk',
                        position: 'start',
                        rotation: 90,
                        font: {size: 10, weight: '400'},
                        color: '#222',
                        backgroundColor: 'rgba(255,255,255,0.92)',
                        borderColor: 'rgba(0,0,0,0.15)',
                        borderWidth: 1
                    }
                };
            }
            if (dawnTime) {
                annotations.dawnLine = {
                    type: 'line',
                    xMin: dawnTime, xMax: dawnTime,
                    borderColor: 'black', borderWidth: 1,
                    label: {
                        display: true,
                        content: 'Astronomical dawn',
                        position: 'start',
                        rotation: 90,
                        font: {size: 10, weight: '400'},
                        color: '#222',
                        backgroundColor: 'rgba(255,255,255,0.92)',
                        borderColor: 'rgba(0,0,0,0.15)',
                        borderWidth: 1
                    }
                };
            }
            if (sunriseTime) {
                annotations.sunriseLine = {
                    type: 'line',
                    xMin: sunriseTime, xMax: sunriseTime,
                    borderColor: 'black', borderWidth: 1,
                    label: {
                        display: true,
                        content: 'Sunrise',
                        position: 'start',
                        rotation: 90,
                        font: {size: 10, weight: '400'},
                        color: '#222',
                        backgroundColor: 'rgba(255,255,255,0.92)',
                        borderColor: 'rgba(0,0,0,0.15)',
                        borderWidth: 1
                    }
                };
            }

            if (data.transit_time && data.transit_time !== "N/A") {
                // We already have baseDt/nextDt in plotTz, and duskTime/dawnTime as epoch ms
                // Example: baseDt = luxon.DateTime.fromISO(data.date, { zone: plotTz });
                const parts = (data.transit_time || '').split(':');
                const th = Number(parts[0] || 0);
                const tm = Number(parts[1] || 0);

                // Two candidates: same wall time on the base day, and on the next day
                const t0 = baseDt.set({hour: th, minute: tm, second: 0, millisecond: 0}).toMillis();     // evening candidate
                const t1 = baseDt.plus({days: 1}).set({hour: th, minute: tm, second: 0, millisecond: 0}).toMillis(); // after-midnight candidate

                // Night window [astronomical dusk .. astronomical dawn]
                const nightStart = duskTime;   // ms (same night, typically before midnight)
                const nightEnd = dawnTime;   // ms (next morning, after midnight)

                // Choose the candidate that lands inside the night window; if neither, pick the closer to midnight
                const inWindow = (t) => t >= nightStart && t <= nightEnd;
                const transitMs = inWindow(t0)
                    ? t0
                    : inWindow(t1)
                        ? t1
                        : (Math.abs(t0 - midnightMs) < Math.abs(t1 - midnightMs) ? t0 : t1);

                annotations.transitLine = {
                    type: 'line',
                    xMin: transitMs, xMax: transitMs,
                    borderColor: 'crimson', borderWidth: 2, borderDash: [6, 6],
                    clip: false,
                    label: {
                        display: true,
                        content: data.transit_time,    // e.g., "23:03"
                        position: 'start',
                        rotation: 90,
                        font: {size: 10, weight: 'bold'},
                        color: 'crimson',
                        backgroundColor: 'rgba(255,255,255,0.7)'
                    }
                };
            }

            // night-shade background as a plugin (so we don’t touch options.beforeDraw)
            const nightShade = {
                id: 'nightShade',
                beforeDraw(chart) {
                    const {ctx, chartArea, scales} = chart;
                    if (!chartArea) return; // Exit if chart area isn't ready

                    // Get the pixel coordinates for the start and end of the chart's x-axis
                    const left = scales.x.getPixelForValue(scales.x.min);
                    const right = scales.x.getPixelForValue(scales.x.max);

                    // --- This section uses the correct dusk and dawn times ---
                    const duskPx = duskTime ? scales.x.getPixelForValue(duskTime) : right;
                    const dawnPx = dawnTime ? scales.x.getPixelForValue(dawnTime) : left;

                    ctx.save();
                    ctx.fillStyle = 'rgba(211, 211, 211, 1)'; // The light gray for "daytime"

                    // If dusk is after dawn (i.e., the entire night is within the 24hr window)
                    if (duskPx < dawnPx) {
                        // Shade from the start of the chart to dusk
                        if (duskPx > left) {
                            ctx.fillRect(left, chartArea.top, duskPx - left, chartArea.height);
                        }
                        // Shade from dawn to the end of the chart
                        if (dawnPx < right) {
                            ctx.fillRect(dawnPx, chartArea.top, right - dawnPx, chartArea.height);
                        }
                    } else {
                        ctx.fillRect(left, chartArea.top, right - left, chartArea.height);
                    }
                    ctx.restore();
                }
            };

            // create / replace chart
            const ctx = document.getElementById('altitudeChartCanvas').getContext('2d');
            if (window.altitudeChart) window.altitudeChart.destroy();

            window.altitudeChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        {
                            label: '{{ object_name }} Altitude',
                            data: data.object_alt,
                            borderColor: '#36A2EB',
                            yAxisID: 'yAltitude',
                            borderWidth: 4,
                            pointRadius: 0,
                            tension: 0.1
                        },
                        {
                            label: 'Moon Altitude',
                            data: data.moon_alt,
                            borderColor: '#FFC107',
                            yAxisID: 'yAltitude',
                            borderWidth: 4,
                            pointRadius: 0,
                            tension: 0.1
                        },
                        {
                            label: 'Horizon',
                            data: Array(labels.length).fill(0),
                            borderColor: 'black',
                            yAxisID: 'yAltitude',
                            borderWidth: 2,
                            pointRadius: 0
                        },
                        {
                            label: '{{ object_name }} Azimuth',
                            data: data.object_az,
                            borderColor: '#36A2EB',
                            yAxisID: 'yAzimuth',
                            borderDash: [5, 5],
                            borderWidth: 3.5,
                            pointRadius: 0,
                            tension: 0.1
                        },
                        {
                            label: 'Moon Azimuth',
                            data: data.moon_az,
                            borderColor: '#FFC107',
                            yAxisID: 'yAzimuth',
                            borderDash: [5, 5],
                            borderWidth: 3.5,
                            pointRadius: 0,
                            tension: 0.1
                        }
                    ]
                },
                plugins: [nightShade],
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 2,
                    adapters: {date: {zone: plotTz}},
                    plugins: {
                        annotation: {annotations},
                        legend: {position: 'top'},
                        title: {
                            display: false,
                            text: `Altitude and Azimuth for {{ alt_name }} on ${data.date}`,
                            align: 'start',
                            font: {size: 16}
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            adapters: {
                                date: {
                                    zone: plotTz
                                }
                            },
                            parsing: false,                           // we pass epoch ms already
                            time: {unit: 'hour', displayFormats: {hour: 'HH:mm'}},

                            // keep midnight centered using your computed window
                            min: xMinCentered,
                            max: xMaxCentered,
                            bounds: 'ticks',

                            // let the adapter format in the plot timezone (no custom callback here)
                            ticks: {source: 'auto'},

                            grid: {color: 'rgba(128,128,128,0.5)', borderDash: [2, 2]},
                            title: {display: true, text: `Time (Local - {{ header_location_name }})`}
                        },

                        yAltitude: {
                            position: 'left',
                            min: -90, max: 90,
                            title: {display: true, text: 'Altitude (°)'},
                            grid: {color: 'rgba(128,128,128,0.5)', borderDash: [2, 2]}
                        },

                        yAzimuth: {
                            position: 'right',
                            min: 0, max: 360,
                            title: {display: true, text: 'Azimuth (°)'},
                            grid: {drawOnChartArea: false}
                        }
                    }
                }
            });

        } catch (err) {
            console.error('Could not render chart:', err);
            const canvas = document.getElementById('altitudeChartCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = '16px Arial';
            ctx.fillStyle = 'red';
            ctx.textAlign = 'center';
            ctx.fillText('Error: Could not load chart data.', canvas.width / 2, canvas.height / 2);
        } finally {
            chartLoadingDiv?.classList.add('hidden');
        }
    }

    async function renderMonthlyYearlyChart(view) {
        const chartLoadingDiv = document.getElementById('chart-loading');
        chartLoadingDiv?.classList.remove('hidden');

        const objectName = "{{ object_name }}";
        const selMonth = document.getElementById('month-select').value;
        const year = document.getElementById('year-select').value;
        const plotLat = "{{ graph_lat_param | default('', True) }}";
        const plotLon = "{{ graph_lon_param | default('', True) }}";
        const plotTz = "{{ graph_tz_name_param | default('UTC', true) }}";

        let titleText, objAlt = [], moonAlt = [], horizon = [];

        try {
            if (view === 'year') {
                titleText = `Yearly Altitude at Local Midnight for {{ alt_name }} - ${year}`;

                const months = [...Array(12)].map((_, i) => String(i + 1).padStart(2, '0'));
                const urls = months.map(m =>
                    `/api/get_monthly_plot_data/${encodeURIComponent(objectName)}?year=${year}&month=${m}&plot_lat=${plotLat}&plot_lon=${plotLon}&plot_tz=${encodeURIComponent(plotTz)}`
                );

                const responses = await Promise.all(urls.map(u => fetch(u)));
                const bad = responses.find(r => !r.ok);
                if (bad) throw new Error(`HTTP ${bad.status} for ${bad.url}`);

                const monthly = await Promise.all(responses.map(r => r.json()));

                monthly.forEach(block => {
                    block.dates.forEach((d, i) => {
                        const t = `${d}T00:00:00`;
                        objAlt.push({x: t, y: block.object_alt[i]});
                        moonAlt.push({x: t, y: block.moon_alt[i]});
                        horizon.push({x: t, y: 0});
                    });
                });

            } else {
                titleText = `Monthly Altitude at Local Midnight for {{ alt_name }} - ${year}-${selMonth}`;

                const apiUrl =
                    `/api/get_monthly_plot_data/${encodeURIComponent(objectName)}?year=${year}&month=${selMonth}` +
                    `&plot_lat=${plotLat}&plot_lon=${plotLon}&plot_tz=${encodeURIComponent(plotTz)}`;

                const resp = await fetch(apiUrl);
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                const data = await resp.json();

                data.dates.forEach((d, i) => {
                    const t = `${d}T00:00:00`;
                    objAlt.push({x: t, y: data.object_alt[i]});
                    moonAlt.push({x: t, y: data.moon_alt[i]});
                    horizon.push({x: t, y: 0});
                });
            }

            const ctx = document.getElementById('altitudeChartCanvas').getContext('2d');
            if (window.altitudeChart) window.altitudeChart.destroy();

            window.altitudeChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: '{{ object_name }} Altitude',
                            data: objAlt,
                            borderColor: '#36A2EB',
                            borderWidth: 3,
                            pointRadius: 0,
                            tension: 0.2
                        },
                        {
                            label: 'Moon Altitude',
                            data: moonAlt,
                            borderColor: 'gold',
                            borderWidth: 2.5,
                            pointRadius: 0,
                            tension: 0.0
                        },
                        {label: 'Horizon', data: horizon, borderColor: 'black', borderWidth: 2, pointRadius: 0}
                    ]
                },
                options: {
                    adapters: {date: {zone: plotTz}},
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 2,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: (view === 'year') ? 'month' : 'day',
                                displayFormats: (view === 'year') ? {month: 'MMM'} : {day: 'dd'}
                            },
                            title: {
                                display: true,
                                text: (view === 'year') ? `Month of ${year}` : `Day of ${year}-${selMonth}`
                            }
                        },
                        y: {
                            min: -90, max: 90,
                            title: {display: true, text: 'Altitude (°)'}
                        }
                    },
                    plugins: {
                        legend: {position: 'top'},
                        title: {display: false, text: titleText, align: 'start', font: {size: 16}}
                    }
                }
            });

        } catch (err) {
            console.error(`Could not render ${view} chart:`, err);
            const canvas = document.getElementById('altitudeChartCanvas');
            if (canvas) {
                const c = canvas.getContext('2d');
                c.clearRect(0, 0, canvas.width, canvas.height);
                c.font = "16px Arial";
                c.fillStyle = "red";
                c.textAlign = "center";
                c.fillText(`Error loading ${view} chart data.`, canvas.width / 2, canvas.height / 2);
            }
        } finally {
            chartLoadingDiv?.classList.add('hidden');
        }
    }

    // NEW: base image layer handle + FOV center
    let baseSurvey = null;
    let blendLayer = null;         // secondary survey layer for alpha blending
    let fovCenter = null; // { ra: number, dec: number }

    // --- QoL state ---
    let lockToObject = false;
    let objectCoords = null; // {ra, dec} resolved once per open

    function toggleFramingFullscreen(btn) {
        const modalContent = document.getElementById('framing-modal-content');
        if (!modalContent) return;

        modalContent.classList.toggle('fullscreen');
        // Update button icon/label to reflect the new state
        const isFullscreen = modalContent.classList.contains('fullscreen');
        if (btn) {
            btn.innerHTML = isFullscreen ? '&#x21F2;' : '&#x2922;'; // Shrink / Expand arrows
            btn.title = isFullscreen ? 'Exit fullscreen' : 'Fullscreen';
        }
    }

    function setProjectQuickLink(url) {
        const container = document.getElementById('project-quick-link');
        if (!container) return;

        // Clear any existing button
        container.innerHTML = '';

        if (url) {
            const btn = document.createElement('button');
            btn.className = 'inline-button';
            btn.style.fontSize = '13px';
            btn.style.padding = '6px 12px';
            btn.textContent = 'Re-open Last Saved Framing';
            btn.onclick = () => {
              // Merge current framing params (including blend) with provided base url
              try {
                const u = new URL(url, location.origin);
                const qNow = new URLSearchParams(buildFramingQuery().slice(1));
                qNow.forEach((v, k) => u.searchParams.set(k, v));
                history.pushState(null, '', u.pathname + '?' + u.searchParams.toString());
              } catch (e) {
                history.pushState(null, '', url);
              }
              // Open the modal, which will now read the new URL parameters
              openFramingAssistant();
            };
            container.appendChild(btn);
        }
    }

    // --- Aladin Lite Functions ---
    function openFramingAssistant() {
        const framingModal = document.getElementById('framing-modal');
        const framingRigSelect = document.getElementById('framing-rig-select');

        if (framingRigSelect.options.length === 0 || framingRigSelect.value === "") {
            alert("Please configure at least one rig on the Configuration page first.");
            return;
        }

        // Show the modal
        framingModal.style.display = 'block';
        // Ensure a visible rotation readout element exists
        (function ensureRotationReadout(){
            const slider = document.getElementById('framing-rotation');
            if (!slider) return;

            // Remove any stray literal '0°' text nodes or extra whitespace after the slider
            let n = slider.nextSibling;
            while (n && n.nodeType === Node.TEXT_NODE) {
                const t = n.textContent.trim();
                const next = n.nextSibling;
                if (t === '' || t === '0°') n.parentNode.removeChild(n); else break;
                n = next;
            }

            // Ensure there is exactly one readout span
            const existingSpans = Array.from(document.querySelectorAll('#rotation-value'));
            let span = existingSpans[0];
            // Remove any duplicates beyond the first
            if (existingSpans.length > 1) existingSpans.slice(1).forEach(el => el.remove());

            if (!span) {
                span = document.createElement('span');
                span.id = 'rotation-value';
                span.style.marginLeft = '8px';
                span.style.fontWeight = 'normal';
                span.style.fontSize = '15px';
                slider.insertAdjacentElement('afterend', span);
                try { span.style.fontWeight = 'normal'; } catch(_) {}
            }
        })();

        // Initialize Aladin once
        if (!aladin) {
            aladin = A.aladin('#aladin-lite-div', {
                survey: "P/DSS2/color",
                fov: 1.5,
                cooFrame: 'ICRS',
                showFullscreenControl: false,
                showGotoControl: false
            });
        // --- Custom wheel zoom: slower & smooth
        (function installSlowWheelZoom(){
            if (window.__novaSlowZoomInstalled) return; // avoid double-install
            const host = document.getElementById('aladin-lite-div');
            if (!host) return;

            // Help browsers avoid scroll chaining (Firefox/Chromium)
            try { host.style.overscrollBehavior = 'contain'; } catch(e) {}

            function onWheel(ev) {
                // Let system pinch-zoom (Ctrl/⌘) pass through
                if (ev.ctrlKey) return;
                // We handle zoom ourselves
                ev.preventDefault();
                ev.stopPropagation();

                if (!aladin) return;

                // Normalize delta across devices/browsers
                // deltaMode: 0=pixels, 1=lines (~16 px), 2=pages (~400 px heuristic)
                const unit = (ev.deltaMode === 1) ? 16 : (ev.deltaMode === 2) ? 400 : 1;
                let dy = (ev.deltaY || 0) * unit;

                // Tame aggressive trackpads further
                dy = Math.max(-80, Math.min(80, dy));

                // Read current FOV width (deg) robustly
                const g = aladin.getFov();
                const current = Array.isArray(g) ? (g[0] ?? 1) : (g ?? 1);

                // Smaller coef => slower zoom. 0.00045 is gentle; tweak to taste.
                const scale = Math.exp(dy * 0.00075);
                const minFov = 0.01, maxFov = 180;
                const next = Math.min(maxFov, Math.max(minFov, current * scale));
                if (Number.isFinite(next)) aladin.setFov(next);
            }

            // Capture-phase so we intercept before Aladin's internal handler
            host.addEventListener('wheel', onWheel, { passive: false, capture: true });

            // Also bind directly to the internal canvas (in case it stops propagation)
            const tryBindCanvas = () => {
                const cv = host.querySelector('canvas');
                if (cv) cv.addEventListener('wheel', onWheel, { passive: false, capture: true });
            };
            // Try now and again after a tick (canvas may appear after init)
            tryBindCanvas();
            setTimeout(tryBindCanvas, 50);

            window.__novaSlowZoomInstalled = true;
        })();
            baseSurvey = aladin.getBaseImageLayer();
            // ---------- Blending helpers (Aladin Lite v3) ----------
            let __blendSurveyId = null;

            function ensureBlendLayer() {
              if (!aladin) return null;
              const sel = document.getElementById('blend-survey-select');
              if (!sel) return null;
              const surveyId = sel.value;

              // Reuse if already set to same
              const existing = aladin.getOverlayImageLayer && aladin.getOverlayImageLayer('blend');
              if (existing && __blendSurveyId === surveyId) return existing;

              try {
                const hpx = (aladin.newImageSurvey)
                  ? aladin.newImageSurvey(surveyId)
                  : aladin.createImageSurvey(surveyId, surveyId, surveyId, 'equatorial', 9, { imgFormat: 'jpeg' });

                if (hpx) {
                  aladin.setOverlayImageLayer(hpx, 'blend');
                  __blendSurveyId = surveyId;
                  return aladin.getOverlayImageLayer('blend');
                }
              } catch (e) {
                console.warn('[nova] Could not create/set overlay image survey:', e);
              }
              return null;
            }

            function setBlendOpacity(a) {
              const v = Math.max(0, Math.min(1, Number(a) || 0));
              if (!aladin) return;
              const layer = ensureBlendLayer();

              // Try layer method first
              if (layer && (typeof layer.setOpacity === 'function' || typeof layer.setAlpha === 'function')) {
                (layer.setOpacity || layer.setAlpha).call(layer, v);
                return;
              }
              // Fallback: survey object (some builds expose setOpacity there)
              try {
                const survey = aladin.getOverlayImageLayer && aladin.getOverlayImageLayer('blend');
                survey?.setOpacity?.(v);
              } catch(e) {}
            }


            // Wire blending UI
            (function wireBlendAndConstellationUI(){
                const blendSel = document.getElementById('blend-survey-select');
                const blendOp  = document.getElementById('blend-opacity');

                if (blendSel) {
                    blendSel.addEventListener('change', () => {
                        ensureBlendLayer();
                        const v = Number(blendOp?.value || 0);
                        setBlendOpacity(v);
                        updateFramingChart(false);
                    });
                }
                if (blendOp) {
                    const sync = (e) => {
                        setBlendOpacity(e.target.value);
                        updateFramingChart(false);
                    };
                    blendOp.addEventListener('input', sync);
                    blendOp.addEventListener('change', sync);
                }

                // Initialize (blend hidden)
                try { if (blendOp) setBlendOpacity(blendOp.value); } catch(e) {}
            })();
            // Keep screen-space FOV rectangle visible and sized while zooming
            if (aladin.on) {
                aladin.on('zoomChanged', () => {
                    if (!lockToObject) return;
                    const sel = document.getElementById('framing-rig-select');
                    const rot = parseFloat(document.getElementById('framing-rotation')?.value || '0') || 0;
                    if (sel && sel.selectedIndex >= 0) {
                        const opt = sel.options[sel.selectedIndex];
                        updateScreenFovOverlay(opt.dataset.fovw, opt.dataset.fovh, rot);
                    }
                });
            }
            // Re‑apply blend layer after base survey changes (some builds clear overlays)
            if (aladin.on) {
                aladin.on('baseLayerChanged', () => {
                    try {
                        const bop = document.getElementById('blend-opacity');
                        // Recreate overlay for the selected blend survey and restore opacity
                        ensureBlendLayer();
                        if (bop) setBlendOpacity(bop.value);
                    } catch (e) {
                        console.warn('[nova] Could not reapply blend after base change:', e);
                    }
                });
            }

            // Overlay for the FOV polygon
            fovLayer = A.graphicOverlay({color: '#83b4c5', lineWidth: 3});
            aladin.addOverlay(fovLayer);

            const canvas = document.getElementById('aladin-lite-div');
            // --- Watch for canvas size changes so FOV frame always stays visible ---
            if (window.ResizeObserver && canvas) {
                let roTimer = null;
                const ro = new ResizeObserver(() => {
                    clearTimeout(roTimer);
                    roTimer = setTimeout(() => {
                        const sel = document.getElementById('framing-rig-select');
                        if (sel && sel.selectedIndex >= 0) {
                            const opt = sel.options[sel.selectedIndex];
                            applyRigFovZoom(opt.dataset.fovw, opt.dataset.fovh);
                        }
                        updateFramingChart(false);
                        if (lockToObject) {
                            const sel = document.getElementById('framing-rig-select');
                            const rot = parseFloat(document.getElementById('framing-rotation')?.value || '0') || 0;
                            if (sel && sel.selectedIndex >= 0) {
                                const opt = sel.options[sel.selectedIndex];
                                updateScreenFovOverlay(opt.dataset.fovw, opt.dataset.fovh, rot);
                            }
                        }
                                            }, 80);
                });
                ro.observe(canvas);
            }
            // Prepare a screen-space overlay for "Lock FOV"
            (function ensureScreenOverlay(){
                const host = document.getElementById('aladin-lite-div');
                if (!host) return;
                // Ensure we can absolutely-position a child over the canvas
                if (!host.style.position) host.style.position = 'relative';

                if (!document.getElementById('screen-fov-overlay')) {
                    const ov = document.createElement('div');
                    ov.id = 'screen-fov-overlay';
                    ov.style.position = 'absolute';
                    ov.style.inset = '0';
                    ov.style.pointerEvents = 'none';
                    ov.style.zIndex = '5';

                    const rect = document.createElement('div');
                    rect.id = 'screen-fov-rect';
                    rect.style.position = 'absolute';
                    rect.style.border = '3px solid #83b4c5';
                    rect.style.boxSizing = 'border-box';
                    rect.style.left = '50%';
                    rect.style.top = '50%';
                    rect.style.transformOrigin = 'center center';
                    rect.style.display = 'none';  // only visible when locked
                    ov.appendChild(rect);

                    host.appendChild(ov);
                }
            })();
            // Shift+Click → set FOV center to cursor (plain click does nothing)
            canvas.addEventListener('click', (ev) => {
                if (!ev.shiftKey) return;      // <— NEW requirement
                if (lockToObject) return;      // respect lock
                const rect = canvas.getBoundingClientRect();
                const x = ev.clientX - rect.left;
                const y = ev.clientY - rect.top;
                const sky = aladin.pix2world(x, y);
                if (!sky) return;
                fovCenter = {ra: sky[0], dec: sky[1]};
                updateFramingChart(false);
                if (lockToObject) {
                    const sel = document.getElementById('framing-rig-select');
                    const rot = parseFloat(document.getElementById('framing-rotation')?.value || '0') || 0;
                    if (sel && sel.selectedIndex >= 0) {
                        const opt = sel.options[sel.selectedIndex];
                        updateScreenFovOverlay(opt.dataset.fovw, opt.dataset.fovh, rot);
                    }
                }
                updateReadoutFromCenter();
            });

            // Keyboard nudges (1′)
            window.addEventListener('keydown', (e) => {
                const k = e.key.toLowerCase();
                if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd'].includes(k)) {
                    e.preventDefault();
                    if (k === 'arrowup' || k === 'w') nudgeFov(0, +1);
                    if (k === 'arrowdown' || k === 's') nudgeFov(0, -1);
                    if (k === 'arrowleft' || k === 'a') nudgeFov(-1, 0);
                    if (k === 'arrowright' || k === 'd') nudgeFov(+1, 0);
                }
            });

            // Keep rotation value live and update overlay without refit (attach every open)
            (function wireRotationLiveUpdate(){
                const rotInput = document.getElementById('framing-rotation');
                if (!rotInput) return;

                const handler = () => {
                    // Recompute everything (including label) in one place
                    updateFramingChart(false);
                };

                // Remove previous handler if any to avoid duplicates
                try { rotInput.removeEventListener('input', rotInput.__novaRotHandler); } catch(e) {}
                try { rotInput.removeEventListener('change', rotInput.__novaRotHandler); } catch(e) {}
                rotInput.__novaRotHandler = handler;
                rotInput.addEventListener('input', handler);
                rotInput.addEventListener('change', handler);
                // Normalize the slider's attribute so programmatic changes reflect
                try { rotInput.setAttribute('value', String(rotInput.valueAsNumber ?? rotInput.value ?? 0)); } catch(e) {}
                // Initialize display immediately
                handler();
            })();

            // Wire: Insert into Project should carry blend settings as well
            (function wireInsertIntoProject(){
              const btn = document.getElementById('insert-into-project');
              if (!btn) return;
              try { btn.removeEventListener('click', btn.__novaInsertHandler); } catch(e) {}
              btn.__novaInsertHandler = (ev) => {
                try {
                  // Update the URL (no reload) so backend reads all params, including blend*
                  const q = buildFramingQuery();
                  const href = location.pathname + q;
                  history.replaceState(null, '', href);
                  // Let any existing handler proceed (we just made sure the URL is up-to-date)
                } catch(e) {
                  console.warn('[nova] Insert-to-project wiring error:', e);
                }
              };
              btn.addEventListener('click', btn.__novaInsertHandler);
            })();

        }
        // Helper: build current framing query (used by Insert to Project & quick links)
        function buildFramingQuery() {
          const sel = document.getElementById('framing-rig-select');
          const rig = sel && sel.selectedIndex >= 0 ? sel.options[sel.selectedIndex].value : '';
          const rotInput = document.getElementById('framing-rotation');
          const rot = rotInput ? (parseFloat(rotInput.value) || 0) : 0;
          const sSel = document.getElementById('survey-select');
          const survey = sSel ? sSel.value : '';
          const bSel = document.getElementById('blend-survey-select');
          const bOp  = document.getElementById('blend-opacity');
          const blend = bSel ? bSel.value : '';
          const blend_op = bOp ? (parseFloat(bOp.value) || 0) : 0;
          const { ra, dec } = (fovCenter || (aladin && (() => { const rc = aladin.getRaDec(); return { ra: rc[0], dec: rc[1] }; })()) || { ra: NaN, dec: NaN });

          const qp = new URLSearchParams();
          if (rig) qp.set('rig', rig);
          if (Number.isFinite(ra)) qp.set('ra', ra.toFixed(6));
          if (Number.isFinite(dec)) qp.set('dec', dec.toFixed(6));
          qp.set('rot', String(Math.round(rot)));
          if (survey) qp.set('survey', survey);
          if (blend) qp.set('blend', blend);
          qp.set('blend_op', String(Math.max(0, Math.min(1, blend_op))));
          return '?' + qp.toString();
        }
        // -------- Restore from URL (rig/center/rotation/survey) --------
        let haveCenter = false;
        let haveRot = false;
        let haveRigRestored = false;

        try {
            const q = new URLSearchParams(location.search);
            const rig = q.get('rig');
            const ra = parseFloat(q.get('ra'));
            const dec = parseFloat(q.get('dec'));
            const rot = parseFloat(q.get('rot'));
            const surv = q.get('survey');
            const blend = q.get('blend');
            const blendOp = parseFloat(q.get('blend_op'));

            // Rig
            if (rig) {
                const sel = document.getElementById('framing-rig-select');
                if (sel) {
                    const idx = Array.from(sel.options).findIndex(o => o.value === rig);
                    if (idx >= 0) {
                        sel.selectedIndex = idx;
                        haveRigRestored = true;
                    }
                }
            }

            // Rotation
            if (!Number.isNaN(rot)) {
                const rotInput = document.getElementById('framing-rotation');
                if (rotInput) rotInput.value = rot;
                const rotSpan = document.getElementById('rotation-value');
                if (rotSpan) rotSpan.textContent = `${Math.round(rot)}°`;
                haveRot = true;
            }

            // Survey
            if (surv) {
                if (typeof setSurvey === 'function') setSurvey(surv);
                else {
                    const s = document.getElementById('survey-select');
                    if (s) s.value = surv;
                }
            }

            // Blend survey & opacity
            try {
              const bsel = document.getElementById('blend-survey-select');
              const bop  = document.getElementById('blend-opacity');
              if (blend && bsel) {
                bsel.value = blend;
                if (typeof ensureBlendLayer === 'function') ensureBlendLayer();
              }
              if (!Number.isNaN(blendOp) && bop) {
                bop.value = String(Math.max(0, Math.min(1, blendOp)));
                if (typeof setBlendOpacity === 'function') setBlendOpacity(bop.value);
              }
            } catch (e) {}

            // Finalize: ensure blend overlay + opacity actually applied
            try {
              const bop2 = document.getElementById('blend-opacity');
              ensureBlendLayer();
              if (bop2) setBlendOpacity(bop2.value);
            } catch (e) {}

            // Saved frame center
            if (!Number.isNaN(ra) && !Number.isNaN(dec)) {
                fovCenter = {ra, dec};       // IMPORTANT: assign the real variable, not window.*
                haveCenter = true;
            } else {
                fovCenter = null;
            }
        } catch (e) {
            // ignore; keep current defaults
        }
        // Finalize: ensure blend shows what URL/controls say (covers late base survey init)
        try {
            const bop = document.getElementById('blend-opacity');
            ensureBlendLayer();
            if (bop) setBlendOpacity(bop.value);
        } catch (e) {}

        // Defaults if not provided
        if (!haveRot) {
            const rotInput = document.getElementById('framing-rotation');
            if (rotInput) rotInput.value = 0;
            const rotSpan = document.getElementById('rotation-value');
            if (rotSpan) rotSpan.textContent = `0°`;
        }
        if (!haveRigRestored) {
            // Do NOT force index 0 if a rig is already selected; leave as-is
        }

        // If there is a saved center: unlock and center Aladin there BEFORE first draw
        if (haveCenter) {
            const lockBox = document.getElementById('lock-to-object');
            if (lockBox) lockBox.checked = false;
            lockToObject = false;
            if (aladin && typeof aladin.gotoRaDec === 'function') {
                aladin.gotoRaDec(fovCenter.ra, fovCenter.dec);
            }
            if (haveCenter) {
                const sel = document.getElementById('framing-rig-select');
                if (sel && sel.selectedIndex >= 0) {
                    const opt = sel.options[sel.selectedIndex];
                    applyRigFovZoom(opt.dataset.fovw, opt.dataset.fovh);
                }
            }
        }

        // First draw: if haveCenter, don't recenter to object
        updateFramingChart(haveCenter ? false : true);
        updateFovVsObjectLabel?.();
        updateReadoutFromCenter?.();
        // Ensure lock-to-object/Lock FOV default checked state is respected on load
        if (!haveCenter) {
            // If not restoring to a saved center, enable lock mode by default
            applyLockToObject(true);
        }
    }

    function closeFramingAssistant() {
        const framingModal = document.getElementById('framing-modal');
        framingModal.style.display = 'none';
    }

    function flipFraming90() {
        const slider = document.getElementById('framing-rotation');
        let v = parseFloat(slider.value) || 0;
        v = (v + 90) % 360;
        slider.value = v;
        // Let the live handler update the label and overlay
        slider.dispatchEvent(new Event('input', { bubbles: true }));
        updateFramingChart(false);
        updateReadoutFromCenter();
    }

    // Always zoom so the current rig's FOV just fits in view.
    // fovW_arcmin and fovH_arcmin are arcminutes.
    function applyRigFovZoom(fovW_arcmin, fovH_arcmin, rotationDeg = 0, margin = 1.06) {
        if (!aladin) return;
        const host = document.getElementById('aladin-lite-div');
        if (!host) return;

        const wpx = host.clientWidth, hpx = host.clientHeight;
        if (!(wpx > 0 && hpx > 0)) return;
        const aspect = wpx / hpx;               // width / height in pixels

        const wDeg = parseFloat(fovW_arcmin) / 60;
        const hDeg = parseFloat(fovH_arcmin) / 60;
        if (!(isFinite(wDeg) && isFinite(hDeg) && wDeg > 0 && hDeg > 0)) return;

        // Account for rotation: bounding box of a rotated rectangle
        const th = (parseFloat(rotationDeg) || 0) * Math.PI / 180;
        const needWidthDeg = Math.abs(wDeg * Math.cos(th)) + Math.abs(hDeg * Math.sin(th));
        const needHeightDeg = Math.abs(wDeg * Math.sin(th)) + Math.abs(hDeg * Math.cos(th));

        // setFov() controls the *width* in degrees. Ensure BOTH axes fit:
        const requiredWidthDeg = Math.max(needWidthDeg * margin, needHeightDeg * margin * aspect);
        aladin.setFov(requiredWidthDeg);
        // If FOV is locked, keep the screen overlay sized correctly
        if (lockToObject) updateScreenFovOverlay(fovW_arcmin, fovH_arcmin, rotationDeg);
    }

window.updateFramingChart = function (recenter = true) {
    if (!aladin) return;

    const objectName = "{{ object_name }}";
    const framingRigSelect = document.getElementById('framing-rig-select');
    const rotationSlider = document.getElementById('framing-rotation');
    const rotationValueSpan = document.getElementById('rotation-value');
    const selectedOption = framingRigSelect.options[framingRigSelect.selectedIndex];
    if (!selectedOption) return;

    const fovWidthArcmin = parseFloat(selectedOption.dataset.fovw);
    const fovHeightArcmin = parseFloat(selectedOption.dataset.fovh);

    // Read rotation robustly from the range input
    const vNum = (rotationSlider && typeof rotationSlider.valueAsNumber === 'number') ? rotationSlider.valueAsNumber : NaN;
    const rotation = Number.isFinite(vNum)
      ? vNum
      : (Number.isFinite(parseFloat(rotationSlider.value)) ? parseFloat(rotationSlider.value) : 0);

    // Update rotation label here so there is exactly one writer
    (function updateRotationBadge(){
        const el = document.getElementById('rotation-value');
        const sliderEl = document.getElementById('framing-rotation');
        const txt = `${Math.round(rotation)}°`;
        if (el) el.textContent = txt;
        if (sliderEl) sliderEl.title = `Rotation: ${txt}`; // helpful hover fallback
    })();

        // Only refit/zoom when we explicitly recenter; rotation alone should not change zoom
        if (recenter) {
            applyRigFovZoom(fovWidthArcmin, fovHeightArcmin, rotation);
        }

        if (recenter) {
            aladin.gotoObject(objectName, {
                success: () => {
                    // ✅ Zoom again after gotoObject so frame fits perfectly
                    applyRigFovZoom(fovWidthArcmin, fovHeightArcmin, rotation);

                    const rc = aladin.getRaDec();
                    objectCoords = {ra: rc[0], dec: rc[1]};
                    fovCenter = lockToObject ? {...objectCoords} : {ra: rc[0], dec: rc[1]};
                    if (lockToObject) {
                        if (fovLayer) fovLayer.removeAll();
                        updateScreenFovOverlay(fovWidthArcmin, fovHeightArcmin, rotation);
                    } else {
                        drawFovFootprint(fovWidthArcmin, fovHeightArcmin, rotation, fovCenter);
                    }
                    updateReadoutFromCenter?.();
                },
                error: () => {
                    const rc = aladin.getRaDec();
                    fovCenter = {ra: rc[0], dec: rc[1]};
                    if (lockToObject) {
                        if (fovLayer) fovLayer.removeAll();
                        updateScreenFovOverlay(fovWidthArcmin, fovHeightArcmin, rotation);
                    } else {
                        drawFovFootprint(fovWidthArcmin, fovHeightArcmin, rotation, fovCenter);
                    }
                    updateReadoutFromCenter?.();
                }
            });
            return;
        }

        // No recenter: reuse existing center
        if (!fovCenter) {
            const rc = aladin.getRaDec();
            fovCenter = {ra: rc[0], dec: rc[1]};
        }
        if (lockToObject) {
            if (fovLayer) fovLayer.removeAll();
            updateScreenFovOverlay(fovWidthArcmin, fovHeightArcmin, rotation);
        } else {
            drawFovFootprint(fovWidthArcmin, fovHeightArcmin, rotation, fovCenter);
        }
    };

    function drawFovFootprint(fovWidthArcmin, fovHeightArcmin, rotationDeg, center) {
        if (!aladin || !fovLayer || !center) return;

        fovLayer.removeAll();

        // Half-sizes in DEGREES
        const halfW = (fovWidthArcmin / 60) / 2;
        const halfH = (fovHeightArcmin / 60) / 2;

        // Rotation in radians
        const ang = rotationDeg * Math.PI / 180;

        // Center (radians)
        const ra0 = center.ra * Math.PI / 180;
        const dec0 = center.dec * Math.PI / 180;

        // Unit vector at center
        const cX = Math.cos(dec0) * Math.cos(ra0);
        const cY = Math.cos(dec0) * Math.sin(ra0);
        const cZ = Math.sin(dec0);

        // Local basis at center: East & North unit vectors
        // East: d/dRA at fixed Dec -> (-sinRA, cosRA, 0)
        const eX = -Math.sin(ra0), eY = Math.cos(ra0), eZ = 0;
        // North: d/dDec at fixed RA -> (-sinDec*cosRA, -sinDec*sinRA, cosDec)
        const nX = -Math.sin(dec0) * Math.cos(ra0);
        const nY = -Math.sin(dec0) * Math.sin(ra0);
        const nZ = Math.cos(dec0);

        // Rotate a point (x,y) in the local tangent plane by 'ang'
        function rot2d(x, y) {
            return [x * Math.cos(ang) - y * Math.sin(ang),
                x * Math.sin(ang) + y * Math.cos(ang)];
        }

        // Corners before spherical mapping (deg in the local plane)
        const raw = [
            [-halfW, -halfH],
            [halfW, -halfH],
            [halfW, halfH],
            [-halfW, halfH],
        ].map(([x, y]) => rot2d(x, y));

        // Map each (x_deg, y_deg) to the sphere and return [ra_deg, dec_deg]
        function planeToSky(x_deg, y_deg) {
            const dx = x_deg * Math.PI / 180;  // angular distance east (radians)
            const dy = y_deg * Math.PI / 180;  // angular distance north (radians)
            const r = Math.hypot(dx, dy);

            if (r < 1e-12) {
                // exactly the center
                return [center.ra, center.dec];
            }

            // Direction unit vector in 3D: (dx * East + dy * North) / r
            const dirX = (dx * eX + dy * nX) / r;
            const dirY = (dx * eY + dy * nY) / r;
            const dirZ = (dx * eZ + dy * nZ) / r;

            // Great-circle step: new = center*cos(r) + dir*sin(r)
            const s = Math.sin(r), c = Math.cos(r);
            const pX = c * cX + s * dirX;
            const pY = c * cY + s * dirY;
            const pZ = c * cZ + s * dirZ;

            // Back to RA/Dec
            let ra = Math.atan2(pY, pX);
            if (ra < 0) ra += 2 * Math.PI;
            const dec = Math.asin(pZ);
            return [ra * 180 / Math.PI, dec * 180 / Math.PI];
        }

        // Build polygon
        const polyCoords = raw.map(([x, y]) => planeToSky(x, y));
        polyCoords.push(polyCoords[0]); // close

        // Draw (teal, thicker line)
        const fovPolygon = A.polygon(polyCoords, {color: '#83b4c5', lineWidth: 3});
        const fovFootprint = A.footprint(fovPolygon);
        fovLayer.add(fovFootprint);

        updateReadoutFromCenter?.();
    }
    // --- Screen-space FOV overlay helpers (for "Lock FOV") ---
    let lockFovEnabled = false;
    let lockRafId = null;

    function updateScreenFovOverlay(fovWidthArcmin, fovHeightArcmin, rotationDeg) {
        const host = document.getElementById('aladin-lite-div');
        const rectEl = document.getElementById('screen-fov-rect');
        if (!host || !rectEl) return;

        const wpx = host.clientWidth || 1;
        const hpx = host.clientHeight || 1;

        // Aladin.getFov() returns width in degrees; height ~ width * (hpx/wpx)
        const gf = aladin.getFov();
        const viewWdeg = Array.isArray(gf) ? (gf[0] ?? 1) : (gf ?? 1);
        const viewHdeg = viewWdeg * (hpx / wpx);

        const fovWdeg = (parseFloat(fovWidthArcmin) || 0) / 60;
        const fovHdeg = (parseFloat(fovHeightArcmin) || 0) / 60;
        if (!(fovWdeg > 0 && fovHdeg > 0)) return;

        // Convert FOV to pixels for current view
        const pxW = Math.max(2, (fovWdeg / viewWdeg) * wpx);
        const pxH = Math.max(2, (fovHdeg / viewHdeg) * hpx);

        rectEl.style.display = 'block';
        rectEl.style.width = pxW + 'px';
        rectEl.style.height = pxH + 'px';
        rectEl.style.marginLeft = (-pxW / 2) + 'px';
        rectEl.style.marginTop = (-pxH / 2) + 'px';
        rectEl.style.transform = `translate(0,0) rotate(${rotationDeg || 0}deg)`;
    }

    function startLockOverlayLoop() {
        if (lockRafId) return;
        const tick = () => {
            if (!lockToObject) { lockRafId = null; return; }
            // Keep size in sync as the user pans/zooms
            const sel = document.getElementById('framing-rig-select');
            const rot = parseFloat(document.getElementById('framing-rotation')?.value || '0') || 0;
            if (sel && sel.selectedIndex >= 0) {
                const opt = sel.options[sel.selectedIndex];
                updateScreenFovOverlay(opt.dataset.fovw, opt.dataset.fovh, rot);
            }
            updateReadoutFromCenter();
            lockRafId = requestAnimationFrame(tick);
        };
        lockRafId = requestAnimationFrame(tick);
    }

    function stopLockOverlayLoop() {
        if (lockRafId) { cancelAnimationFrame(lockRafId); lockRafId = null; }
    }
    function setSurvey(hipsId) {
        if (!aladin) return;
        const newLayer = aladin.newImageSurvey(hipsId);
        aladin.setBaseImageLayer(newLayer);
        baseSurvey = aladin.getBaseImageLayer();
        // reapply current image adjustments to the new layer
        updateImageAdjustments();
    }

    function updateImageAdjustments() {
        if (!baseSurvey) return;
        const b = parseFloat(document.getElementById('img-bright').value);
        const c = parseFloat(document.getElementById('img-contrast').value);
        const g = parseFloat(document.getElementById('img-gamma').value);
        const s = parseFloat(document.getElementById('img-sat').value);

        // API: setBrightness(-1..1), setContrast(-1..1), setGamma(0.1..10), setSaturation(-1..1)
        baseSurvey.setBrightness(b);
        baseSurvey.setContrast(c);
        baseSurvey.setGamma(g);
        baseSurvey.setSaturation(s);
    }

    function updateReadout(raDeg, decDeg) {
        document.getElementById('ra-readout').value = formatRA(raDeg);
        document.getElementById('dec-readout').value = formatDec(decDeg);
    }

    // Always show the sky coordinates at the frame center
    function updateReadoutFromCenter() {
        let center;
        if (lockToObject) {
            // In locked mode, the frame is fixed at screen center, which is the view center
            const rc = aladin.getRaDec();
            center = { ra: rc[0], dec: rc[1] };
        } else if (fovCenter && isFinite(fovCenter.ra) && isFinite(fovCenter.dec)) {
            center = fovCenter;
        } else {
            const rc = aladin.getRaDec();
            center = { ra: rc[0], dec: rc[1] };
        }
        updateReadout(center.ra, center.dec);
    }

    function copyRaDec() {
        const text = `${document.getElementById('ra-readout').value} ${document.getElementById('dec-readout').value}`;
        navigator.clipboard.writeText(text).then(() => {
            // optional toast
        });
    }

    function changeView(view) {
        // First, update the header text for the selected date
        const day = document.getElementById('day-select').value;
        const month = document.getElementById('month-select').value;
        const year = document.getElementById('year-select').value;
        const objectName = "{{ object_name }}";

        fetch(`/get_date_info/${encodeURIComponent(objectName)}?day=${day}&month=${month}&year=${year}`)
            .then(response => response.json())
            .then(data => {
                document.getElementById("date-display").innerText = formatDateISOtoEuropean(data.date);
                document.getElementById("phase-display").innerText = data.phase + "%";
                document.getElementById("dusk-display").innerText = data.astronomical_dusk;
                document.getElementById("dawn-display").innerText = data.astronomical_dawn;
            });

        // Now, call the correct function to render the selected chart view
        if (view === 'day') {
            renderClientSideChart();
        } else {
            renderMonthlyYearlyChart(view);
        }
    }

    function useReadoutAsFovCenter() {
        const raStr = document.getElementById('ra-readout').value;
        const decStr = document.getElementById('dec-readout').value;
        const sky = parseRaDec(raStr, decStr);
        if (!sky) return;
        fovCenter = {ra: sky.ra, dec: sky.dec};
        updateFramingChart(false);
        updateReadoutFromCenter();
    }

    function resetFovCenterToObject() {
        fovCenter = null; // will fall back to view center after gotoObject
        updateFramingChart(true);
        updateFovVsObjectLabel();
    }

    function nudgeFov(dxArcmin, dyArcmin) {
        if (lockToObject && objectCoords) {
            fovCenter = {ra: objectCoords.ra, dec: objectCoords.dec};
            updateFramingChart(false);
            updateReadoutFromCenter();
            return;
        }
        if (!fovCenter) {
            const rc = aladin.getRaDec();
            fovCenter = {ra: rc[0], dec: rc[1]};
        }

        // Convert current declination to radians for the Math.cos function
        const decRad = fovCenter.dec * (Math.PI / 180);

        // Correct the RA nudge by the cosine of the declination
        // This accounts for the projection of the celestial sphere onto your flat screen
        if (Math.abs(decRad) < (Math.PI / 2.0 - 0.001)) { // Avoid division by zero near the pole
            fovCenter.ra -= (dxArcmin / 60.0) / Math.cos(decRad);
        }

        // The declination nudge is simpler and doesn't need correction
        fovCenter.dec += dyArcmin / 60.0;

        updateFramingChart(false);
        updateReadoutFromCenter();
    }

    function applyLockToObject(locked) {
        lockToObject = !!locked;

        const rectEl = document.getElementById('screen-fov-rect');
        if (lockToObject) {
            // Snap overlay center to current object once
            const c = objectCoords || (() => {
                const rc = aladin.getRaDec();
                return {ra: rc[0], dec: rc[1]};
            })();
            fovCenter = {ra: c.ra, dec: c.dec};

            // Hide sky-anchored polygon while locked
            if (fovLayer) fovLayer.removeAll();

            // Show screen-space rectangle and size it
            if (rectEl) rectEl.style.display = 'block';
            const sel = document.getElementById('framing-rig-select');
            const rot = parseFloat(document.getElementById('framing-rotation')?.value || '0') || 0;
            if (sel && sel.selectedIndex >= 0) {
                const opt = sel.options[sel.selectedIndex];
                updateScreenFovOverlay(opt.dataset.fovw, opt.dataset.fovh, rot);
            }

            startLockOverlayLoop();
            updateReadoutFromCenter();
        } else {
            // Restore normal sky overlay
            if (rectEl) rectEl.style.display = 'none';
            stopLockOverlayLoop();

            // Redraw footprint with current rig/rotation at current center
            const sel = document.getElementById('framing-rig-select');
            const rot = parseFloat(document.getElementById('framing-rotation')?.value || '0') || 0;
            const center = fovCenter || (() => {
                const rc = aladin.getRaDec();
                return {ra: rc[0], dec: rc[1]};
            })();
            if (sel && sel.selectedIndex >= 0) {
                const opt = sel.options[sel.selectedIndex];
                drawFovFootprint(parseFloat(opt.dataset.fovw), parseFloat(opt.dataset.fovh), rot, center);
            }
            updateReadoutFromCenter();
        }
    }

    function updateFovVsObjectLabel() {
        const el = document.getElementById('fov-vs-object');
        if (!el) return;

        const sel = document.getElementById('framing-rig-select');
        if (!sel || sel.selectedIndex < 0) {
            el.textContent = '';
            return;
        }

        const opt = sel.options[sel.selectedIndex];
        const fovW = parseFloat(opt.dataset.fovw); // arcmin
        const fovH = parseFloat(opt.dataset.fovh); // arcmin
        if (!isFinite(fovW) || !isFinite(fovH)) {
            el.textContent = '';
            return;
        }

        let text = `FOV (Rig): ${Math.round(fovW)}′ × ${Math.round(fovH)}′`;

        if (typeof OBJECT_SIZE_ARCMIN === 'number' && isFinite(OBJECT_SIZE_ARCMIN) && OBJECT_SIZE_ARCMIN > 0) {
            const minSide = Math.min(fovW, fovH);
            const fitAcross = minSide / OBJECT_SIZE_ARCMIN;
            // e.g., "Object ~ 20′ → fits ~3.1× across the short side"
            text += ` • Object ~ ${Math.round(OBJECT_SIZE_ARCMIN)}′ → ${fitAcross >= 1 ? 'fits' : 'spans'} ${fitAcross.toFixed(1)}× ${fitAcross >= 1 ? 'across' : 'of'} short side`;
        }

        el.textContent = text;
    }

    // If user tries to move center while locked, ignore and re-snap.

    // Optionally, keep the VIEW panned onto the object whenever user drags while locked.
    // Simple heuristic: on mouseup, jump back to object.
    (function recenterViewWhenLocked() {
        const canvas = document.getElementById('aladin-lite-div');
        if (!canvas) return;
        canvas.addEventListener('mouseup', () => {
            if (lockToObject && objectCoords) {
                aladin.gotoObject([objectCoords.ra, objectCoords.dec]);
            }
        });
    })();

    // Formatting helpers
    function pad(n, w = 2) {
        return n.toString().padStart(w, '0');
    }

    function formatRA(raDeg) {
        const totalSec = raDeg / 15 * 3600;
        const h = Math.floor(totalSec / 3600);
        const m = Math.floor((totalSec % 3600) / 60);
        const s = (totalSec % 60).toFixed(2);
        return `${pad(h)}:${pad(m)}:${pad(s, 5)}`;
    }

    function formatDec(decDeg) {
        const sign = decDeg >= 0 ? '+' : '-';
        const abs = Math.abs(decDeg);
        const d = Math.floor(abs);
        const m = Math.floor((abs - d) * 60);
        const s = ((abs - d) * 60 - m) * 60;
        return `${sign}${pad(d)}:${pad(m)}:${s.toFixed(1).padStart(4, '0')}`;
    }

    function getFrameCenterRaDec() {
      if (lockToObject) {
        // Screen-fixed frame: center is the current view center
        const rc = aladin.getRaDec();
        return { ra: rc[0], dec: rc[1] };
      }
      if (fovCenter && isFinite(fovCenter.ra) && isFinite(fovCenter.dec)) return fovCenter;
      const rc = aladin.getRaDec();
      return { ra: rc[0], dec: rc[1] };
    }

    function parseRaDec(raHMS, decDMS) {
        try {
            const [h, m, s] = raHMS.split(':').map(parseFloat);
            const ra = (h + m / 60 + s / 3600) * 15.0;
            const sign = decDMS.trim()[0] === '-' ? -1 : 1;
            const [d, dm, ds] = decDMS.replace('+', '').replace('-', '').split(':').map(parseFloat);
            const dec = sign * (d + dm / 60 + ds / 3600);
            return {ra, dec};
        } catch (e) {
            return null;
        }
    }

    // --- Your Original Page Functions ---

    function formatDateISOtoEuropean(iso_str) {
        if (!iso_str || typeof iso_str !== 'string') return 'N/A';
        const parts = iso_str.split("-");
        if (parts.length !== 3) {
            console.warn("formatDateISOtoEuropean received unexpected format:", iso_str);
            return iso_str;
        }
        const [year, month, day] = parts;
        return `${day}.${month}.${year}`;
    }

    function setLocation() {
        const selectedLocation = document.getElementById('location-select').value;
        fetch('/set_location', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({location: selectedLocation})
        })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    refreshChart();
                } else {
                    console.error("Location update failed:", data);
                }
            })
            .catch(error => console.error('Error setting location:', error));
    }

    function saveProject() {
        const newProject = document.getElementById('project-field').value;
        const objectName = "{{ object_name }}";
        fetch('/update_project', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({object: objectName, project: newProject})
        }).then(res => res.json()).then(data => {
            alert(data.status === "success" ? "Project updated successfully!" : data.error);
        });
    }

    function insertFramingIntoProject() {
        try {
            const ta = document.getElementById('project-field');
            if (!ta) {
                alert('Project notes box not found.');
                return;
            }

            // Collect current framing settings (canonical, single source of truth)
            const sel = document.getElementById('framing-rig-select');
            const rigId = sel?.value || '';
            const rigName = (sel && sel.selectedIndex >= 0)
                ? sel.options[sel.selectedIndex].textContent.trim()
                : 'rig?';

            const rotInput = document.getElementById('framing-rotation');
            const rotDeg = Math.round(parseFloat(rotInput?.value ?? '0')) || 0;

            const survSel = document.getElementById('survey-select');
            const survey = survSel?.value || '';

            // Blend survey & opacity (ensure these are persisted)
            const blendSel = document.getElementById('blend-survey-select');
            const blendSurvey = blendSel?.value || '';
            const blendOpEl = document.getElementById('blend-opacity');
            const blendOp = Math.max(0, Math.min(1, parseFloat(blendOpEl?.value ?? '0') || 0));

            // Robust center retrieval
            const center = getFrameCenterRaDec();
            const raDeg  = center.ra;
            const decDeg = center.dec;

            // Sync visible readout so UI matches what we insert
            updateReadout(raDeg, decDeg);

            // Build a shareable URL with ALL framing state
            const qs = new URLSearchParams();
            if (rigId) qs.set('rig', rigId);
            if (Number.isFinite(raDeg)) qs.set('ra', raDeg.toFixed(6));
            if (Number.isFinite(decDeg)) qs.set('dec', decDeg.toFixed(6));
            qs.set('rot', String(rotDeg));
            if (survey) qs.set('survey', survey);
            if (blendSurvey) qs.set('blend', blendSurvey);
            qs.set('blend_op', String(blendOp));
            const url = `${location.origin}${location.pathname}?${qs.toString()}`;

            // Human‑readable single line (we will keep exactly ONE per object)
            const objectName = "{{ object_name }}"; // already in template context
            const centerTxt = `RA ${formatRA(raDeg)}, Dec ${formatDec(decDeg)}`;
            const line = `[Framing:${objectName}] ${rigName}, rot ${rotDeg}\u00B0, ${centerTxt}, survey ${survey || 'default'}${blendSurvey ? ` + blend ${blendSurvey} @ ${blendOp}` : ''}`;

            // === DEDUP STRATEGY ===
            // We maintain at most one framing block for this object: a title line + the URL on the next line.
            // Remove any previous block for the same object, then insert the new one at the end.
            const lines = ta.value.split(/\r?\n/);
            const out = [];
            for (let i = 0; i < lines.length; i++) {
                const L = lines[i];
                // Match the start of a previous block for this object
                if (/^\[Framing:/.test(L)) {
                    // Is it for this object?
                    if (L.startsWith(`[Framing:${objectName}]`)) {
                        // Skip this line and, if the next line looks like a URL, skip it too
                        const maybeUrl = lines[i + 1] || '';
                        if (/^https?:\/\//i.test(maybeUrl)) i++; // skip URL line
                        continue; // drop old block
                    }
                }
                out.push(L);
            }

            // Ensure trailing newline before appending
            if (out.length && out[out.length - 1] !== '') out.push('');
            out.push(line);
            out.push(url);

            ta.value = out.join('\n');
            ta.dispatchEvent(new Event('input', { bubbles: true }));
            ta.scrollTop = ta.scrollHeight;

            // Update the quick link button to this latest canonical URL
            setProjectQuickLink(url);

        } catch (e) {
            console.error('insertFramingIntoProject failed', e);
            alert('Could not insert framing into Project. See console for details.');
        }
    }

    function copyFramingUrl() {
        try {
            // buildFramingQuery() already includes RA, Dec, rotation, survey, blend, etc.
            const q = buildFramingQuery();
            const url = location.origin + location.pathname + q;
            navigator.clipboard.writeText(url);
            console.log("[Framing] Copied URL:", url);
        } catch (e) {
            console.warn("[Framing] copyFramingUrl failed:", e);
        }
    }

    function toggleSimbad() {
        var container = document.getElementById('simbadContainer');
        const objectName = "{{ object_name }}";
        if (container.style.display === 'none' || container.style.display === '') {
            document.getElementById('simbadIframe').src = "https://simbad.u-strasbg.fr/simbad/sim-id?Ident=" + encodeURIComponent(objectName);
            container.style.display = 'block';
        } else {
            container.style.display = 'none';
        }
    }

    function loadImagingOpportunities() {
        document.getElementById("opportunities-section").style.display = "block";
        const tbody = document.getElementById("opportunities-body");
        tbody.innerHTML = `<tr><td colspan="9">Searching...</td></tr>`;
        const objectName = "{{ object_name }}";

        fetch(`/get_imaging_opportunities/${encodeURIComponent(objectName)}`)
            .then(response => response.json())
            .then(data => {
                if (data.status === "success") {
                    if (data.results.length === 0) {
                        tbody.innerHTML = `<tr><td colspan="9">No good dates found matching your criteria.</td></tr>`;
                        return;
                    }
                    let htmlRows = "";
                    const selectedDateStr = `${document.getElementById('year-select').value.padStart(4, '0')}-${document.getElementById('month-select').value.padStart(2, '0')}-${document.getElementById('day-select').value.padStart(2, '0')}`;
                    const plotLat = "{{ graph_lat_param }}";
                    const plotLon = "{{ graph_lon_param }}";


                    data.results.forEach(r => {
                        const isSelected = r.date === selectedDateStr;
                        const formattedDate = formatDateISOtoEuropean(r.date);
                        const ics_url = `/generate_ics/${encodeURIComponent(objectName)}?date=${r.date}&tz=${encodeURIComponent(plotTz)}&lat=${plotLat}&lon=${plotLon}&max_alt=${r.max_alt}&moon_illum=${r.moon_illumination}&obs_dur=${r.obs_minutes}&from_time=${r.from_time}&to_time=${r.to_time}`;
                        const filename = `imaging_${objectName.replace(/\s+/g, '_')}_${r.date}.ics`;
                        htmlRows += `<tr class="${isSelected ? 'highlight' : ''}" data-date="${r.date}" onclick="selectSuggestedDate('${r.date}')" style="cursor: pointer;">
                        <td>${formattedDate}</td><td>${r.from_time}</td><td>${r.to_time}</td><td>${r.obs_minutes}</td>
                        <td>${r.max_alt}</td><td>${r.moon_illumination}</td><td>${r.moon_separation}</td>
                        <td>${r.rating || ""}</td><td onclick="event.stopPropagation();"><a href="${ics_url}" download="${filename}" title="Add to calendar" style="font-size: 1.5em; text-decoration: none;">🗓️</a></td></tr>`;
                    });
                    tbody.innerHTML = htmlRows;
                } else {
                    tbody.innerHTML = `<tr><td colspan="9">Error: ${data.message}</td></tr>`;
                }
            });
    }

    function selectSuggestedDate(dateStr) {
        const [year, month, day] = dateStr.split('-').map(Number);
        document.getElementById('year-select').value = year;
        document.getElementById('month-select').value = month;
        document.getElementById('day-select').value = day;
        changeView('day'); // This will re-render the chart for the new date
        // Highlight the selected row after a short delay to ensure the table has re-rendered if needed
        setTimeout(() => {
            const rows = document.getElementById("opportunities-body").querySelectorAll("tr");
            rows.forEach(row => {
                row.classList.toggle("highlight", row.getAttribute("data-date") === dateStr);
            });
        }, 100);
    }

    function openInStellarium() {
        document.getElementById('stellarium-status').textContent = "Sending object to Stellarium...";
        document.getElementById('stellarium-status').style.color = "#666"; // Reset color
        const objectName = "{{ object_name }}";
        fetch("/proxy_focus", {
            method: "POST",
            headers: {"Content-Type": "application/x-www-form-urlencoded"},
            body: new URLSearchParams({target: objectName, mode: "center"})
        })
            .then(async response => {
                let data;
                try {
                    data = await response.json();
                } catch (e) {
                    data = {message: "Could not parse server response."};
                }

                if (response.ok && data.status === "success") {
                    document.getElementById('stellarium-status').textContent = "Stellarium view updated!";
                    document.getElementById('stellarium-status').style.color = "#83b4c5";
                } else {
                    document.getElementById('stellarium-status').innerHTML = `<p style="color:red; margin:0;">Error: ${data.message || "Unknown error"}</p>`;
                }
            });
    }

    window.addEventListener('load', () => {
        // As you correctly diagnosed, we must register the plugin before using it.
        // This line runs after the library file has been loaded.
        if (window['chartjs-plugin-annotation']) {
            Chart.register(window['chartjs-plugin-annotation']);
        }

        // Now, the initial chart render will work.
        changeView('day');

        // The rest of your setup logic remains the same.
        // Ensure the "Lock FOV" checkbox is checked by default in the DOM (if present)
        const lockBox = document.getElementById('lock-to-object');
        if (lockBox) lockBox.checked = true;
        const q = new URLSearchParams(location.search);
        if (q.has('rig') && (q.has('ra') || q.has('dec'))) {
            setTimeout(() => openFramingAssistant(), 0);
        }
        const dateEl = document.getElementById("date-display");
        if (dateEl && dateEl.innerText.includes("-")) {
            dateEl.innerText = formatDateISOtoEuropean(dateEl.innerText);
        }
        const dayInput = document.getElementById("day-select");
        const monthSelect = document.getElementById("month-select");
        const yearInput = document.getElementById("year-select");

        function updateDayLimit() {
            const year = parseInt(yearInput.value);
            const month = parseInt(monthSelect.value);
            const daysInMonth = new Date(year, month, 0).getDate();
            if (parseInt(dayInput.value) > daysInMonth) {
                dayInput.value = daysInMonth;
            }
            dayInput.max = daysInMonth;
        }

        monthSelect.addEventListener("change", updateDayLimit);
        yearInput.addEventListener("change", updateDayLimit);
        updateDayLimit();
        const framingModal = document.getElementById('framing-modal');
        window.addEventListener('click', function (event) {
            if (event.target == framingModal) {
                closeFramingAssistant();
            }
        });
        window.addEventListener('resize', () => {
            if (document.getElementById('framing-modal').style.display === 'block') {
                if (aladin) updateFramingChart(false);
            }
        });
        const ta = document.getElementById('project-field');
        if (ta) {
            const m = ta.value.match(/\bhttps?:\/\/[^\s<>"']+/g);
            if (m && m.length) setProjectQuickLink(m[m.length - 1]);
        }
    });
// Add "checked" attribute to the "Lock FOV" checkbox in the HTML
</script>

{# ... somewhere above, in the HTML for the framing modal, find the checkbox: #}
{# <input type="checkbox" id="lock-to-object" ...> #}
{# Change to: #}
{# <input type="checkbox" id="lock-to-object" checked> #}
{% endblock %}
