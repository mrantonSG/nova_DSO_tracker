{% extends "base.html" %}

{% block title %}Graph – Nova DSO Tracker{% endblock %}

{% block head_extra %}

<script src="https://aladin.cds.unistra.fr/AladinLite/api/v3/latest/aladin.js" charset="utf-8"></script>
<style>
    body {
        padding: 20px;
        margin: 0;
    }

    #back-button {
        margin-top: 0;
        padding: 10px 20px;
        font-size: 16px;
        background-color: #83b4c5;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    }

    #back-button:hover {
        background-color: #6795a4 !important;
    }

    #chart-section img {
        max-width: 100%;
        height: auto;
        border-radius: 5px;
        margin-bottom: 10px;
        margin-bottom: 20px;
    }

    #chart-section {
        margin-top: 20px;
        display: flex;
        flex-direction: column;
        gap: 15px;
    }

    .date-controls {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 10px;
        margin-bottom: 10px;
    }

    .date-controls label, .date-controls input, .date-controls select {
        font-size: 14px;
        padding: 4px;
    }

    .view-buttons {
        margin-top: 10px;
        display: flex;
        gap: 10px;
    }

    .view-button {
        background-color: #83b4c5;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        padding: 8px 16px;
        font-size: 14px;
    }

    .view-button:hover {
        background-color: #6795a4;
    }

    #project-field {
        width: 100%;
        max-width: 970px;
        height: 150px;
        box-sizing: border-box;
        font-size: 15px;
    }

    .inline-button {
        background-color: #83b4c5;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        padding: 10px 20px;
        font-size: 16px;
        margin-right: 10px;
    }

    .button-container {
        padding: 10px;
        margin-left: 50px;
    }

    .top-info-grid {
        display: flex;
        align-items: stretch;
        margin-bottom: 40px;
    }

    .info-button-column {
        flex-shrink: 0;
        padding-right: 15px;
        margin-right: 15px;
        border-right: 1px solid #ccc;

        display: flex;
        flex-direction: column;
        align-items: flex-start;
    }

    .info-details-column {
        display: flex;
        flex-direction: column;
        flex-grow: 1;
    }

    .primary-info-line .inline-button {
        margin-right: 15px;
        flex-shrink: 0;
    }

    .object-title-block-main {
        margin-bottom: 10px;
    }

    .object-common-name {
        font-size: 1.4em;
        font-weight: bold;
        color: #333;
    }

    .secondary-info-line-main {
        display: flex;
        flex-wrap: nowrap;
        gap: 20px;
        align-items: center;
    }

    .secondary-info-line-main small {
        font-size: 12px;
        color: #666;
    }

    .secondary-info-line-main p {
        margin: 0;
        font-size: 16px;
    }

    .secondary-info-line-main span {
        font-weight: bold;
        font-size: 16px;
        color: #000;
    }

    .object-title-block {
        flex-grow: 1;
    }

    .object-id-name {
        font-size: 1.2em;
        font-weight: bold;
        color: #555;
        margin-left: 4px;
    }

    .inline-button:hover {
        background-color: #6795a4 !important;
    }

    .content-section {
        margin-top: 25px;
        padding: 20px;
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        margin-bottom: 25px;
    }

    .content-section h3 {
        margin-top: 0;
        color: #343a40;
        border-bottom: 1px solid #ced4da;
        padding-bottom: 10px;
        font-size: 1.2em;
        font-weight: 600;
    }

    .sessions-history-list {
        list-style-type: none;
        padding-left: 0;
        max-height: 250px;
        overflow-y: auto;
        border: 1px solid #ced4da;
        border-radius: 4px;
        background-color: #fff;
        margin-top: 10px;
    }

    .sessions-history-list li {
        padding: 7px 10px;
        border-bottom: 1px dotted #e0e0e0;
        font-size: 0.85em;
    }

    .sessions-history-list li:last-child {
        border-bottom: none;
    }

    .sessions-history-list li a {
        text-decoration: none;
        color: #0056b3;
    }

    .sessions-history-list li a:hover {
        text-decoration: underline;
    }

    .sessions-history-list li.current-session-item {
        background-color: #cfe2ff;
        border-left: 3px solid #0056b3;
        padding-left: 7px;
    }

    .sessions-history-list li.current-session-item a {
        font-weight: bold;
    }

    .selected-session-details {
        margin-top: 15px;
        padding: 15px;
        background-color: #ffffff;
        border: 1px solid #bac8d3;
        border-radius: 4px;
        max-width: 770px;
    }

    .selected-session-details h4 {
        margin-top: 0;
        color: #2c3e50;
        font-size: 1.05em;
        font-weight: 600;
    }

    .selected-session-details p, .selected-session-details div {
        margin-bottom: 6px;
        font-size: 0.9em;
        line-height: 1.5;
    }

    .selected-session-details strong {
        color: #1c2833;
    }

    .action-button-group {
        display: flex;
        align-items: center;

        margin-top: 10px;
        margin-bottom: 10px;
    }

    .action-button-group .inline-button {
        margin-right: 8px;

        margin-bottom: 5px;
        font-size: 13px;
        padding: 6px 12px;
        text-decoration: none;
        box-sizing: border-box;
        display: inline-block;
        vertical-align: middle;
        line-height: 1.2;
    }

    hr.detail-separator {
        border: 0;
        height: 1px;
        background: #e0e0e0;
        margin: 10px 0;
    }

    #opportunities-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
        font-size: 14px;
        margin-left: 20px;
    }

    #opportunities-table th, #opportunities-table td {
        border: 1px solid #ccc;
        padding: 8px 12px;
        text-align: left;
    }

    #opportunities-table th {
        background-color: #83b4c5;
        color: white;
        font-weight: normal;
    }

    #opportunities-table tr:nth-child(even) {
        background-color: #f2f2f2;
    }

    #opportunities-table tr:hover {
        background-color: #e1f0f5;
    }

    #opportunities-section {
        margin-top: 40px;
    }

    .opportunities-heading {
        font-size: 16px;
        font-weight: normal;
        color: #333;
        margin-bottom: 10px;
        margin-left: 20px;
    }

    #opportunities-table th,
    #opportunities-table td {
        text-align: center !important;
        vertical-align: middle !important;
    }

    .highlight {
        background-color: #d6ecff !important;
    }

    code {
        background-color: #f5f5f5;
        padding: 2px 4px;
        border-radius: 4px;
        font-family: monospace;
    }

    .preserve-newlines {
        white-space: pre-wrap;
        margin-top: 4px;
        padding-left: 10px;
        border-left: 2px solid #eee;
    }


    .session-history-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
        font-size: 0.85em;
    }

    .session-history-table th, .session-history-table td {
        border: 1px solid #dde;
        padding: 6px 8px;
        text-align: left;
        vertical-align: middle;
    }

    .session-history-table th {
        background-color: #e9ecef;
        font-weight: 600;
    }

    .session-history-table tr.clickable-session-row:hover {
        background-color: #e6f7ff;
        cursor: pointer;
    }

    .session-history-table tr.current-session-item {
        background-color: #cfe2ff !important;
        font-weight: bold;
    }

    .session-history-table td.col-date, .session-history-table th.col-date {
        width: 120px;
    }

    .session-history-table td.col-location, .session-history-table th.col-location {
        width: 150px;
    }

    .session-history-table td.col-setup, .session-history-table th.col-setup {
        width: auto;
    }

    .session-history-table td.col-integ, .session-history-table th.col-integ {
        width: 100px;
        text-align: center;
    }

    .session-history-table td.col-rating, .session-history-table th.col-rating {
        width: 100px;
        text-align: center;
    }

    .selected-session-details .form-data-value {
        padding: 8px 10px;
        background-color: #e9ecef;
        border: 1px solid #ced4da;
        border-radius: 4px;
        min-height: 25px;
        word-wrap: break-word;
        font-size: 1.1em;
        line-height: 1.5;
    }


    .selected-session-details div.form-data-value.preserve-newlines {
        min-height: 80px;
        background-color: #fff;
        border: 1px dashed #ced4da;

    }

    div.form-data-value.preserve-newlines {
        min-height: 80px;
        background-color: #fff;
        border: 1px dashed #ced4da;
    }

    .form-group label {
        display: block;
        margin-bottom: 3px;
        font-weight: normal;
        font-size: 1em;
        color: #495057;
        width: 320px;


    }

    .form-group {
        margin-bottom: 10px;
    }

    .form-section-title {
        font-size: 1.1em;
        font-weight: bold;
        color: #333;
        margin-top: 20px;
        margin-bottom: 10px;
        border-bottom: 1px solid #eee;
        padding-bottom: 5px;
    }

    .form-row {
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
    }

    .form-row .form-group {
        flex: 1;
        min-width: 200px;
    }


    .framing-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 15px;
    }

    .framing-table th, .framing-table td {
        border: 1px solid #eee;
        padding: 10px;
        text-align: left;
        font-size: 14px;
    }

    .framing-table th {
        background-color: #f9f9f9;
        font-weight: 600;
    }

    .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.6);
    }

    .framing-controls {
        margin-bottom: 15px;
        display: flex;
        gap: 20px;
        align-items: center;
        color: black;
    }

    .framing-controls select, .framing-controls button {
        font-size: 14px;
        padding: 5px;
    }


    #aladin-lite-div .aladin-location,
    #aladin-lite-div .aladin-mouse-position {
        display: none !important;
    }


    .modal-header-bar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 12px 56px 6px 16px;
        border-bottom: 1px solid #83b4c5;
    }

    .brand-strong {
        font-weight: 800;
        letter-spacing: 0.2px;
        font-size: 20px;
    }

    .brand-light {
        font-weight: 400;
        margin-left: 6px;
        color: #555;
        font-size: 20px;
    }

    .fov-chip {
        font-size: 13px;
        color: #444;
        background: #f3f5f7;
        border: 1px solid #e2e6ea;
        border-radius: 999px;
        padding: 4px 10px;
        white-space: nowrap;
        margin-right: 48px;
    }

    .modal .close {
        position: absolute;
        top: 10px;
        right: 12px;
        z-index: 3;
        line-height: 1;
        font-size: 22px;
        color: #999;
    }

    .modal .close:hover {
        color: #666;
    }

    #framing-modal {
        position: fixed;
        inset: 0;
        display: none;
        background: rgba(0, 0, 0, 0.6);
        z-index: 1000;
    }


    #framing-modal-content {
        position: relative;
        margin: 4vh auto 6vh auto;
        width: clamp(320px, 70vw, 1200px);
        height: clamp(400px, 78vh, 900px);
        background: #fff;
        border-radius: 10px;
        box-shadow: 0 12px 32px rgba(0, 0, 0, 0.25);
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }

    #framing-header,
    #framing-toolbar {
        padding: 10px 16px;
    }

    #framing-toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 10px 14px;
        align-items: center;
        border-top: 1px solid #e9eef2;
        border-bottom: 1px solid #e9eef2;
    }


    #framing-body {
        flex: 1 1 auto;
        min-height: 240px;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        padding: 10px 16px 14px 16px;
    }

    #aladin-lite-div {
        flex: 1 1 auto;
        min-height: 200px;
        border-radius: 6px;
        overflow: hidden;
    }

    .framing-readout {
        display: flex;
        flex-wrap: wrap;
        gap: 8px 12px;
        align-items: center;
        margin: 8px 0 10px;
    }

    @media (max-width: 1280px) {
        #framing-modal-content {
            width: 96vw;
            height: 92vh;
            margin: 2vh auto;
        }

        #framing-toolbar, #framing-body {
            padding-left: 12px;
            padding-right: 12px;
        }

        #framing-toolbar {
            gap: 8px 10px;
        }
    }

    @media (max-width: 900px) {
        .framing-readout {
            gap: 6px 10px;
        }

        .inline-label {
            white-space: nowrap;
            font-size: 0.95rem;
        }
    }

    .framing-controls {
        padding-left: 16px;
        padding-right: 16px;
    }

    #framing-modal-content.fullscreen {
        width: 98vw !important;
        height: 96vh !important;
        margin: 2vh auto !important;
    }

    .fullscreen-btn {
        float: right;
        border: none;
        background: transparent;
        font-size: 1.3rem;
        cursor: pointer;
        margin-right: 10px;
    }

    .fullscreen-btn:hover {
        color: #0077aa;
    }

    .close {
        font-size: 1.4rem;
        cursor: pointer;
        color: #666;
    }

    .close:hover {
        color: #d00;
    }

    .modal-controls {
        position: absolute;
        top: 8px;
        right: 12px;
        z-index: 2;
        display: flex;
        gap: 10px;
        align-items: center;
        pointer-events: auto;
    }

    .fullscreen-btn,
    .close-btn {
        width: 28px;
        height: 28px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        line-height: 1;
        border: 0;
        border-radius: 6px;
        background: transparent;
        color: #444;
        cursor: pointer;
    }

    .close-btn:hover {
        color: #d22;
    }

    #chart-container {
        position: relative;
        width: 100%;
        max-width: 1000px;
        margin: auto;
        height: 55vh;
    }

    #altitudeChartCanvas {
        display: block;
        margin-left: 0;
    }

    .chart-container,
    .canvas-wrapper,
    #chart-container,
    #chart-area {
        position: relative;

    }

    #altitudeChartCanvas {
        display: block;
        width: 100%;
        height: 100%;
    }

    .loading-overlay.hidden {
        opacity: 0;
        visibility: hidden;
    }

    #chart-wrapper {
        width: 80%;
        max-width: 1100px;
        margin-left: 0;
    }

    #chart-area {
        position: relative;
    }

    #altitudeChartCanvas {
        display: block;
        width: 100% !important;
        height: auto !important;
    }

    .loading-overlay {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(255, 255, 255, 0.6);
        backdrop-filter: blur(2px);
        font: 600 18px/1.2 system-ui, sans-serif;
        color: #334;
        z-index: 2;
        opacity: 1;
        visibility: visible;
        transition: opacity 200ms ease, visibility 200ms ease;
    }

    /* Styles for the new tab navigation */
    .tab-container { display: flex; margin-bottom: 25px; border-bottom: 2px solid #ccc; }
    .tab-button { padding: 10px 20px; cursor: pointer; border: 1px solid #ccc; border-bottom: none; background-color: #e9e9e9; margin-right: 5px; border-radius: 5px 5px 0 0; font-size: 16px; }
    .tab-button.active { background-color: #fff; border-color: #ccc; border-bottom: 2px solid #fff; position: relative; top: 1px; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
</style>
{% endblock %}

{% block body %}

<div class="top-info-grid">
    <div class="info-button-column">
        <button class="inline-button" onclick='window.top.location.href="{{ url_for("index") }}"'>Back to Tracker</button>
    </div>
    <div class="info-details-column">
        <div class="object-title-block-main">
            <span class="object-common-name">{{ alt_name | default(object_name, True) }}</span>
            <span class="object-id-name">({{ object_name }})</span>
        </div>
        <div class="secondary-info-line-main">
            <p><small>Location:</small> <span id="location-display">{{ header_location_name }}</span></p>
            <p><small>Date (Graph):</small> <span id="date-display">{{ header_date_display }}</span></p>
            <p><small>Moon (for date):</small> <span id="phase-display">{{ header_moon_phase }}%</span></p>
            <p><small>Astro Dusk:</small> <span id="dusk-display">{{ header_astro_dusk }}</span></p>
            <p><small>Astro Dawn:</small> <span id="dawn-display">{{ header_astro_dawn }}</span></p>
        </div>
    </div>
</div>

<div class="tab-container">
    <button class="tab-button active" data-tab="chart" onclick="showTab('chart')">Chart</button>
    <button class="tab-button" data-tab="journal" onclick="showTab('journal')">Journal</button>
    <button class="tab-button" data-tab="framing" onclick="showTab('framing')">Framing & Notes</button>
</div>

<div id="chart-tab" class="tab-content active">
    <div id="chart-section">
        <div style="width: 80%; max-width: 1100px; margin-left: 0;">
            <div id="chart-area">
                <canvas id="altitudeChartCanvas"></canvas>
                <div id="chart-loading" class="loading-overlay">Loading chart...</div>
            </div>
            <div class="date-controls" style="margin-top: 20px; padding-left: 20px; box-sizing: border-box;">
                <label for="day-select">Day:</label>
                <input type="number" id="day-select" value="{{ selected_day }}" min="1" max="31" style="width:60px;"/>
                <label for="month-select">Month:</label>
                <select id="month-select">
                    {% for m in range(1, 13) %}
                    <option value="{{ m }}" {% if m== selected_month|int %}selected{% endif %}>{{ '%02d' % m }}</option>
                    {% endfor %}
                </select>
                <label for="year-select">Year:</label>
                <input type="number" id="year-select" value="{{ selected_year }}" style="width:70px;"/>
                <button class="view-button" data-view="day" onclick="changeView('day')">Day View</button>
                <button class="view-button" data-view="month" onclick="changeView('month')">Month View</button>
                <button class="view-button" data-view="year" onclick="changeView('year')">Year View</button>
            </div>
        </div>
    </div>
</div>

<div id="journal-tab" class="tab-content">
    <div class="content-section">
        {% include '_journal_section.html' %}
    </div>
</div>

<div id="framing-tab" class="tab-content">
    {% if available_rigs and object_main_details.Size and object_main_details.Size != "N/A" %}
    <div class="content-section">
        <h3>Framing With Your Rigs</h3>
        <p style="font-size:13px; color: #666; margin-top: -8px;"><em>Assessment is based on the object's largest dimension and may not reflect framing of specific features.</em></p>
        <table class="framing-table">
            <thead>
            <tr>
                <th>Rig Name</th>
                <th>Rig FOV</th>
                <th>Object Size</th>
                <th>Fit Assessment</th>
            </tr>
            </thead>
            <tbody>
            {% set object_size = object_main_details.Size | float %}
            {% for rig in available_rigs %}
            {% if rig.fov_w_arcmin and rig.fov_h_arcmin %}
            {% set fov_max = [rig.fov_w_arcmin, rig.fov_h_arcmin] | max %}
            {% set fov_min = [rig.fov_w_arcmin, rig.fov_h_arcmin] | min %}
            {% if object_size > fov_max %}{% set fit_text = "Mosaic Required" %}{% set fit_color = "#e74c3c" %}
            {% elif object_size > fov_min %}{% set fit_text = "Fits with Rotation" %}{% set fit_color = "#f39c12" %}
            {% else %}{% set fit_ratio = (object_size / fov_min) * 100 %}
            {% if fit_ratio < 5 %}{% set fit_text = "Small Target" %}{% set fit_color = "#9b59b6" %}
            {% elif fit_ratio < 20 %}{% set fit_text = "Wide Field" %}{% set fit_color = "#3498db" %}
            {% else %}{% set fit_text = "Good Fit" %}{% set fit_color = "#2ecc71" %}{% endif %}{% endif %}
            <tr>
                <td><strong>{{ rig.rig_name }}</strong></td>
                <td>{{ rig.fov_w_arcmin | round(1) }}' x {{ rig.fov_h_arcmin | round(1) }}'</td>
                <td>{{ object_size }}'</td>
                <td style="color: {{ fit_color }}; font-weight: bold;">{{ fit_text }}</td>
            </tr>
            {% endif %}{% endfor %}
            </tbody>
        </table>
    </div>
    {% endif %}

    <div class="content-section project-notes-section">
        <h3>Project Notes</h3>
        <textarea id="project-field" name="project_notes_from_config"
                  title="General notes for this object from your main configuration. Editable on the Configuration page.">{{ project_notes_from_config }}</textarea>
        <div id="project-quick-link" style="margin:6px 0 12px; font-size:14px; color:#333;"></div>
        <div class="button-group">
            <button class="inline-button" onclick="saveProject()">Save Project Notes</button>
            <button class="inline-button" onclick="openFramingAssistant()">Show Framing</button>
            <button class="inline-button" onclick="toggleSimbad()">Toggle SIMBAD Info</button>
            <button class="inline-button" onclick="loadImagingOpportunities()">Find Imaging Opportunities</button>
            <button id="open-in-stellarium" class="inline-button" onclick="openInStellarium()">Open in Stellarium</button>
        </div>
        <div id="stellarium-status" style="margin-top: 10px; color: #666;"></div>
    </div>
</div>

<div id="simbadContainer" style="display:none; margin-top:20px;">
    <iframe id="simbadIframe" style="width:100%; height:1200px; border:1px solid #ddd;"></iframe>
</div>

<div id="opportunities-section" style="display: none; max-width: 800px; margin-top: 30px;">
    <div class="opportunities-heading">Imaging Opportunities:<br><small>Note: The star rating does not differentiate
        whether the moon is above or below the horizon.</small></div>
    <table id="opportunities-table" class="opportunity-table center-text">
        <thead>
        <tr>
            <th>Date</th><th>From</th><th>To</th><th>Obs Duration (min)</th><th>Max Alt (°)</th>
            <th>Moon Illum (%)</th><th>Ang Sep (°)</th><th>Rating</th><th>Add to Cal</th>
        </tr>
        </thead>
        <tbody id="opportunities-body"></tbody>
    </table>
</div>

<div id="framing-modal" class="modal">
    <div id="framing-modal-content">
        <div class="modal-controls">
            <button type="button" class="fullscreen-btn" aria-label="Toggle fullscreen" title="Fullscreen" onclick="toggleFramingFullscreen(this)">⤢</button>
            <button type="button" class="close-btn" aria-label="Close" title="Close" onclick="closeFramingAssistant()">×</button>
        </div>
        <div class="modal-header-bar">
            <div class="brand"><span class="brand-strong">Nova</span><span class="brand-light">DSO Tracker</span></div>
            <span id="fov-vs-object" class="fov-chip"></span>
        </div>
        <div class="framing-controls" style="align-items:center; gap:10px; padding-top:4px;">
            <label style="display:flex;align-items:center;gap:6px;"><input type="checkbox" id="lock-to-object" onchange="applyLockToObject(this.checked)" checked> Lock FOV</label>
            <button class="inline-button" style="padding:6px 10px;font-size:13px;" onclick="flipFraming90()">Flip 90°</button>
            <button class="inline-button" style="padding:6px 10px;font-size:13px;" onclick="copyFramingUrl()">Copy framing URL</button>
            <button id="insert-into-project" type="button" class="inline-button" style="padding:6px 10px;font-size:13px;" onclick="insertFramingIntoProject()">Insert into Project</button>
        </div>
        <div class="framing-controls">
            <div>
                <label for="framing-rig-select">Select Rig:</label>
                <select id="framing-rig-select" onchange="updateFramingChart(true); updateFovVsObjectLabel();">
                    {% if available_rigs %}{% for rig in available_rigs %}
                    <option value="{{ rig.rig_id }}" data-fovw="{{ rig.fov_w_arcmin }}" data-fovh="{{ rig.fov_h_arcmin }}">{{ rig.rig_name }}</option>
                    {% endfor %}{% else %}<option value="">No rigs configured</option>{% endif %}
                </select>
            </div>
            <div>
              <label for="framing-rotation">Rotation:</label>
              <input type="range" id="framing-rotation" min="-90" max="90" value="0" step="0.5" oninput="onRotationInput(this.value)" onchange="onRotationInput(this.value)"/>
              <span id="rotation-value">0°</span>
            </div>
            <div>
                <label for="survey-select">Survey:</label>
                <select id="survey-select" onchange="setSurvey(this.value)">
                    <option value="P/DSS2/color">DSS2 (color)</option><option value="P/allWISE/color">AllWISE (color)</option><option value="P/2MASS/color">2MASS (color)</option>
                    <option value="P/GALEXGR6/AIS/color">GALEX (color)</option><option value="P/PanSTARRS/DR1/color-z-zg-g">Pan-STARRS (color)</option>
                    <option value="CDS/P/SHASSA">SHASSA Hα</option><option value="P/SDSS9/color">SDSS9 (color)</option>
                </select>
                <span style="margin-left:18px;">Blend with:</span>
                <select id="blend-survey-select" style="margin-left:6px;">
                    <option value="P/DSS2/color" selected>DSS2 (color)</option><option value="P/DSS2/red">DSS2 (red)</option><option value="P/DSS2/blue">DSS2 (blue)</option>
                    <option value="P/2MASS/color">2MASS (color)</option><option value="P/allWISE/color">WISE (color)</option><option value="P/SDSS9/color">SDSS (color)</option>
                    <option value="P/GALEXGR6/AIS/color">GALEX (color)</option>
                </select>
                <input id="blend-opacity" type="range" min="0" max="1" step="0.01" value="0" title="Blend opacity" style="width:130px; vertical-align:middle; margin-left:8px;">
            </div>
        </div>
        <div class="framing-controls" style="flex-wrap: wrap;">
            <div><label>Brightness</label><input type="range" id="img-bright" min="-1" max="1" step="0.01" value="0" oninput="updateImageAdjustments()"></div>
            <div><label>Contrast</label><input type="range" id="img-contrast" min="-1" max="1" step="0.01" value="0" oninput="updateImageAdjustments()"></div>
            <div><label>Gamma</label><input type="range" id="img-gamma" min="0.1" max="10" step="0.1" value="1" oninput="updateImageAdjustments()"></div>
            <div><label>Saturation</label><input type="range" id="img-sat" min="-1" max="1" step="0.01" value="0" oninput="updateImageAdjustments()"></div>
            <div style="display:flex; align-items:center; gap:6px;">
                <label>RA</label><input id="ra-readout" type="text" style="width:160px;" readonly>
                <label>Dec</label><input id="dec-readout" type="text" style="width:160px;" readonly>
                <button class="inline-button" style="padding:6px 10px; font-size:13px;" onclick="copyRaDec()">Copy</button>
            </div>
            <div style="display:flex; align-items:center; gap:6px;">
                <span style="font-size:12px;color:#555;">Tip: Click on the sky to move the FOV center.</span>
                <button class="inline-button" style="padding:6px 10px; font-size:13px;" onclick="resetFovCenterToObject()">Recenter to object</button>
                <div style="display:flex; align-items:center; gap:4px;">
                    <button class="inline-button" style="padding:4px 8px;" title="Nudge Up" onclick="nudgeFov(0, +1)">↑</button>
                    <div>
                        <button class="inline-button" style="padding:4px 8px;" title="Nudge Left" onclick="nudgeFov(-1, 0)">←</button>
                        <button class="inline-button" style="padding:4px 8px;" title="Nudge Right" onclick="nudgeFov(+1, 0)">→</button>
                    </div>
                    <button class="inline-button" style="padding:4px 8px;" title="Nudge Down" onclick="nudgeFov(0, -1)">↓</button>
                    <span style="font-size:12px;color:#555;">(1′ steps)</span>
                </div>
            </div>
        </div>
        <div id="aladin-lite-div"></div>
    </div>
</div>

<script src="{{ url_for('static', filename='js/chart/chart.umd.min.js') }}"></script>
<script src="{{ url_for('static', filename='js/chart/luxon.min.js') }}"></script>
<script src="{{ url_for('static', filename='js/chart/chartjs-adapter-luxon.umd.min.js') }}"></script>
<script src="{{ url_for('static', filename='js/chart/chartjs-plugin-annotation.min.js') }}"></script>
<script>
    // --- NEW: Tab Management Function ---
    function showTab(tabName) {
        document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
        document.querySelectorAll('.tab-button').forEach(button => button.classList.remove('active'));
        document.getElementById(tabName + '-tab').classList.add('active');
        document.querySelector(`.tab-button[data-tab="${tabName}"]`).classList.add('active');
        localStorage.setItem('activeGraphTab', tabName);
    }

    const plotTz = "{{ graph_tz_name_param | default('UTC', true) }}";
    Chart.defaults.adapters = Chart.defaults.adapters || {};
    Chart.defaults.adapters.date = {
        ...(Chart.defaults.adapters.date || {}),
        zone: plotTz
    };
    console.log('Adapter:', Chart._adapters?._date?.id, 'Zone:', Chart.defaults.adapters.date.zone);

    const OBJECT_SIZE_ARCMIN = null;
    let aladin = null;
    let fovLayer = null;
    let altitudeChart = null;

    function getDateTimeMs(baseDateISO, timeStr) {
        if (!timeStr || !timeStr.includes(':')) return null;
        const [hour, minute] = timeStr.split(':').map(Number);
        const base = luxon.DateTime.fromISO(baseDateISO, {zone: plotTz}).startOf('day');
        return base.set({hour, minute, second: 0, millisecond: 0}).toMillis();
    }

    async function renderClientSideChart() {
        const chartLoadingDiv = document.getElementById('chart-loading');
        chartLoadingDiv?.classList.remove('hidden');
        const objectName = "{{ object_name }}";
        const day = document.getElementById('day-select').value;
        const month = document.getElementById('month-select').value;
        const year = document.getElementById('year-select').value;
        const plotLat = "{{ graph_lat_param | default('', True) }}";
        const plotLon = "{{ graph_lon_param | default('', True) }}";
        const plotTz = "{{ graph_tz_name_param | default('', True) }}";
        const plotLocName = "{{ graph_location_name_param | default('', True) }}";
        const apiUrl = `/api/get_plot_data/${encodeURIComponent(objectName)}?day=${day}&month=${month}&year=${year}&plot_lat=${plotLat}&plot_lon=${plotLon}&plot_tz=${encodeURIComponent(plotTz)}&plot_loc_name=${encodeURIComponent(plotLocName)}`;
        console.log("Fetching Chart Data from API URL:", apiUrl);

        try {
            const resp = await fetch(apiUrl);
            if (!resp.ok) throw new Error(`Failed to fetch chart data: ${resp.status} ${resp.statusText}`);
            const data = await resp.json();
            function toMs(val) {
                if (typeof val === 'number') return (val < 1e12 ? val * 1000 : val);
                if (typeof val === 'string') {
                    const hasOffset = /[Zz]|[+\-]\d{2}:?\d{2}$/.test(val);
                    if (hasOffset) return luxon.DateTime.fromISO(val).setZone(plotTz).toMillis();
                    else return luxon.DateTime.fromISO(val, {zone: plotTz}).toMillis();
                }
                return null;
            }
            const labels = data.times.map(toMs);
            const annotations = {};
            const baseDt = luxon.DateTime.fromISO(data.date, {zone: plotTz});
            const nextDt = baseDt.plus({days: 1});
            const cloudInfo = { 1: {label: 'Clear', color: 'rgba(135, 206, 250, 0.0)'}, 2: {label: 'Clear', color: 'rgba(135, 206, 250, 0.05)'}, 3: {label: 'P/Clear', color: 'rgba(170, 170, 170, 0.1)'}, 4: {label: 'P/Clear', color: 'rgba(170, 170, 170, 0.15)'}, 5: {label: 'P/Cloudy', color: 'rgba(120, 120, 120, 0.2)'}, 6: {label: 'P/Cloudy', color: 'rgba(120, 120, 120, 0.25)'}, 7: {label: 'Cloudy', color: 'rgba(80, 80, 80, 0.3)'}, 8: {label: 'Cloudy', color: 'rgba(80, 80, 80, 0.35)'}, 9: {label: 'Overcast', color: 'rgba(50, 50, 50, 0.4)'} };
            const seeingInfo = { 1: {label: 'Seeing: Exc.', color: 'rgba(0, 255, 127, 0.15)'}, 2: {label: 'Seeing: Good', color: 'rgba(0, 255, 127, 0.2)'}, 3: {label: 'Seeing: Good', color: 'rgba(173, 255, 47, 0.2)'}, 4: {label: 'Seeing: Avg.', color: 'rgba(255, 255, 0, 0.2)'}, 5: {label: 'Seeing: Avg.', color: 'rgba(255, 215, 0, 0.2)'}, 6: {label: 'Seeing: Poor', color: 'rgba(255, 165, 0, 0.2)'}, 7: {label: 'Seeing: Poor', color: 'rgba(255, 69, 0, 0.2)'}, 8: {label: 'Seeing: Bad', color: 'rgba(255, 0, 0, 0.2)'} };
            if (data.weather_forecast && data.weather_forecast.length > 0) {
                data.weather_forecast.forEach((block, index) => {
                    annotations[`cloud_block_${index}`] = { type: 'box', xMin: block.start, xMax: block.end, yMin: 95, yMax: 100, backgroundColor: cloudInfo[block.cloudcover]?.color || 'rgba(0,0,0,0.1)', borderColor: 'transparent', borderWidth: 0, label: { display: true, content: cloudInfo[block.cloudcover]?.label || 'Cloudy', position: 'center', font: { size: 10 }, color: '#444' } };
                    if (block.seeing) annotations[`seeing_block_${index}`] = { type: 'box', xMin: block.start, xMax: block.end, yMin: 90, yMax: 95, backgroundColor: seeingInfo[block.seeing]?.color || 'rgba(0,0,0,0.1)', borderColor: 'transparent', borderWidth: 0, label: { display: true, content: seeingInfo[block.seeing]?.label || 'Seeing: N/A', position: 'center', font: {size: 10}, color: '#444' } };
                });
            }
            function wallTimeMs(baseDateTime, timeStr) {
                if (!timeStr || !timeStr.includes(':')) return null;
                const [h, m] = timeStr.split(':').map(Number);
                return baseDateTime.set({hour: h, minute: m, second: 0, millisecond: 0}).toMillis();
            }
            const sunsetTimeCurrent = wallTimeMs(baseDt, data.sun_events.current.sunset);
            let duskTime;
            const duskTimeCurrent = wallTimeMs(baseDt, data.sun_events.current.astronomical_dusk);
            if (duskTimeCurrent && sunsetTimeCurrent && duskTimeCurrent < sunsetTimeCurrent) duskTime = wallTimeMs(nextDt, data.sun_events.current.astronomical_dusk);
            else duskTime = duskTimeCurrent;
            const dawnTime = wallTimeMs(nextDt, data.sun_events.next.astronomical_dawn);
            const sunriseTime = wallTimeMs(nextDt, data.sun_events.next.sunrise);
            const sunsetTime = sunsetTimeCurrent;
            const firstMs = labels[0], lastMs = labels[labels.length - 1], originalWindowMs = lastMs - firstMs, midnightMs = luxon.DateTime.fromISO(data.date, {zone: plotTz}).plus({days: 1}).startOf('day').toMillis();
            const currentCenterMs = (firstMs + lastMs) / 2, delta = midnightMs - currentCenterMs, xMinCentered = firstMs + delta, xMaxCentered = xMinCentered + originalWindowMs;
            if (sunsetTime) annotations.sunsetLine = { type: 'line', xMin: sunsetTime, xMax: sunsetTime, borderColor: 'black', borderWidth: 1, label: { display: true, content: 'Sunset', position: 'start', rotation: 90, font: {size: 10, weight: '400'}, color: '#222', backgroundColor: 'rgba(255,255,255,0.92)', borderColor: 'rgba(0,0,0,0.15)', borderWidth: 1 } };
            if (duskTime) annotations.duskLine = { type: 'line', xMin: duskTime, xMax: duskTime, borderColor: 'black', borderWidth: 1, label: { display: true, content: 'Astronomical dusk', position: 'start', rotation: 90, font: {size: 10, weight: '400'}, color: '#222', backgroundColor: 'rgba(255,255,255,0.92)', borderColor: 'rgba(0,0,0,0.15)', borderWidth: 1 } };
            if (dawnTime) annotations.dawnLine = { type: 'line', xMin: dawnTime, xMax: dawnTime, borderColor: 'black', borderWidth: 1, label: { display: true, content: 'Astronomical dawn', position: 'start', rotation: 90, font: {size: 10, weight: '400'}, color: '#222', backgroundColor: 'rgba(255,255,255,0.92)', borderColor: 'rgba(0,0,0,0.15)', borderWidth: 1 } };
            if (sunriseTime) annotations.sunriseLine = { type: 'line', xMin: sunriseTime, xMax: sunriseTime, borderColor: 'black', borderWidth: 1, label: { display: true, content: 'Sunrise', position: 'start', rotation: 90, font: {size: 10, weight: '400'}, color: '#222', backgroundColor: 'rgba(255,255,255,0.92)', borderColor: 'rgba(0,0,0,0.15)', borderWidth: 1 } };
            if (data.transit_time && data.transit_time !== "N/A") {
                const parts = (data.transit_time || '').split(':'), th = Number(parts[0] || 0), tm = Number(parts[1] || 0);
                const t0 = baseDt.set({hour: th, minute: tm, second: 0, millisecond: 0}).toMillis(), t1 = baseDt.plus({days: 1}).set({hour: th, minute: tm, second: 0, millisecond: 0}).toMillis();
                const nightStart = duskTime, nightEnd = dawnTime, inWindow = (t) => t >= nightStart && t <= nightEnd;
                const transitMs = inWindow(t0) ? t0 : inWindow(t1) ? t1 : (Math.abs(t0 - midnightMs) < Math.abs(t1 - midnightMs) ? t0 : t1);
                annotations.transitLine = { type: 'line', xMin: transitMs, xMax: transitMs, borderColor: 'crimson', borderWidth: 2, borderDash: [6, 6], clip: false, label: { display: true, content: data.transit_time, position: 'start', rotation: 90, font: {size: 10, weight: 'bold'}, color: 'crimson', backgroundColor: 'rgba(255,255,255,0.7)' } };
            }
            const nightShade = { id: 'nightShade', beforeDraw(chart) { const {ctx, chartArea, scales} = chart; if (!chartArea) return; const left = scales.x.getPixelForValue(scales.x.min), right = scales.x.getPixelForValue(scales.x.max); const duskPx = duskTime ? scales.x.getPixelForValue(duskTime) : right, dawnPx = dawnTime ? scales.x.getPixelForValue(dawnTime) : left; ctx.save(); ctx.fillStyle = 'rgba(211, 211, 211, 1)'; if (duskPx < dawnPx) { if (duskPx > left) ctx.fillRect(left, chartArea.top, duskPx - left, chartArea.height); if (dawnPx < right) ctx.fillRect(dawnPx, chartArea.top, right - dawnPx, chartArea.height); } else ctx.fillRect(left, chartArea.top, right - left, chartArea.height); ctx.restore(); } };
            const ctx = document.getElementById('altitudeChartCanvas').getContext('2d');
            if (window.altitudeChart) window.altitudeChart.destroy();
            window.altitudeChart = new Chart(ctx, { type: 'line', data: { labels, datasets: [ { label: '{{ object_name }} Altitude', data: data.object_alt, borderColor: '#36A2EB', yAxisID: 'yAltitude', borderWidth: 4, pointRadius: 0, tension: 0.1 }, { label: 'Moon Altitude', data: data.moon_alt, borderColor: '#FFC107', yAxisID: 'yAltitude', borderWidth: 4, pointRadius: 0, tension: 0.1 }, { label: 'Horizon Mask', data: data.horizon_mask_alt, borderColor: '#636e72', backgroundColor: 'rgba(99, 110, 114, 0.3)', yAxisID: 'yAltitude', borderWidth: 2, pointRadius: 0, tension: 0.1, fill: 'start' }, { label: 'Horizon', data: Array(labels.length).fill(0), borderColor: 'black', yAxisID: 'yAltitude', borderWidth: 2, pointRadius: 0 }, { label: '{{ object_name }} Azimuth', data: data.object_az, borderColor: '#36A2EB', yAxisID: 'yAzimuth', borderDash: [5, 5], borderWidth: 3.5, pointRadius: 0, tension: 0.1 }, { label: 'Moon Azimuth', data: data.moon_az, borderColor: '#FFC107', yAxisID: 'yAzimuth', borderDash: [5, 5], borderWidth: 3.5, pointRadius: 0, tension: 0.1 } ] }, plugins: [nightShade], options: { responsive: true, maintainAspectRatio: true, aspectRatio: 2, adapters: {date: {zone: plotTz}}, plugins: { annotation: {annotations}, legend: {position: 'right'}, title: { display: false, text: `Altitude and Azimuth for {{ alt_name }} on ${data.date}`, align: 'start', font: {size: 16} } }, scales: { x: { type: 'time', adapters: { date: { zone: plotTz }}, parsing: false, time: {unit: 'hour', displayFormats: {hour: 'HH:mm'}}, min: xMinCentered, max: xMaxCentered, bounds: 'ticks', ticks: {source: 'auto'}, grid: {color: 'rgba(128,128,128,0.5)', borderDash: [2, 2]}, title: {display: true, text: `Time (Local - {{ header_location_name }})`} }, yAltitude: { position: 'left', min: -90, max: 100, title: {display: true, text: 'Altitude (°)'}, grid: {color: 'rgba(128,128,128,0.5)', borderDash: [2, 2]} }, yAzimuth: { position: 'right', min: 0, max: 360, title: {display: true, text: 'Azimuth (°)'}, grid: {drawOnChartArea: false} } } } });
        } catch (err) {
            console.error('Could not render chart:', err);
            const canvas = document.getElementById('altitudeChartCanvas'), ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = '16px Arial'; ctx.fillStyle = 'red'; ctx.textAlign = 'center'; ctx.fillText('Error: Could not load chart data.', canvas.width / 2, canvas.height / 2);
        } finally { chartLoadingDiv?.classList.add('hidden'); }
    }

    async function renderMonthlyYearlyChart(view) {
        const chartLoadingDiv = document.getElementById('chart-loading');
        chartLoadingDiv?.classList.remove('hidden');
        const objectName = "{{ object_name }}", selMonth = document.getElementById('month-select').value, year = document.getElementById('year-select').value, plotLat = "{{ graph_lat_param | default('', True) }}", plotLon = "{{ graph_lon_param | default('', True) }}", plotTz = "{{ graph_tz_name_param | default('UTC', true) }}";
        let titleText, objAlt = [], moonAlt = [], horizon = [];
        try {
            if (view === 'year') {
                titleText = `Yearly Altitude at Local Midnight for {{ alt_name }} - ${year}`;
                const months = [...Array(12)].map((_, i) => String(i + 1).padStart(2, '0'));
                const urls = months.map(m => `/api/get_monthly_plot_data/${encodeURIComponent(objectName)}?year=${year}&month=${m}&plot_lat=${plotLat}&plot_lon=${plotLon}&plot_tz=${encodeURIComponent(plotTz)}`);
                const responses = await Promise.all(urls.map(u => fetch(u)));
                const bad = responses.find(r => !r.ok);
                if (bad) throw new Error(`HTTP ${bad.status} for ${bad.url}`);
                const monthly = await Promise.all(responses.map(r => r.json()));
                monthly.forEach(block => { block.dates.forEach((d, i) => { const t = `${d}T00:00:00`; objAlt.push({x: t, y: block.object_alt[i]}); moonAlt.push({x: t, y: block.moon_alt[i]}); horizon.push({x: t, y: 0}); }); });
            } else {
                titleText = `Monthly Altitude at Local Midnight for {{ alt_name }} - ${year}-${selMonth}`;
                const apiUrl = `/api/get_monthly_plot_data/${encodeURIComponent(objectName)}?year=${year}&month=${selMonth}&plot_lat=${plotLat}&plot_lon=${plotLon}&plot_tz=${encodeURIComponent(plotTz)}`;
                const resp = await fetch(apiUrl);
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                const data = await resp.json();
                data.dates.forEach((d, i) => { const t = `${d}T00:00:00`; objAlt.push({x: t, y: data.object_alt[i]}); moonAlt.push({x: t, y: data.moon_alt[i]}); horizon.push({x: t, y: 0}); });
            }
            const ctx = document.getElementById('altitudeChartCanvas').getContext('2d');
            if (window.altitudeChart) window.altitudeChart.destroy();
            window.altitudeChart = new Chart(ctx, { type: 'line', data: { datasets: [ { label: '{{ object_name }} Altitude', data: objAlt, borderColor: '#36A2EB', borderWidth: 3, pointRadius: 0, tension: 0.2 }, { label: 'Moon Altitude', data: moonAlt, borderColor: 'gold', borderWidth: 2.5, pointRadius: 0, tension: 0.0 }, {label: 'Horizon', data: horizon, borderColor: 'black', borderWidth: 2, pointRadius: 0} ] }, options: { adapters: {date: {zone: plotTz}}, responsive: true, maintainAspectRatio: true, aspectRatio: 2, scales: { x: { type: 'time', time: { unit: (view === 'year') ? 'month' : 'day', displayFormats: (view === 'year') ? {month: 'MMM'} : {day: 'dd'} }, title: { display: true, text: (view === 'year') ? `Month of ${year}` : `Day of ${year}-${selMonth}` } }, y: { min: -90, max: 90, title: {display: true, text: 'Altitude (°)'} } }, plugins: { legend: {position: 'top'}, title: {display: false, text: titleText, align: 'start', font: {size: 16}} } } });
        } catch (err) {
            console.error(`Could not render ${view} chart:`, err);
            const canvas = document.getElementById('altitudeChartCanvas');
            if (canvas) { const c = canvas.getContext('2d'); c.clearRect(0, 0, canvas.width, canvas.height); c.font = "16px Arial"; c.fillStyle = "red"; c.textAlign = "center"; c.fillText(`Error loading ${view} chart data.`, canvas.width / 2, canvas.height / 2); }
        } finally { chartLoadingDiv?.classList.add('hidden'); }
    }

    let baseSurvey = null;
    let blendLayer = null;
    let fovCenter = null;
    let lockToObject = false;
    let objectCoords = null;
    function to360(deg) { return ((deg % 360) + 360) % 360; }
    function toSigned180(deg) { const d = to360(deg); return d > 180 ? d - 360 : d; }
    let __pendingRotation = null;
    let __rafRotation = null;
    function scheduleRotationUpdate(deg) {
        __pendingRotation = Number(deg);
        if (__rafRotation) return;
        __rafRotation = requestAnimationFrame(() => {
            const val = __pendingRotation;
            __pendingRotation = null; __rafRotation = null;
            const rotation = Math.max(-90, Math.min(90, Number(val) || 0));
            if (typeof lockToObject !== 'undefined' && lockToObject) {
                const sel = document.getElementById('framing-rig-select');
                if (sel && sel.selectedIndex >= 0) { const opt = sel.options[sel.selectedIndex]; updateScreenFovOverlay(opt.dataset.fovw, opt.dataset.fovh, rotation); }
            }
            if (typeof window.updateFramingChart === 'function') window.updateFramingChart(false);
        });
    }
    function onRotationInput(val) {
        const v = Math.max(-90, Math.min(90, Number(val) || 0));
        const span = document.getElementById('rotation-value');
        if (span) span.textContent = v.toFixed(1).replace(/\.0$/, '') + '°';
        scheduleRotationUpdate(v);
    }
    function toggleFramingFullscreen(btn) {
        const modalContent = document.getElementById('framing-modal-content');
        if (!modalContent) return;
        modalContent.classList.toggle('fullscreen');
        const isFullscreen = modalContent.classList.contains('fullscreen');
        if (btn) { btn.innerHTML = isFullscreen ? '&#x21F2;' : '&#x2922;'; btn.title = isFullscreen ? 'Exit fullscreen' : 'Fullscreen'; }
    }
    function setProjectQuickLink(url) {
        const container = document.getElementById('project-quick-link');
        if (!container) return;
        container.innerHTML = '';
        if (url) {
            const btn = document.createElement('button');
            btn.className = 'inline-button';
            btn.style.fontSize = '13px';
            btn.style.padding = '6px 12px';
            btn.textContent = 'Re-open Last Saved Framing';
            btn.onclick = () => {
                try {
                    const u = new URL(url, location.origin);
                    const qNow = new URLSearchParams(buildFramingQuery().slice(1));
                    qNow.forEach((v, k) => u.searchParams.set(k, v));
                    history.pushState(null, '', u.pathname + '?' + u.searchParams.toString());
                } catch (e) { history.pushState(null, '', url); }
                openFramingAssistant();
            };
            container.appendChild(btn);
        }
    }
    function openFramingAssistant() {
        const framingModal = document.getElementById('framing-modal');
        const framingRigSelect = document.getElementById('framing-rig-select');
        if (framingRigSelect.options.length === 0 || framingRigSelect.value === "") { alert("Please configure at least one rig on the Configuration page first."); return; }
        framingModal.style.display = 'block';
        (function ensureRotationReadout(){ const slider = document.getElementById('framing-rotation'); if (!slider) return; slider.setAttribute('min', '-90'); slider.setAttribute('max', '90'); slider.setAttribute('step', '0.5'); if (!slider.hasAttribute('value')) slider.setAttribute('value', '0'); let n = slider.nextSibling; while (n && n.nodeType === Node.TEXT_NODE) { const t = n.textContent.trim(), next = n.nextSibling; if (t === '' || t === '0°') n.parentNode.removeChild(n); else break; n = next; } const existingSpans = Array.from(document.querySelectorAll('#rotation-value')); let span = existingSpans[0]; if (existingSpans.length > 1) existingSpans.slice(1).forEach(el => el.remove()); if (!span) { span = document.createElement('span'); span.id = 'rotation-value'; span.style.marginLeft = '8px'; span.style.fontWeight = 'normal'; span.style.fontSize = '15px'; slider.insertAdjacentElement('afterend', span); try { span.style.fontWeight = 'normal'; } catch(_) {} } try { span.style.cursor = 'pointer'; span.title = 'Tap to reset rotation to 0°'; span.addEventListener('click', () => { const slider = document.getElementById('framing-rotation'); if (!slider) return; slider.value = '0'; slider.dispatchEvent(new Event('input', { bubbles: true })); }, { once: false }); } catch (e) {} })();
        if (!aladin) {
            aladin = A.aladin('#aladin-lite-div', { survey: "P/DSS2/color", fov: 1.5, cooFrame: 'ICRS', showFullscreenControl: false, showGotoControl: false });
            (function installSlowWheelZoom(){ if (window.__novaSlowZoomInstalled) return; const host = document.getElementById('aladin-lite-div'); if (!host) return; try { host.style.overscrollBehavior = 'contain'; } catch(e) {} function onWheel(ev) { if (ev.ctrlKey) return; ev.preventDefault(); ev.stopPropagation(); if (!aladin) return; const unit = (ev.deltaMode === 1) ? 16 : (ev.deltaMode === 2) ? 400 : 1; let dy = (ev.deltaY || 0) * unit; dy = Math.max(-80, Math.min(80, dy)); const g = aladin.getFov(), current = Array.isArray(g) ? (g[0] ?? 1) : (g ?? 1); const scale = Math.exp(dy * 0.00075), minFov = 0.01, maxFov = 180; const next = Math.min(maxFov, Math.max(minFov, current * scale)); if (Number.isFinite(next)) aladin.setFov(next); } host.addEventListener('wheel', onWheel, { passive: false, capture: true }); const tryBindCanvas = () => { const cv = host.querySelector('canvas'); if (cv) cv.addEventListener('wheel', onWheel, { passive: false, capture: true }); }; tryBindCanvas(); setTimeout(tryBindCanvas, 50); window.__novaSlowZoomInstalled = true; })();
            baseSurvey = aladin.getBaseImageLayer();
            let __blendSurveyId = null;
            function ensureBlendLayer() { if (!aladin) return null; const sel = document.getElementById('blend-survey-select'); if (!sel) return null; const surveyId = sel.value; const existing = aladin.getOverlayImageLayer && aladin.getOverlayImageLayer('blend'); if (existing && __blendSurveyId === surveyId) return existing; try { const hpx = (aladin.newImageSurvey) ? aladin.newImageSurvey(surveyId) : aladin.createImageSurvey(surveyId, surveyId, surveyId, 'equatorial', 9, { imgFormat: 'jpeg' }); if (hpx) { aladin.setOverlayImageLayer(hpx, 'blend'); __blendSurveyId = surveyId; return aladin.getOverlayImageLayer('blend'); } } catch (e) { console.warn('[nova] Could not create/set overlay image survey:', e); } return null; }
            function setBlendOpacity(a) { const v = Math.max(0, Math.min(1, Number(a) || 0)); if (!aladin) return; const layer = ensureBlendLayer(); if (layer && (typeof layer.setOpacity === 'function' || typeof layer.setAlpha === 'function')) { (layer.setOpacity || layer.setAlpha).call(layer, v); return; } try { const survey = aladin.getOverlayImageLayer && aladin.getOverlayImageLayer('blend'); survey?.setOpacity?.(v); } catch(e) {} }
            (function wireBlendAndConstellationUI(){ const blendSel = document.getElementById('blend-survey-select'), blendOp = document.getElementById('blend-opacity'); if (blendSel) blendSel.addEventListener('change', () => { ensureBlendLayer(); const v = Number(blendOp?.value || 0); setBlendOpacity(v); updateFramingChart(false); }); if (blendOp) { const sync = (e) => { setBlendOpacity(e.target.value); updateFramingChart(false); }; blendOp.addEventListener('input', sync); blendOp.addEventListener('change', sync); } try { if (blendOp) setBlendOpacity(blendOp.value); } catch(e) {} })();
            if (aladin.on) aladin.on('zoomChanged', () => { if (!lockToObject) return; const sel = document.getElementById('framing-rig-select'), rot = parseFloat(document.getElementById('framing-rotation')?.value || '0') || 0; if (sel && sel.selectedIndex >= 0) { const opt = sel.options[sel.selectedIndex]; updateScreenFovOverlay(opt.dataset.fovw, opt.dataset.fovh, rot); } });
            if (aladin.on) aladin.on('baseLayerChanged', () => { try { const bop = document.getElementById('blend-opacity'); ensureBlendLayer(); if (bop) setBlendOpacity(bop.value); } catch (e) { console.warn('[nova] Could not reapply blend after base change:', e); } });
            fovLayer = A.graphicOverlay({color: '#83b4c5', lineWidth: 3});
            aladin.addOverlay(fovLayer);
            const canvas = document.getElementById('aladin-lite-div');
            if (window.ResizeObserver && canvas) { let roTimer = null; const ro = new ResizeObserver(() => { clearTimeout(roTimer); roTimer = setTimeout(() => { const sel = document.getElementById('framing-rig-select'); if (sel && sel.selectedIndex >= 0) { const opt = sel.options[sel.selectedIndex]; applyRigFovZoom(opt.dataset.fovw, opt.dataset.fovh); } updateFramingChart(false); if (lockToObject) { const sel = document.getElementById('framing-rig-select'), rot = parseFloat(document.getElementById('framing-rotation')?.value || '0') || 0; if (sel && sel.selectedIndex >= 0) { const opt = sel.options[sel.selectedIndex]; updateScreenFovOverlay(opt.dataset.fovw, opt.dataset.fovh, rot); } } }, 80); }); ro.observe(canvas); }
            (function ensureScreenOverlay(){ const host = document.getElementById('aladin-lite-div'); if (!host) return; if (!host.style.position) host.style.position = 'relative'; if (!document.getElementById('screen-fov-overlay')) { const ov = document.createElement('div'); ov.id = 'screen-fov-overlay'; ov.style.position = 'absolute'; ov.style.inset = '0'; ov.style.pointerEvents = 'none'; ov.style.zIndex = '5'; const rect = document.createElement('div'); rect.id = 'screen-fov-rect'; rect.style.position = 'absolute'; rect.style.border = '3px solid #83b4c5'; rect.style.boxSizing = 'border-box'; rect.style.left = '50%'; rect.style.top = '50%'; rect.style.transformOrigin = 'center center'; rect.style.display = 'none'; ov.appendChild(rect); host.appendChild(ov); } })();
            canvas.addEventListener('click', (ev) => { if (!ev.shiftKey) return; if (lockToObject) return; const rect = canvas.getBoundingClientRect(), x = ev.clientX - rect.left, y = ev.clientY - rect.top; const sky = aladin.pix2world(x, y); if (!sky) return; fovCenter = {ra: sky[0], dec: sky[1]}; updateFramingChart(false); if (lockToObject) { const sel = document.getElementById('framing-rig-select'), rot = parseFloat(document.getElementById('framing-rotation')?.value || '0') || 0; if (sel && sel.selectedIndex >= 0) { const opt = sel.options[sel.selectedIndex]; updateScreenFovOverlay(opt.dataset.fovw, opt.dataset.fovh, rot); } } updateReadoutFromCenter(); });
            window.addEventListener('keydown', (e) => { const k = e.key.toLowerCase(); if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd'].includes(k)) { e.preventDefault(); if (k === 'arrowup' || k === 'w') nudgeFov(0, +1); if (k === 'arrowdown' || k === 's') nudgeFov(0, -1); if (k === 'arrowleft' || k === 'a') nudgeFov(-1, 0); if (k === 'arrowright' || k === 'd') nudgeFov(+1, 0); } });
            (function wireRotationLiveUpdate(){ const rotInput = document.getElementById('framing-rotation'); if (!rotInput) return; const handler = () => { const raw = (typeof rotInput.valueAsNumber === 'number') ? rotInput.valueAsNumber : parseFloat(rotInput.value) || 0; const snapped = (Math.abs(raw) <= 1) ? 0 : raw; if (snapped !== raw) rotInput.value = String(snapped); updateFramingChart(false); }; try { rotInput.removeEventListener('input', rotInput.__novaRotHandler); } catch(e) {} try { rotInput.removeEventListener('change', rotInput.__novaRotHandler); } catch(e) {} rotInput.__novaRotHandler = handler; rotInput.addEventListener('input', handler); rotInput.addEventListener('change', handler); try { rotInput.setAttribute('value', String(rotInput.valueAsNumber ?? rotInput.value ?? 0)); } catch(e) {} handler(); })();
            (function wireInsertIntoProject(){ const btn = document.getElementById('insert-into-project'); if (!btn) return; try { btn.removeEventListener('click', btn.__novaInsertHandler); } catch(e) {} btn.__novaInsertHandler = (ev) => { try { const q = buildFramingQuery(), href = location.pathname + q; history.replaceState(null, '', href); } catch(e) { console.warn('[nova] Insert-to-project wiring error:', e); } }; btn.addEventListener('click', btn.__novaInsertHandler); })();
        }
        function buildFramingQuery() { const sel = document.getElementById('framing-rig-select'), rig = sel && sel.selectedIndex >= 0 ? sel.options[sel.selectedIndex].value : '', rotInput = document.getElementById('framing-rotation'), rot = rotInput ? (parseFloat(rotInput.value) || 0) : 0, sSel = document.getElementById('survey-select'), survey = sSel ? sSel.value : '', bSel = document.getElementById('blend-survey-select'), bOp = document.getElementById('blend-opacity'), blend = bSel ? bSel.value : '', blend_op = bOp ? (parseFloat(bOp.value) || 0) : 0; const { ra, dec } = (fovCenter || (aladin && (() => { const rc = aladin.getRaDec(); return { ra: rc[0], dec: rc[1] }; })()) || { ra: NaN, dec: NaN }); const qp = new URLSearchParams(); if (rig) qp.set('rig', rig); if (Number.isFinite(ra)) qp.set('ra', ra.toFixed(6)); if (Number.isFinite(dec)) qp.set('dec', dec.toFixed(6)); qp.set('rot', String(Math.round(to360(rot)))); if (survey) qp.set('survey', survey); if (blend) qp.set('blend', blend); qp.set('blend_op', String(Math.max(0, Math.min(1, blend_op)))); return '?' + qp.toString(); }
        let haveCenter = false, haveRot = false, haveRigRestored = false;
        try {
            const q = new URLSearchParams(location.search), rig = q.get('rig'), ra = parseFloat(q.get('ra')), dec = parseFloat(q.get('dec')), rot = parseFloat(q.get('rot')), surv = q.get('survey'), blend = q.get('blend'), blendOp = parseFloat(q.get('blend_op'));
            if (rig) { const sel = document.getElementById('framing-rig-select'); if (sel) { const idx = Array.from(sel.options).findIndex(o => o.value === rig); if (idx >= 0) { sel.selectedIndex = idx; haveRigRestored = true; } } }
            if (!Number.isNaN(rot)) { const rotInput = document.getElementById('framing-rotation'), signed = toSigned180(rot); if (rotInput) rotInput.value = signed; const rotSpan = document.getElementById('rotation-value'); if (rotSpan) rotSpan.textContent = `${Math.round(signed)}°`; haveRot = true; }
            if (surv) { if (typeof setSurvey === 'function') setSurvey(surv); else { const s = document.getElementById('survey-select'); if (s) s.value = surv; } }
            try { const bsel = document.getElementById('blend-survey-select'), bop = document.getElementById('blend-opacity'); if (blend && bsel) { bsel.value = blend; if (typeof ensureBlendLayer === 'function') ensureBlendLayer(); } if (!Number.isNaN(blendOp) && bop) { bop.value = String(Math.max(0, Math.min(1, blendOp))); if (typeof setBlendOpacity === 'function') setBlendOpacity(bop.value); } } catch (e) {}
            try { const bop2 = document.getElementById('blend-opacity'); ensureBlendLayer(); if (bop2) setBlendOpacity(bop2.value); } catch (e) {}
            if (!Number.isNaN(ra) && !Number.isNaN(dec)) { fovCenter = {ra, dec}; haveCenter = true; } else fovCenter = null;
        } catch (e) {}
        try { const bop = document.getElementById('blend-opacity'); ensureBlendLayer(); if (bop) setBlendOpacity(bop.value); } catch (e) {}
        if (!haveRot) { const rotInput = document.getElementById('framing-rotation'); if (rotInput) rotInput.value = 0; const rotSpan = document.getElementById('rotation-value'); if (rotSpan) rotSpan.textContent = `0°`; }
        if (haveCenter) { const lockBox = document.getElementById('lock-to-object'); if (lockBox) lockBox.checked = false; lockToObject = false; if (aladin && typeof aladin.gotoRaDec === 'function') aladin.gotoRaDec(fovCenter.ra, fovCenter.dec); if (haveCenter) { const sel = document.getElementById('framing-rig-select'); if (sel && sel.selectedIndex >= 0) { const opt = sel.options[sel.selectedIndex]; applyRigFovZoom(opt.dataset.fovw, opt.dataset.fovh); } } }
        updateFramingChart(haveCenter ? false : true);
        updateFovVsObjectLabel?.();
        updateReadoutFromCenter?.();
        if (!haveCenter) applyLockToObject(true);
    }
    function closeFramingAssistant() { document.getElementById('framing-modal').style.display = 'none'; }
    function flipFraming90() { const slider = document.getElementById('framing-rotation'); let v = parseFloat(slider.value) || 0; v += 90; if (v > 90) v = -90; slider.value = v; slider.dispatchEvent(new Event('input', { bubbles: true })); updateFramingChart(false); if (typeof updateReadoutFromCenter === 'function') updateReadoutFromCenter(); }
    function applyRigFovZoom(fovW_arcmin, fovH_arcmin, rotationDeg = 0, margin = 1.06) {
        if (!aladin) return; const host = document.getElementById('aladin-lite-div'); if (!host) return;
        const wpx = host.clientWidth, hpx = host.clientHeight; if (!(wpx > 0 && hpx > 0)) return; const aspect = wpx / hpx;
        const wDeg = parseFloat(fovW_arcmin) / 60, hDeg = parseFloat(fovH_arcmin) / 60; if (!(isFinite(wDeg) && isFinite(hDeg) && wDeg > 0 && hDeg > 0)) return;
        const th = (parseFloat(rotationDeg) || 0) * Math.PI / 180;
        const needWidthDeg = Math.abs(wDeg * Math.cos(th)) + Math.abs(hDeg * Math.sin(th)), needHeightDeg = Math.abs(wDeg * Math.sin(th)) + Math.abs(hDeg * Math.cos(th));
        const requiredWidthDeg = Math.max(needWidthDeg * margin, needHeightDeg * margin * aspect);
        aladin.setFov(requiredWidthDeg);
        if (lockToObject) updateScreenFovOverlay(fovW_arcmin, fovH_arcmin, rotationDeg);
    }
    window.updateFramingChart = function (recenter = true) {
        if (!aladin) return;
        const objectName = "{{ object_name }}", framingRigSelect = document.getElementById('framing-rig-select'), rotationSlider = document.getElementById('framing-rotation'), selectedOption = framingRigSelect.options[framingRigSelect.selectedIndex];
        if (!selectedOption) return;
        const fovWidthArcmin = parseFloat(selectedOption.dataset.fovw), fovHeightArcmin = parseFloat(selectedOption.dataset.fovh);
        const vNum = (rotationSlider && typeof rotationSlider.valueAsNumber === 'number') ? rotationSlider.valueAsNumber : NaN;
        const rotation = Number.isFinite(vNum) ? vNum : (Number.isFinite(parseFloat(rotationSlider.value)) ? parseFloat(rotationSlider.value) : 0);
        (function updateRotationBadge(){ const el = document.getElementById('rotation-value'), sliderEl = document.getElementById('framing-rotation'), txt = `${Math.round(toSigned180(rotation))}°`; if (el) el.textContent = txt; if (sliderEl) sliderEl.title = `Rotation: ${txt}`; })();
        if (recenter) applyRigFovZoom(fovWidthArcmin, fovHeightArcmin, rotation);
        if (recenter) {
            aladin.gotoObject(objectName, {
                success: () => { applyRigFovZoom(fovWidthArcmin, fovHeightArcmin, rotation); const rc = aladin.getRaDec(); objectCoords = {ra: rc[0], dec: rc[1]}; fovCenter = lockToObject ? {...objectCoords} : {ra: rc[0], dec: rc[1]}; if (lockToObject) { if (fovLayer) fovLayer.removeAll(); updateScreenFovOverlay(fovWidthArcmin, fovHeightArcmin, rotation); } else drawFovFootprint(fovWidthArcmin, fovHeightArcmin, rotation, fovCenter); updateReadoutFromCenter?.(); },
                error: () => { const rc = aladin.getRaDec(); fovCenter = {ra: rc[0], dec: rc[1]}; if (lockToObject) { if (fovLayer) fovLayer.removeAll(); updateScreenFovOverlay(fovWidthArcmin, fovHeightArcmin, rotation); } else drawFovFootprint(fovWidthArcmin, fovHeightArcmin, rotation, fovCenter); updateReadoutFromCenter?.(); }
            }); return;
        }
        if (!fovCenter) { const rc = aladin.getRaDec(); fovCenter = {ra: rc[0], dec: rc[1]}; }
        if (lockToObject) { if (fovLayer) fovLayer.removeAll(); updateScreenFovOverlay(fovWidthArcmin, fovHeightArcmin, rotation); }
        else drawFovFootprint(fovWidthArcmin, fovHeightArcmin, rotation, fovCenter);
    };
    function drawFovFootprint(fovWidthArcmin, fovHeightArcmin, rotationDeg, center) {
        if (!aladin || !fovLayer || !center) return;
        fovLayer.removeAll();
        const halfW = (fovWidthArcmin / 60) / 2, halfH = (fovHeightArcmin / 60) / 2, ang = rotationDeg * Math.PI / 180;
        const ra0 = center.ra * Math.PI / 180, dec0 = center.dec * Math.PI / 180;
        const cX = Math.cos(dec0) * Math.cos(ra0), cY = Math.cos(dec0) * Math.sin(ra0), cZ = Math.sin(dec0);
        const eX = -Math.sin(ra0), eY = Math.cos(ra0), eZ = 0;
        const nX = -Math.sin(dec0) * Math.cos(ra0), nY = -Math.sin(dec0) * Math.sin(ra0), nZ = Math.cos(dec0);
        function rot2d(x, y) { return [x * Math.cos(ang) - y * Math.sin(ang), x * Math.sin(ang) + y * Math.cos(ang)]; }
        const raw = [[-halfW, -halfH], [halfW, -halfH], [halfW, halfH], [-halfW, halfH]].map(([x, y]) => rot2d(x, y));
        function planeToSky(x_deg, y_deg) {
            const dx = x_deg * Math.PI / 180, dy = y_deg * Math.PI / 180, r = Math.hypot(dx, dy);
            if (r < 1e-12) return [center.ra, center.dec];
            const dirX = (dx * eX + dy * nX) / r, dirY = (dx * eY + dy * nY) / r, dirZ = (dx * eZ + dy * nZ) / r;
            const s = Math.sin(r), c = Math.cos(r);
            const pX = c * cX + s * dirX, pY = c * cY + s * dirY, pZ = c * cZ + s * dirZ;
            let ra = Math.atan2(pY, pX); if (ra < 0) ra += 2 * Math.PI; const dec = Math.asin(pZ);
            return [ra * 180 / Math.PI, dec * 180 / Math.PI];
        }
        const polyCoords = raw.map(([x, y]) => planeToSky(x, y));
        polyCoords.push(polyCoords[0]);
        const fovPolygon = A.polygon(polyCoords, {color: '#83b4c5', lineWidth: 3});
        const fovFootprint = A.footprint(fovPolygon);
        fovLayer.add(fovFootprint);
        updateReadoutFromCenter?.();
    }
    let lockFovEnabled = false, lockRafId = null;
    function updateScreenFovOverlay(fovWidthArcmin, fovHeightArcmin, rotationDeg) {
            const host = document.getElementById('aladin-lite-div');
            const rectEl = document.getElementById('screen-fov-rect');
            if (!host || !rectEl) return;

            const wpx = host.clientWidth || 1;
            const hpx = host.clientHeight || 1;

            const gf = aladin.getFov();
            const viewWdeg = Array.isArray(gf) ? (gf[0] ?? 1) : (gf ?? 1);

            // This is the corrected logic
            const viewHdeg = viewWdeg * (hpx / wpx); // Calculate the view's height in degrees
            const fovWdeg = (parseFloat(fovWidthArcmin) || 0) / 60;
            const fovHdeg = (parseFloat(fovHeightArcmin) || 0) / 60;
            if (!(fovWdeg > 0 && fovHdeg > 0)) return;

            const pxW = Math.max(2, (fovWdeg / viewWdeg) * wpx);
            const pxH = Math.max(2, (fovHdeg / viewHdeg) * hpx); // <-- THIS LINE IS FIXED

            rectEl.style.display = 'block';
            rectEl.style.width = pxW + 'px';
            rectEl.style.height = pxH + 'px';
            rectEl.style.marginLeft = (-pxW / 2) + 'px';
            rectEl.style.marginTop = (-pxH / 2) + 'px';
            rectEl.style.transform = `translate(0,0) rotate(${rotationDeg || 0}deg)`;
        }
    function startLockOverlayLoop() { if (lockRafId) return; const tick = () => { if (!lockToObject) { lockRafId = null; return; } const sel = document.getElementById('framing-rig-select'), rot = parseFloat(document.getElementById('framing-rotation')?.value || '0') || 0; if (sel && sel.selectedIndex >= 0) { const opt = sel.options[sel.selectedIndex]; updateScreenFovOverlay(opt.dataset.fovw, opt.dataset.fovh, rot); } updateReadoutFromCenter(); lockRafId = requestAnimationFrame(tick); }; lockRafId = requestAnimationFrame(tick); }
    function stopLockOverlayLoop() { if (lockRafId) { cancelAnimationFrame(lockRafId); lockRafId = null; } }
    function setSurvey(hipsId) { if (!aladin) return; const newLayer = aladin.newImageSurvey(hipsId); aladin.setBaseImageLayer(newLayer); baseSurvey = aladin.getBaseImageLayer(); updateImageAdjustments(); }
    function updateImageAdjustments() { if (!baseSurvey) return; const b = parseFloat(document.getElementById('img-bright').value), c = parseFloat(document.getElementById('img-contrast').value), g = parseFloat(document.getElementById('img-gamma').value), s = parseFloat(document.getElementById('img-sat').value); baseSurvey.setBrightness(b); baseSurvey.setContrast(c); baseSurvey.setGamma(g); baseSurvey.setSaturation(s); }
    function updateReadout(raDeg, decDeg) { document.getElementById('ra-readout').value = formatRA(raDeg); document.getElementById('dec-readout').value = formatDec(decDeg); }
    function updateReadoutFromCenter() { let center; if (lockToObject) { const rc = aladin.getRaDec(); center = { ra: rc[0], dec: rc[1] }; } else if (fovCenter && isFinite(fovCenter.ra) && isFinite(fovCenter.dec)) center = fovCenter; else { const rc = aladin.getRaDec(); center = { ra: rc[0], dec: rc[1] }; } updateReadout(center.ra, center.dec); }
    function copyRaDec() { const text = `${document.getElementById('ra-readout').value} ${document.getElementById('dec-readout').value}`; navigator.clipboard.writeText(text); }
    function changeView(view) {
        const day = document.getElementById('day-select').value, month = document.getElementById('month-select').value, year = document.getElementById('year-select').value, objectName = "{{ object_name }}";
        fetch(`/get_date_info/${encodeURIComponent(objectName)}?day=${day}&month=${month}&year=${year}`).then(response => response.json()).then(data => { document.getElementById("date-display").innerText = formatDateISOtoEuropean(data.date); document.getElementById("phase-display").innerText = data.phase + "%"; document.getElementById("dusk-display").innerText = data.astronomical_dusk; document.getElementById("dawn-display").innerText = data.astronomical_dawn; });
        if (view === 'day') renderClientSideChart();
        else renderMonthlyYearlyChart(view);
    }
    function useReadoutAsFovCenter() { const raStr = document.getElementById('ra-readout').value, decStr = document.getElementById('dec-readout').value, sky = parseRaDec(raStr, decStr); if (!sky) return; fovCenter = {ra: sky.ra, dec: sky.dec}; updateFramingChart(false); updateReadoutFromCenter(); }
    function resetFovCenterToObject() { fovCenter = null; updateFramingChart(true); updateFovVsObjectLabel(); }
    function nudgeFov(dxArcmin, dyArcmin) {
        if (lockToObject && objectCoords) { fovCenter = {ra: objectCoords.ra, dec: objectCoords.dec}; updateFramingChart(false); updateReadoutFromCenter(); return; }
        if (!fovCenter) { const rc = aladin.getRaDec(); fovCenter = {ra: rc[0], dec: rc[1]}; }
        const decRad = fovCenter.dec * (Math.PI / 180);
        if (Math.abs(decRad) < (Math.PI / 2.0 - 0.001)) fovCenter.ra -= (dxArcmin / 60.0) / Math.cos(decRad);
        fovCenter.dec += dyArcmin / 60.0;
        updateFramingChart(false); updateReadoutFromCenter();
    }
    function applyLockToObject(locked) {
        lockToObject = !!locked;
        const rectEl = document.getElementById('screen-fov-rect');
        if (lockToObject) {
            const c = objectCoords || (() => { const rc = aladin.getRaDec(); return {ra: rc[0], dec: rc[1]}; })();
            fovCenter = {ra: c.ra, dec: c.dec};
            if (fovLayer) fovLayer.removeAll();
            if (rectEl) rectEl.style.display = 'block';
            const sel = document.getElementById('framing-rig-select'), rot = parseFloat(document.getElementById('framing-rotation')?.value || '0') || 0;
            if (sel && sel.selectedIndex >= 0) { const opt = sel.options[sel.selectedIndex]; updateScreenFovOverlay(opt.dataset.fovw, opt.dataset.fovh, rot); }
            startLockOverlayLoop(); updateReadoutFromCenter();
        } else {
            if (rectEl) rectEl.style.display = 'none';
            stopLockOverlayLoop();
            const sel = document.getElementById('framing-rig-select'), rot = parseFloat(document.getElementById('framing-rotation')?.value || '0') || 0;
            const center = fovCenter || (() => { const rc = aladin.getRaDec(); return {ra: rc[0], dec: rc[1]}; })();
            if (sel && sel.selectedIndex >= 0) { const opt = sel.options[sel.selectedIndex]; drawFovFootprint(parseFloat(opt.dataset.fovw), parseFloat(opt.dataset.fovh), rot, center); }
            updateReadoutFromCenter();
        }
    }
    function updateFovVsObjectLabel() { const el = document.getElementById('fov-vs-object'); if (!el) return; const sel = document.getElementById('framing-rig-select'); if (!sel || sel.selectedIndex < 0) { el.textContent = ''; return; } const opt = sel.options[sel.selectedIndex]; const fovW = parseFloat(opt.dataset.fovw), fovH = parseFloat(opt.dataset.fovh); if (!isFinite(fovW) || !isFinite(fovH)) { el.textContent = ''; return; } let text = `FOV (Rig): ${Math.round(fovW)}′ × ${Math.round(fovH)}′`; if (typeof OBJECT_SIZE_ARCMIN === 'number' && isFinite(OBJECT_SIZE_ARCMIN) && OBJECT_SIZE_ARCMIN > 0) { const minSide = Math.min(fovW, fovH), fitAcross = minSide / OBJECT_SIZE_ARCMIN; text += ` • Object ~ ${Math.round(OBJECT_SIZE_ARCMIN)}′ → ${fitAcross >= 1 ? 'fits' : 'spans'} ${fitAcross.toFixed(1)}× ${fitAcross >= 1 ? 'across' : 'of'} short side`; } el.textContent = text; }
    (function recenterViewWhenLocked() { const canvas = document.getElementById('aladin-lite-div'); if (!canvas) return; canvas.addEventListener('mouseup', () => { if (lockToObject && objectCoords) aladin.gotoObject([objectCoords.ra, objectCoords.dec]); }); })();
    function pad(n, w = 2) { return n.toString().padStart(w, '0'); }
    function formatRA(raDeg) { const totalSec = raDeg / 15 * 3600, h = Math.floor(totalSec / 3600), m = Math.floor((totalSec % 3600) / 60), s = (totalSec % 60).toFixed(2); return `${pad(h)}:${pad(m)}:${pad(s, 5)}`; }
    function formatDec(decDeg) { const sign = decDeg >= 0 ? '+' : '-', abs = Math.abs(decDeg), d = Math.floor(abs), m = Math.floor((abs - d) * 60), s = ((abs - d) * 60 - m) * 60; return `${sign}${pad(d)}:${pad(m)}:${s.toFixed(1).padStart(4, '0')}`; }
    function getFrameCenterRaDec() { if (lockToObject) { const rc = aladin.getRaDec(); return { ra: rc[0], dec: rc[1] }; } if (fovCenter && isFinite(fovCenter.ra) && isFinite(fovCenter.dec)) return fovCenter; const rc = aladin.getRaDec(); return { ra: rc[0], dec: rc[1] }; }
    function parseRaDec(raHMS, decDMS) { try { const [h, m, s] = raHMS.split(':').map(parseFloat), ra = (h + m / 60 + s / 3600) * 15.0, sign = decDMS.trim()[0] === '-' ? -1 : 1, [d, dm, ds] = decDMS.replace('+', '').replace('-', '').split(':').map(parseFloat), dec = sign * (d + dm / 60 + ds / 3600); return {ra, dec}; } catch (e) { return null; } }
    function formatDateISOtoEuropean(iso_str) { if (!iso_str || typeof iso_str !== 'string') return 'N/A'; const parts = iso_str.split("-"); if (parts.length !== 3) { console.warn("formatDateISOtoEuropean received unexpected format:", iso_str); return iso_str; } const [year, month, day] = parts; return `${day}.${month}.${year}`; }
    function setLocation() { const selectedLocation = document.getElementById('location-select').value; fetch('/set_location', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({location: selectedLocation}) }).then(response => response.json()).then(data => { if (data.status === 'success') refreshChart(); else console.error("Location update failed:", data); }).catch(error => console.error('Error setting location:', error)); }
    function saveProject() { const newProject = document.getElementById('project-field').value, objectName = "{{ object_name }}"; fetch('/update_project', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({object: objectName, project: newProject}) }).then(res => res.json()).then(data => { alert(data.status === "success" ? "Project updated successfully!" : data.error); }); }
    function insertFramingIntoProject() { try { const ta = document.getElementById('project-field'); if (!ta) { alert('Project notes box not found.'); return; } const sel = document.getElementById('framing-rig-select'), rigId = sel?.value || '', rigName = (sel && sel.selectedIndex >= 0) ? sel.options[sel.selectedIndex].textContent.trim() : 'rig?', rotInput = document.getElementById('framing-rotation'), rotDeg = Math.round(parseFloat(rotInput?.value ?? '0')) || 0, survSel = document.getElementById('survey-select'), survey = survSel?.value || '', blendSel = document.getElementById('blend-survey-select'), blendSurvey = blendSel?.value || '', blendOpEl = document.getElementById('blend-opacity'), blendOp = Math.max(0, Math.min(1, parseFloat(blendOpEl?.value ?? '0') || 0)); const center = getFrameCenterRaDec(), raDeg = center.ra, decDeg = center.dec; updateReadout(raDeg, decDeg); const qs = new URLSearchParams(); if (rigId) qs.set('rig', rigId); if (Number.isFinite(raDeg)) qs.set('ra', raDeg.toFixed(6)); if (Number.isFinite(decDeg)) qs.set('dec', decDeg.toFixed(6)); qs.set('rot', String(rotDeg)); if (survey) qs.set('survey', survey); if (blendSurvey) qs.set('blend', blendSurvey); qs.set('blend_op', String(blendOp)); const url = `${location.origin}${location.pathname}?${qs.toString()}`; const objectName = "{{ object_name }}", centerTxt = `RA ${formatRA(raDeg)}, Dec ${formatDec(decDeg)}`, line = `[Framing:${objectName}] ${rigName}, rot ${rotDeg}\u00B0, ${centerTxt}, survey ${survey || 'default'}${blendSurvey ? ` + blend ${blendSurvey} @ ${blendOp}` : ''}`; const lines = ta.value.split(/\r?\n/), out = []; for (let i = 0; i < lines.length; i++) { const L = lines[i]; if (/^\[Framing:/.test(L)) { if (L.startsWith(`[Framing:${objectName}]`)) { const maybeUrl = lines[i + 1] || ''; if (/^https?:\/\//i.test(maybeUrl)) i++; continue; } } out.push(L); } if (out.length && out[out.length - 1] !== '') out.push(''); out.push(line); out.push(url); ta.value = out.join('\n'); ta.dispatchEvent(new Event('input', { bubbles: true })); ta.scrollTop = ta.scrollHeight; setProjectQuickLink(url); } catch (e) { console.error('insertFramingIntoProject failed', e); alert('Could not insert framing into Project. See console for details.'); } }
    function copyFramingUrl() { try { const q = buildFramingQuery(), url = location.origin + location.pathname + q; navigator.clipboard.writeText(url); console.log("[Framing] Copied URL:", url); } catch (e) { console.warn("[Framing] copyFramingUrl failed:", e); } }
    function toggleSimbad() { var container = document.getElementById('simbadContainer'); const objectName = "{{ object_name }}"; if (container.style.display === 'none' || container.style.display === '') { document.getElementById('simbadIframe').src = "https://simbad.u-strasbg.fr/simbad/sim-id?Ident=" + encodeURIComponent(objectName); container.style.display = 'block'; } else container.style.display = 'none'; }
    function loadImagingOpportunities() { document.getElementById("opportunities-section").style.display = "block"; const tbody = document.getElementById("opportunities-body"); tbody.innerHTML = `<tr><td colspan="9">Searching...</td></tr>`; const objectName = "{{ object_name }}"; fetch(`/get_imaging_opportunities/${encodeURIComponent(objectName)}`).then(response => response.json()).then(data => { if (data.status === "success") { if (data.results.length === 0) { tbody.innerHTML = `<tr><td colspan="9">No good dates found matching your criteria.</td></tr>`; return; } let htmlRows = ""; const selectedDateStr = `${document.getElementById('year-select').value.padStart(4, '0')}-${document.getElementById('month-select').value.padStart(2, '0')}-${document.getElementById('day-select').value.padStart(2, '0')}`, plotLat = "{{ graph_lat_param }}", plotLon = "{{ graph_lon_param }}"; data.results.forEach(r => { const isSelected = r.date === selectedDateStr, formattedDate = formatDateISOtoEuropean(r.date), ics_url = `/generate_ics/${encodeURIComponent(objectName)}?date=${r.date}&tz=${encodeURIComponent(plotTz)}&lat=${plotLat}&lon=${plotLon}&max_alt=${r.max_alt}&moon_illum=${r.moon_illumination}&obs_dur=${r.obs_minutes}&from_time=${r.from_time}&to_time=${r.to_time}`, filename = `imaging_${objectName.replace(/\s+/g, '_')}_${r.date}.ics`; htmlRows += `<tr class="${isSelected ? 'highlight' : ''}" data-date="${r.date}" onclick="selectSuggestedDate('${r.date}')" style="cursor: pointer;"><td>${formattedDate}</td><td>${r.from_time}</td><td>${r.to_time}</td><td>${r.obs_minutes}</td><td>${r.max_alt}</td><td>${r.moon_illumination}</td><td>${r.moon_separation}</td><td>${r.rating || ""}</td><td onclick="event.stopPropagation();"><a href="${ics_url}" download="${filename}" title="Add to calendar" style="font-size: 1.5em; text-decoration: none;">🗓️</a></td></tr>`; }); tbody.innerHTML = htmlRows; } else tbody.innerHTML = `<tr><td colspan="9">Error: ${data.message}</td></tr>`; }); }
    function selectSuggestedDate(dateStr) { const [year, month, day] = dateStr.split('-').map(Number); document.getElementById('year-select').value = year; document.getElementById('month-select').value = month; document.getElementById('day-select').value = day; changeView('day'); setTimeout(() => { const rows = document.getElementById("opportunities-body").querySelectorAll("tr"); rows.forEach(row => { row.classList.toggle("highlight", row.getAttribute("data-date") === dateStr); }); }, 100); }
    function openInStellarium() { document.getElementById('stellarium-status').textContent = "Sending object to Stellarium..."; document.getElementById('stellarium-status').style.color = "#666"; const objectName = "{{ object_name }}"; fetch("/proxy_focus", { method: "POST", headers: {"Content-Type": "application/x-www-form-urlencoded"}, body: new URLSearchParams({target: objectName, mode: "center"}) }).then(async response => { let data; try { data = await response.json(); } catch (e) { data = {message: "Could not parse server response."}; } if (response.ok && data.status === "success") { document.getElementById('stellarium-status').textContent = "Stellarium view updated!"; document.getElementById('stellarium-status').style.color = "#83b4c5"; } else document.getElementById('stellarium-status').innerHTML = `<p style="color:red; margin:0;">Error: ${data.message || "Unknown error"}</p>`; }); }

    window.addEventListener('load', () => {
        if (window['chartjs-plugin-annotation']) Chart.register(window['chartjs-plugin-annotation']);
        const savedTab = localStorage.getItem('activeGraphTab') || 'chart';
        showTab(savedTab);
        changeView('day');
        const lockBox = document.getElementById('lock-to-object');
        if (lockBox) lockBox.checked = true;
        const q = new URLSearchParams(location.search);
        if (q.has('rig') && (q.has('ra') || q.has('dec'))) setTimeout(() => openFramingAssistant(), 0);
        const dateEl = document.getElementById("date-display");
        if (dateEl && dateEl.innerText.includes("-")) dateEl.innerText = formatDateISOtoEuropean(dateEl.innerText);
        const dayInput = document.getElementById("day-select"), monthSelect = document.getElementById("month-select"), yearInput = document.getElementById("year-select");
        function updateDayLimit() { const year = parseInt(yearInput.value), month = parseInt(monthSelect.value), daysInMonth = new Date(year, month, 0).getDate(); if (parseInt(dayInput.value) > daysInMonth) dayInput.value = daysInMonth; dayInput.max = daysInMonth; }
        monthSelect.addEventListener("change", updateDayLimit);
        yearInput.addEventListener("change", updateDayLimit);
        updateDayLimit();
        const framingModal = document.getElementById('framing-modal');
        window.addEventListener('click', function (event) { if (event.target == framingModal) closeFramingAssistant(); });
        window.addEventListener('resize', () => { if (document.getElementById('framing-modal').style.display === 'block') if (aladin) updateFramingChart(false); });
        const ta = document.getElementById('project-field');
        if (ta) { const m = ta.value.match(/\bhttps?:\/\/[^\s<>"']+/g); if (m && m.length) setProjectQuickLink(m[m.length - 1]); }
    });
</script>

{% endblock %}