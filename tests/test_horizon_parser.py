"""
Unit tests for the .hzn horizon file parser functionality.

This module tests the parseStellariumHorizon function that processes
Stellarium horizon files and converts them to the internal format.
"""

import pytest
import os


# Test horizon file content samples
VALID_HZN_CONTENT = """# Stellarium horizon file
# Generated by Stellarium
0 10
45 15
90 5
135 20
180 10
225 15
270 8
315 12
360 10
"""

HZN_WITH_COMMENTS = """# Horizon data
# Comment line
; Another comment
0 10
90 20
# Inline comment shouldn't break
180 15
270 10
360 10
"""

HZN_WITH_COMMAS = """0, 10
90, 20
180, 15
270, 10
360, 10
"""

HZN_WITH_MIXED_DELIMITERS = """0 10
90, 20
180\t15
270   10
360 10
"""

HZN_WITH_DECIMALS = """0 10.5
90 20.3
180 15.7
270 8.2
360 10.9
"""

EMPTY_HZN = """# Only comments
# No data here
"""

HZN_WITH_INVALID_DATA = """0 abc
xyz 10
# Valid data
90 20
"""

HZN_LARGE_FILE = """# Large horizon file with 200 points
""" + "\n".join([f"{i*1.8} {abs(10 - (i % 20))}" for i in range(200)])


class TestStellariumHorizonParser:
    """Test suite for the parseStellariumHorizon JavaScript function.

    Since parseStellariumHorizon is a client-side JavaScript function,
    we test the parsing logic in Python to ensure the algorithm works correctly.
    The Python implementation should mirror the JavaScript logic.
    """

    def parse_stellarium_horizon(self, content):
        """
        Python implementation of the parseStellariumHorizon logic for testing.

        This mirrors the JavaScript function in config_form.js:
        - Parse lines containing azimuth and altitude values
        - Skip comments (lines starting with # or ;)
        - Skip empty lines
        - Split by whitespace or commas
        - Round to one decimal place
        - Sort by azimuth
        - Simplify to ~100 points if there are more
        """
        lines = content.split('\n')
        points = []

        for line in lines:
            trimmed = line.strip()
            if not trimmed or trimmed.startswith('#') or trimmed.startswith(';'):
                continue

            # Split by whitespace or commas
            parts = trimmed.replace(',', ' ').split()
            if len(parts) >= 2:
                try:
                    az = float(parts[0])
                    alt = float(parts[1])
                    points.append([round(az * 10) / 10, round(alt * 10) / 10])
                except (ValueError, IndexError):
                    continue

        if len(points) == 0:
            return None

        # Sort by azimuth
        points.sort(key=lambda p: p[0])

        # Simplify if too many points: keep every Nth to get ~100
        if len(points) > 100:
            step = (len(points) + 99) // 100  # ceil(len / 100)
            simplified = []
            for i in range(0, len(points), step):
                simplified.append(points[i])
            # Always include the last point
            if simplified[-1] != points[-1]:
                simplified.append(points[-1])
            points = simplified

        return points

    def test_valid_basic_hzn(self):
        """Test parsing a valid basic .hzn file."""
        result = self.parse_stellarium_horizon(VALID_HZN_CONTENT)
        assert result is not None
        assert len(result) == 9  # 0-360 degrees (9 points)
        assert result[0] == [0, 10.0]
        assert result[1] == [45, 15.0]
        assert result[2] == [90, 5.0]

    def test_hzn_with_comments(self):
        """Test that comments are properly skipped."""
        result = self.parse_stellarium_horizon(HZN_WITH_COMMENTS)
        assert result is not None
        assert len(result) == 5  # 5 data points, comments skipped

    def test_hzn_with_commas(self):
        """Test that comma delimiters work."""
        result = self.parse_stellarium_horizon(HZN_WITH_COMMAS)
        assert result is not None
        assert len(result) == 5
        assert result[0] == [0, 10.0]

    def test_hzn_with_mixed_delimiters(self):
        """Test mixed delimiter types (spaces, commas, tabs)."""
        result = self.parse_stellarium_horizon(HZN_WITH_MIXED_DELIMITERS)
        assert result is not None
        assert len(result) == 5

    def test_hzn_with_decimals(self):
        """Test that decimal values are properly rounded."""
        result = self.parse_stellarium_horizon(HZN_WITH_DECIMALS)
        assert result is not None
        # Check rounding to one decimal place
        assert result[0] == [0, 10.5]
        assert result[1] == [90, 20.3]
        assert result[2] == [180, 15.7]

    def test_empty_hzn(self):
        """Test that empty .hzn files return None."""
        result = self.parse_stellarium_horizon(EMPTY_HZN)
        assert result is None

    def test_hzn_with_invalid_data(self):
        """Test that invalid data lines are skipped."""
        result = self.parse_stellarium_horizon(HZN_WITH_INVALID_DATA)
        assert result is not None
        # Only the valid line (90 20) should be included
        assert len(result) == 1
        assert result[0] == [90, 20.0]

    def test_hzn_sorting_by_azimuth(self):
        """Test that points are sorted by azimuth."""
        unsorted_content = """180 10
90 20
270 15
0 10
360 10
"""
        result = self.parse_stellarium_horizon(unsorted_content)
        assert result is not None
        assert result[0][0] == 0
        assert result[1][0] == 90
        assert result[2][0] == 180
        assert result[3][0] == 270
        assert result[4][0] == 360

    def test_hzn_simplification(self):
        """Test that large files are simplified to ~100 points."""
        result = self.parse_stellarium_horizon(HZN_LARGE_FILE)
        assert result is not None
        # Should be ~100 points (actually slightly less due to step calculation)
        assert len(result) <= 105  # Allow some flexibility
        assert len(result) >= 90

    def test_format_output(self):
        """Test that the output format matches expectations."""
        result = self.parse_stellarium_horizon(VALID_HZN_CONTENT)
        # The JavaScript function formats as: [[az, alt], [az, alt], ...]
        # Each point should be a list of two numbers
        for point in result:
            assert isinstance(point, list)
            assert len(point) == 2
            assert isinstance(point[0], (int, float))  # azimuth
            assert isinstance(point[1], (int, float))  # altitude

    def test_hzn_with_extra_whitespace(self):
        """Test handling of extra whitespace."""
        content = """   0   10

  90  20
   """
        result = self.parse_stellarium_horizon(content)
        assert result is not None
        assert len(result) == 2

    def test_hzn_with_negative_altitudes(self):
        """Test handling of negative altitude values (below horizon)."""
        content = """0 -5
90 10
180 -2
270 15
"""
        result = self.parse_stellarium_horizon(content)
        assert result is not None
        assert len(result) == 4
        assert result[0][1] == -5.0

    def test_hzn_azimuth_range(self):
        """Test that azimuth values are in the expected range."""
        content = """0 10
180 15
360 20
"""
        result = self.parse_stellarium_horizon(content)
        assert result is not None
        assert all(0 <= p[0] <= 360 for p in result)


class TestHorizonErrorHandling:
    """Test error handling and edge cases for the .hzn parser."""

    def parse_stellarium_horizon(self, content):
        """Helper function mirroring JavaScript logic."""
        lines = content.split('\n')
        points = []

        for line in lines:
            trimmed = line.strip()
            if not trimmed or trimmed.startswith('#') or trimmed.startswith(';'):
                continue

            parts = trimmed.replace(',', ' ').split()
            if len(parts) >= 2:
                try:
                    az = float(parts[0])
                    alt = float(parts[1])
                    points.append([round(az * 10) / 10, round(alt * 10) / 10])
                except (ValueError, IndexError):
                    continue

        if len(points) == 0:
            return None

        points.sort(key=lambda p: p[0])

        if len(points) > 100:
            step = (len(points) + 99) // 100
            simplified = []
            for i in range(0, len(points), step):
                simplified.append(points[i])
            if simplified[-1] != points[-1]:
                simplified.append(points[-1])
            points = simplified

        return points

    def test_malformed_line_in_middle(self):
        """Test that malformed lines in the middle don't break parsing."""
        content = """0 10
invalid data here
90 20
also invalid
180 15
"""
        result = self.parse_stellarium_horizon(content)
        assert result is not None
        assert len(result) == 3

    def test_trailing_whitespace(self):
        """Test handling of trailing whitespace in lines."""
        content = """0 10 \t
90 20
180 15
"""
        result = self.parse_stellarium_horizon(content)
        assert result is not None
        assert len(result) == 3

    def test_unicode_characters(self):
        """Test handling of Unicode characters in comments."""
        content = """# Comment with Ã©mojis: ðŸŒ
0 10
# Another comment: ä½ å¥½
90 20
"""
        result = self.parse_stellarium_horizon(content)
        assert result is not None
        assert len(result) == 2

    def test_single_point(self):
        """Test handling of a single data point."""
        content = """0 10
"""
        result = self.parse_stellarium_horizon(content)
        assert result is not None
        assert len(result) == 1
        assert result[0] == [0, 10.0]

    def test_duplicate_azimuths(self):
        """Test handling of duplicate azimuth values."""
        content = """0 10
0 20
90 15
"""
        result = self.parse_stellarium_horizon(content)
        assert result is not None
        # Both points should be included (sorting keeps order of appearance)
        assert len(result) == 3

    def test_file_with_only_whitespace_lines(self):
        """Test that files with only whitespace lines return None."""
        content = """

   \t

"""
        result = self.parse_stellarium_horizon(content)
        assert result is None

    def test_extreme_values(self):
        """Test handling of extreme but valid azimuth/altitude values."""
        content = """0 90
180 0
360 -10
"""
        result = self.parse_stellarium_horizon(content)
        assert result is not None
        assert len(result) == 3
        assert result[0][1] == 90.0
        assert result[2][1] == -10.0

    def test_format_output_json_compatible(self):
        """Test that output format is JSON-compatible for backend parsing."""
        import json
        result = self.parse_stellarium_horizon(VALID_HZN_CONTENT)
        assert result is not None

        # Format as JSON string (mimicking JavaScript output)
        formatted = '[' + ', '.join([f'[{p[0]}, {p[1]}]' for p in result]) + ']'

        # Should be parseable as JSON
        parsed = json.loads(formatted)
        assert len(parsed) == len(result)
        for i, point in enumerate(parsed):
            assert len(point) == 2
            assert isinstance(point[0], (int, float))
            assert isinstance(point[1], (int, float))

    def test_backend_yaml_compatibility(self):
        """Test that output format can be parsed by YAML (as backend does)."""
        import yaml
        result = self.parse_stellarium_horizon(VALID_HZN_CONTENT)
        assert result is not None

        # Format as YAML-compatible string (mimicking JavaScript output)
        formatted = '[' + ', '.join([f'[{p[0]}, {p[1]}]' for p in result]) + ']'

        # Should be parseable as YAML (backend uses yaml.safe_load)
        parsed = yaml.safe_load(formatted)
        assert len(parsed) == len(result)
        for point in parsed:
            assert len(point) == 2

    def test_numbers_with_many_decimals(self):
        """Test that values with many decimal places are rounded correctly."""
        content = """0.123456789 10.987654321
90.111111111 20.222222222
"""
        result = self.parse_stellarium_horizon(content)
        assert result is not None
        assert len(result) == 2
        # Should be rounded to 1 decimal place
        assert result[0][0] == 0.1
        assert result[0][1] == 11.0
        assert result[1][0] == 90.1
        assert result[1][1] == 20.2


class TestHorizonDataFlow:
    """Test the complete data flow from file parsing to backend storage format."""

    def parse_stellarium_horizon(self, content):
        """Helper function mirroring JavaScript logic."""
        lines = content.split('\n')
        points = []

        for line in lines:
            trimmed = line.strip()
            if not trimmed or trimmed.startswith('#') or trimmed.startswith(';'):
                continue

            parts = trimmed.replace(',', ' ').split()
            if len(parts) >= 2:
                try:
                    az = float(parts[0])
                    alt = float(parts[1])
                    points.append([round(az * 10) / 10, round(alt * 10) / 10])
                except (ValueError, IndexError):
                    continue

        if len(points) == 0:
            return None

        points.sort(key=lambda p: p[0])

        if len(points) > 100:
            step = (len(points) + 99) // 100
            simplified = []
            for i in range(0, len(points), step):
                simplified.append(points[i])
            if simplified[-1] != points[-1]:
                simplified.append(points[-1])
            points = simplified

        return points

    def format_as_js_output(self, points):
        """Format points as JavaScript does for textarea population."""
        if points is None:
            return ''
        return '[' + ', '.join([f'[{p[0]}, {p[1]}]' for p in points]) + ']'

    def test_complete_data_flow_simulation(self):
        """Simulate the complete data flow: file -> parse -> format -> backend parse."""
        import yaml

        # Simulate .hzn file content
        hzn_content = """# Stellarium horizon file
0 10
45 15.5
90 8.25
135 20
180 12
225 18
270 5
315 14
360 10
"""
        # Step 1: Parse the file (JavaScript parseStellariumHorizon)
        points = self.parse_stellarium_horizon(hzn_content)
        assert points is not None
        assert len(points) == 9

        # Step 2: Format for textarea (JavaScript formatting)
        textarea_value = self.format_as_js_output(points)
        assert textarea_value.startswith('[')
        assert textarea_value.endswith(']')

        # Step 3: Backend parses the textarea value (Python yaml.safe_load)
        backend_parsed = yaml.safe_load(textarea_value)
        assert backend_parsed is not None
        assert len(backend_parsed) == 9

        # Step 4: Verify data integrity through the flow
        for i, (orig, parsed) in enumerate(zip(points, backend_parsed)):
            assert orig[0] == parsed[0], f"Azimuth mismatch at index {i}"
            assert orig[1] == parsed[1], f"Altitude mismatch at index {i}"

    def test_data_flow_with_invalid_lines(self):
        """Test data flow when file contains invalid lines (should be skipped)."""
        import yaml

        hzn_content = """# Valid comments
0 10
INVALID LINE
90 20
# Another comment
ANOTHER INVALID
180 15
"""
        points = self.parse_stellarium_horizon(hzn_content)
        assert points is not None
        assert len(points) == 3  # Only valid lines

        textarea_value = self.format_as_js_output(points)
        backend_parsed = yaml.safe_load(textarea_value)
        assert len(backend_parsed) == 3

    def test_data_flow_empty_file(self):
        """Test data flow when file is empty or has no valid data."""
        hzn_content = """# Only comments
# No data
"""
        points = self.parse_stellarium_horizon(hzn_content)
        assert points is None

        textarea_value = self.format_as_js_output(points)
        assert textarea_value == ''

    def test_realistic_stellarium_export(self):
        """Test with a realistic Stellarium horizon export format."""
        import yaml

        # This is a realistic format from Stellarium
        hzn_content = """# Stellarium horizon line
# Format: azimuth altitude
# Generated: 2024-01-15
0	5.0
10	5.5
20	6.0
30	7.5
40	9.0
50	11.0
60	13.5
70	16.0
80	18.5
90	20.0
100	18.0
110	15.5
120	13.0
130	10.5
140	8.0
150	6.5
160	5.5
170	5.0
180	5.0
190	5.5
200	6.5
210	8.0
220	10.0
230	12.5
240	15.0
250	17.5
260	19.0
270	19.5
280	18.5
290	16.0
300	13.0
310	10.0
320	7.5
330	6.0
340	5.0
350	5.0
360	5.0
"""
        points = self.parse_stellarium_horizon(hzn_content)
        assert points is not None
        assert len(points) == 37

        textarea_value = self.format_as_js_output(points)
        backend_parsed = yaml.safe_load(textarea_value)
        assert len(backend_parsed) == 37

        # Verify sorting by azimuth
        for i in range(1, len(backend_parsed)):
            assert backend_parsed[i][0] >= backend_parsed[i-1][0]
